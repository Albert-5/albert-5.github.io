<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://albert-5.cn/"/>
  <updated>2019-10-01T14:38:27.146Z</updated>
  <id>https://albert-5.cn/</id>
  
  <author>
    <name>albert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快捷键</title>
    <link href="https://albert-5.cn/2019/10/01/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://albert-5.cn/2019/10/01/快捷键/</id>
    <published>2019-10-01T14:34:01.000Z</published>
    <updated>2019-10-01T14:38:27.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center> Photoshop常用快捷键收</center><p><strong>工具快捷键</strong></p><table><thead><tr><th>动作</th><th>Mac</th><th>windows</th></tr></thead><tbody><tr><td>选择工具</td><td>V</td><td>V</td></tr><tr><td>矩形/椭圆工具</td><td>M</td><td>M</td></tr><tr><td>套索工具</td><td>W</td><td>W</td></tr><tr><td>剪裁/切片工具</td><td>C</td><td>C</td></tr><tr><td>滴管/取色/标尺/注释/计数工具</td><td>I</td><td>I</td></tr><tr><td>修复画笔/修补/红眼工具</td><td>J</td><td>J</td></tr><tr><td>画笔/铅笔/颜色替换工具</td><td>B</td><td>B</td></tr><tr><td>图章工具</td><td>S</td><td>S</td></tr><tr><td>历史记录画笔工具</td><td>Y</td><td>Y</td></tr><tr><td>橡皮擦工具</td><td>E</td><td>E</td></tr><tr><td>渐变/油漆桶工具</td><td>G</td><td>G</td></tr><tr><td>减淡/加深/海绵工具</td><td>O</td><td>O</td></tr><tr><td>钢笔工具</td><td>P</td><td>P</td></tr><tr><td>文字工具</td><td>T</td><td>T</td></tr><tr><td>选择工具</td><td>A</td><td>A</td></tr><tr><td>矩形/椭圆/多边形/直线/自定义形状工具</td><td>U</td><td>U</td></tr><tr><td>3D对象工具</td><td>K</td><td>K</td></tr><tr><td>3D相机工具</td><td>N</td><td>N</td></tr><tr><td>抓手工具</td><td>H</td><td>H</td></tr><tr><td>旋转视图工具</td><td>R</td><td>R</td></tr><tr><td>缩放工具</td><td>Z</td></tr></tbody></table><p><strong>图像菜单</strong></p><table><thead><tr><th>动作</th><th>Mac</th><th>Windows</th></tr></thead><tbody><tr><td>调整-色阶</td><td>Cmd+L</td><td>Ctrl+L</td></tr><tr><td>调整-曲线</td><td>Cmd+M</td><td>Ctrl+M</td></tr><tr><td>调整-色相、饱和度</td><td>Cmd+U</td><td>Ctrl+U</td></tr><tr><td>调整-色彩平衡</td><td>Cmd+B</td><td>Ctrl+B</td></tr><tr><td>调整-黑白</td><td>Opt+Shift+Cmd+B</td><td>Alt+Shift+Ctrl+B</td></tr><tr><td>调整-反相</td><td>Cmd+I</td><td>Ctrl+I</td></tr><tr><td>去色</td><td>Shift+Cmd+U</td><td>Shift+Ctrl+U</td></tr><tr><td>自动色调</td><td>Shift+Cmd+L</td><td>Shift+Ctrl+L</td></tr><tr><td>自动对比度</td><td>Opt+Shift+Cmd+L</td><td>Alt+Shift+Ctrl+L</td></tr><tr><td>自动颜色</td><td>Shift+Cmd+B</td><td>Shift+Ctrl+B</td></tr><tr><td>图像大小</td><td>Opt+Cmd+I</td><td>Alt+Ctrl+I</td></tr><tr><td>画布大小</td><td>Opt+Cmd+C</td><td>Alt+Ctrl+C</td></tr><tr><td>记录测量</td><td>Shift+Cmd+M</td><td>Shift+Ctrl+M</td></tr><tr><td>新建-图层</td><td>Shift+Cmd+N</td><td>Shift+Ctrl+N</td></tr><tr><td>新建-通过拷贝的图层</td><td>Cmd+J</td><td>Ctrl+J</td></tr><tr><td>新建-通过剪切的图层</td><td>Shift+Cmd+J</td><td>Shift+Ctrl+J</td></tr><tr><td>创建剪贴蒙板</td><td>Opt+Cmd+G</td><td>Alt+Ctrl+G</td></tr><tr><td>图层编组</td><td>Cmd+G</td><td>Ctrl+G</td></tr><tr><td>取消图层编组</td><td>Shift+Cmd+G</td><td>Shift+Ctrl+G</td></tr><tr><td>排列-置为顶层</td><td>Shift+Cmd+]</td><td>Shift+Ctrl+]</td></tr><tr><td>排列-前移一层</td><td>Cmd+]</td><td>Ctrl+]</td></tr><tr><td>排列-后移一层</td><td>Cmd+[</td><td>Ctrl+[</td></tr><tr><td>排列-置为底层</td><td>Shift+Cmd+[</td><td>Shift+Ctrl+[</td></tr><tr><td>向下合并</td><td>Cmd+E</td><td>Ctrl+E</td></tr><tr><td>合并可见图层</td><td>Shift+Cmd+E</td><td>Shift+Ctrl+E</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://albert-5.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Photoshop" scheme="https://albert-5.cn/tags/Photoshop/"/>
    
  </entry>
  
  <entry>
    <title>国内访学与发展规划</title>
    <link href="https://albert-5.cn/2019/09/05/%E5%9B%BD%E5%86%85%E8%AE%BF%E5%AD%A6%E4%B8%8E%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92/"/>
    <id>https://albert-5.cn/2019/09/05/国内访学与发展规划/</id>
    <published>2019-09-05T15:43:40.000Z</published>
    <updated>2019-09-08T07:14:45.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于国内访学的思考以及个人发展规划"><a href="#关于国内访学的思考以及个人发展规划" class="headerlink" title="关于国内访学的思考以及个人发展规划"></a>关于国内访学的思考以及个人发展规划</h2><h3 id="国内访学"><a href="#国内访学" class="headerlink" title="国内访学"></a>国内访学</h3><p>因为幸运我有机会去了别人家的大学，国内一所985、211以及双一流院校。大二参加了国内的访学项目并在此期间到合作学校进行为期一年的学习，这就意味着，我将离开刚刚熟悉的大学新校园，转而到另一所新大学去学习，一切都需要重新适应和改变，而且将会认识更多的同学，同时还将意味着我能够接受到更多优质的学习资源、遇到更多优秀的同学，努力提升自己成为一个优秀的人。</p><p>去年今日，我正在新的校园里畅游、徘徊，因为我想好好看看她（渴望而不可及的大学）到底是什么样子，和我的这个学校有什么不同吗？到底是什么魔力吸引着无数高考生的目光，使其奋进全力去考？而我到底值不值在这花费一年的时间来在此学习？</p><p>校园里，有行驶着的来往汽车，有独自一人背着双肩包听着音乐的过路人，也有人成群结队嘻闹的同学，也有着滑着滑板穿梭在人群中的人······那是青春活力的展现，国家未来的希望；教室里，有人敲到着手机，探索着虚拟空间的奥秘，有人专注的翻阅着自己的课本，畅游在高数大物的海洋里，也有人在朗朗地背书，求知求实。这些看起来和我们学校确实没有什么不同，但是上过课之后就会有更多的感受，老师上课时对问题的仔细讲解，老师对学生的那种要求：大一就开始论文写作锻炼，大一就开始参加各种各样的比赛，导师的指导和教诲恐怕让人受益匪浅，或许一两年之后学生出来发表的都是science一星二星文章，而我们还不知发表论文这回事，这也说明人家的起点高，所要到达的高度也是我们所望尘莫及的，更有甚者，他们有的课程都是论文写作培训、比赛训练之类的，无不让人羡慕；另外，他们有更广的眼界，有着更多的机会去接触所谓的大V，科技讲座、人工智能峰会（论坛）······</p><p><font color="indigo" size="4">但是</font>，反过来想，这是我自己的问题，必须由我来解决！</p><p>国内的访学项目真的是拓宽了我的视野，不仅仅体验了那种浓浓的学习氛围、享受到了一些优质资源、认识了一堆学霸朋友，更多的是自身能力与那些“学霸”们之间的差距和不足的认识。一年下来，虽在自己的学校是所谓的“好学生”，其实到头来你啥也不是，唯有自己努力提升各项能力才有机会与此较横！</p><h3 id="发展规划"><a href="#发展规划" class="headerlink" title="发展规划"></a>发展规划</h3><p>回想在交换的一年时光，GPA属实高不就，甚至感觉有点浪费这个交换名额，各科成绩都没有在本校的高，比赛也没有参加几个，得到的一些奖都无法走上台面，在本校的实验室任务项目也都没能参加，自学的机器学习相关知识也很难掌握，需要时间去理解和实践。过去的也就只能过去了，如今的我大学生涯已经过半，若不继续努力恐怕前程会有点上头。这一年的时间，我想弥补前些时间的过错和不足：</p><p>编程方向仍以python为主，C语言为辅，主要工作是python数学科学和算法，进阶是机器学习和自然语言处理；</p><p>专业课程学习还是需要下一定功夫，预习复习、上课笔记</p><p>娱乐兴趣就是摄影、摄像以及后期，用影像去记录生活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="college" scheme="https://albert-5.cn/categories/college/"/>
    
    
      <category term="思考反思" scheme="https://albert-5.cn/tags/%E6%80%9D%E8%80%83%E5%8F%8D%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>网络技术笔记</title>
    <link href="https://albert-5.cn/2019/08/01/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <id>https://albert-5.cn/2019/08/01/网络技术笔记/</id>
    <published>2019-08-01T09:34:41.000Z</published>
    <updated>2019-09-08T07:19:04.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a>网络技术</h1><center>Chapter 1</center><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1、计算机网络的分类"><a href="#1、计算机网络的分类" class="headerlink" title="1、计算机网络的分类"></a>1、计算机网络的分类</h3><h4 id="1-1-局域网-Local-Area-Network-LAN"><a href="#1-1-局域网-Local-Area-Network-LAN" class="headerlink" title="1.1 局域网(Local Area Network  LAN)"></a>1.1 局域网(Local Area Network  LAN)</h4><p>特点：</p><ul><li>局域网覆盖<code>有限的地理范围</code>，使用于机关、学校、有限范围的计算机、终端与各类信息处理设备联网的需求</li><li>提供<code>传输效率</code>(10Mbps~10Gbps),支持高码率、高质量传输环境</li><li>一般属于一个单位所有，易建立、维护和扩展</li></ul><p>另一角度：</p><p>从<code>介质访问方法</code>的角度看，局域网可以分为共享介质式局域网与交换式局域网；从使用的<code>传输介质类型</code>的角度，又可以分为有限介质的有限局域网和无线局域网。</p><p>技术发展的三个方向：</p><ul><li>提高以太网的数据传输速率</li><li>将一个大型局域网划分成多个用网桥或者路由器互联的网络</li><li>将共享介质方式改为交换方式(在交换式局域网的基础上，出现了<code>虚拟局域网</code>VLAN)</li></ul><h4 id="1-2-城域网-Metropolitan-Area-Network-MAN"><a href="#1-2-城域网-Metropolitan-Area-Network-MAN" class="headerlink" title="1.2 城域网(Metropolitan Area Network  MAN)"></a>1.2 城域网(Metropolitan Area Network  MAN)</h4><p>概念：城市区域网络简称城域网，介于广域网和局域网之间的一种高速网络。目的是为了满足<code>几十公里范围</code>内的大量企业、机关、公司的多个局域网的互联要求，实现大量用户之间的数据、语音、图形的传输</p><h4 id="1-3-广域网"><a href="#1-3-广域网" class="headerlink" title="1.3 广域网"></a>1.3 广域网</h4><p>又叫远程网，覆盖范围从<code>几十公里到几千公里</code>。可以覆盖几个国家或地区，甚至横跨几个洲，从而形成国际性的远程计算机网络(分组交换网、卫星通讯网和无线分组网实现)</p><h3 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h3><h4 id="2-1-早期的广域网"><a href="#2-1-早期的广域网" class="headerlink" title="2.1 早期的广域网"></a>2.1 早期的广域网</h4><p><code>结构</code>上分成两部分：负责数据处理的计算机终端；负责数据通信的通信控制处理设备与通信线路</p><p><code>逻辑功能</code>上分成两部分：资源子网和通信子网</p><p>资源子网由计算机系统、终端、终端控制器、连接外部设备、各类软件资源与信息资源组成；资源子网负责全网的数据处理业务，负责向网络用户体统各类网络资源和网络服务。</p><h4 id="2-2-用户计算机接入"><a href="#2-2-用户计算机接入" class="headerlink" title="2.2 用户计算机接入"></a>2.2 用户计算机接入</h4><p>用户计算机可以通过局域网方式接入，也可以选择<code>电话交换网(PSTN)</code>、<code>有线电视网（CATV）</code>、<code>无线城域网（WMAN）</code>或<code>无线局域网（WLAN）</code>方式接入到作为地区级主干网的城域网。城域网又通过路由器与光纤接入到作为国家级或区域级主干网的广域网。多个广域网互联形成覆盖全世界的Internet系统</p><h3 id="实训任务"><a href="#实训任务" class="headerlink" title="实训任务"></a>实训任务</h3><h4 id="1、任务一：宽带城域网的结构"><a href="#1、任务一：宽带城域网的结构" class="headerlink" title="1、任务一：宽带城域网的结构"></a>1、任务一：宽带城域网的结构</h4><ul><li><p>宽带城域网的逻辑结构</p><p>设计一个宽带城域网将涉及<code>三个平台和一个出口</code>，即<code>网络平台、业务平台、管理平台和城市宽带出口</code></p><p><img src="https://i.loli.net/2019/08/01/5d42a0918e65876869.jpg" alt="宽带城域网的总体结构.jpg"></p></li><li><p>网络平台的层次结构</p><p>网络平台的层次结构又可以分为：<code>核心层、汇聚层、接入层</code></p><p>核心层主要承担高速数据的交换的功能，汇聚层主要承担路由和流量汇聚的功能，接入层主要承担用户接入和本地流量控制的功能。</p><ul><li><p>核心交换层的功能</p><ul><li>核心交换层将多个汇聚层连接在起来，为汇聚层的网络提供高速分组转发，为整个城市提供一个高速、安全与<code>具有QoS保障能力</code>的数据传输环境</li><li>核心交换层实现与主干网络的互联，提供城市的<code>宽带IP出口</code></li><li>核心交换层提供宽带城域网的用户<code>访问internet所需要的路由访问</code></li></ul></li><li><p>汇聚层的基本功能</p><ul><li><code>汇聚层的用户流量</code>进行数据分组传输的汇聚、转发和交换</li><li>根据接入层的用户流量进行<code>本地</code>路由、过滤、流量均衡、QoS优先级管理以及安全控制、IP地址转换、流量整形等处理</li><li>根据处理结果把<code>用户流量转发到核心层</code>或<code></code>本地进行路由处理`</li></ul></li><li><p>接入层的基本功能</p><ul><li><p>接入层的<code>最后一公里</code>问题，通过各种接入技术，连接最终用户，为它所覆盖范围内的永辉提供访问Internet以及其他信息服务</p></li><li><p><strong>三层结构</strong>的基本思想是<code>上层负责下层的数据汇聚</code>、<code>核心提供出口与QoS、汇聚本地路由、接入服务用户</code></p></li></ul></li></ul></li></ul><h4 id="2、实训任务二：管理和运营宽带城域网的关键技术"><a href="#2、实训任务二：管理和运营宽带城域网的关键技术" class="headerlink" title="2、实训任务二：管理和运营宽带城域网的关键技术"></a>2、实训任务二：管理和运营宽带城域网的关键技术</h4><p>管理和运营宽带城域网的关键技术主要是：带宽管理、服务质量QoS、网络管理、用户管理、多业务接入、统计与计费、IP地址的分配和地址转换、网络安全</p><ul><li>目前宽带城域网保证服务质量QoS要求的关键技术主要有<code>资源预留(RSVP)</code>、<code>区分服务(DiffeServ)与多协议标记交换MPLS</code></li><li>宽带城域网<code>带内网络管理是指利用数据通信网(DCN)</code>、<code>公共交换电话网(PSTN)</code>、对网络设备进行数据配置。<code>带宽网络管理是指利用网络协议(SNMP)建立网络管理系统</code></li></ul><h4 id="3、实训任务三：基于10GE的城域网方案"><a href="#3、实训任务三：基于10GE的城域网方案" class="headerlink" title="3、实训任务三：基于10GE的城域网方案"></a>3、实训任务三：基于10GE的城域网方案</h4><p>用于宽带城域网的光以太网有多种实现形式，其中最为重要的有两种：<code>基于10GE的技术</code>和<code>弹性分组环</code>技术。</p><p>10Gbps光以太网的技术优势主要表现在一下几个方面：</p><ul><li><p>以太网与DMDW技术都十分成熟，并且已经广泛使用，组建相同规模的宽带城域网，光以太网额造价是SONET的1/5，是ATM的1/10</p></li><li><p>光以太网的特征</p><ul><li>能够根据<code>终端用户的实际应用需求分配带宽</code>，保证带宽资源充分合理的应用</li><li><code>具有认证和授权功能</code>，用户访问网络资源必须经过认证和授权，确保用户和网络资源的合法性</li><li><code>提供计费功能</code>，能及时获得用户的上网时间记录和流量记录，支持按上网时间、用户流量或者包月计费方式、支持实时计费等</li><li>支持<code>VPN和防火墙</code>，有效保证网络安全</li><li>支持<code>MPLS</code>，具有一定的服务质量保证，提供分等级的QoS网络服务</li></ul></li><li><p>弹性分组环RPR技术的城域网</p><p><strong>一种直接的<code>高效传输IP分组</code>的传输技术，基础是Cisco公司提出的<code>动态分组技术(DPT)技术</code></strong></p></li></ul><p>RPR将沿<code>顺时针传输光纤</code>叫做外环，将沿<code>逆时针传输的光纤</code>叫做内环。弹性分组环RPR的内环和外环都可以同统计复用的方法传输IP分组，同时可以实现“自愈环”的功能。RPR的<strong>内环和外环都可以传输数据分组与控制分组</strong>。每一个节点都可以使用两个方向的光纤与近邻节点通信。这样做的目的除了高效地利用光纤带宽之外，还有一个目的是加速控制分组传输，提高环的可靠性，实现“环自愈”功能，保证城域网的系统可靠性与服务质量。</p><ul><li><p>RPR技术主要特点</p><ul><li><p>带宽的占用率高</p><p>传统额FDDI环网中，当源结点向目的结点成功地发送一个数据帧之后这个数据帧要由<strong>源结点</strong>中从环收回；而RPR环限制数据帧只在源节点与目的节点之间的光纤段上传输，当源结点成功地发送一个数据帧之后，这个数据帧要由目<strong>的结点</strong>从环中收回，这样就提高了环带宽的利用率；</p></li><li><p>公平性好</p><p>RPR环中每个结点都执行SRP公平算法，使得结点之间能够获得平等的带宽，防止个别结点因流量大而造成环拥堵。</p></li><li><p>快速保护和恢复能力强</p><p>RPR采用自愈环的设计思想，<code>能够在50ms的时间内</code>，隔离出现故障的节点和光纤段，提供SDH级快速保护和恢复，同时不需要像SDH那样必须有专用的带宽；</p></li><li><p>保证服务质量QoS</p></li></ul></li><li><p><strong>四网融合</strong></p></li></ul><p>计算机网络、电信通信网、电视通信网以及物联网</p><h4 id="4、实训任务四：宽带接入技术的基本类型"><a href="#4、实训任务四：宽带接入技术的基本类型" class="headerlink" title="4、实训任务四：宽带接入技术的基本类型"></a>4、实训任务四：宽带接入技术的基本类型</h4><p>接入技术可以分为有线接入和无线接入两种；从实现技术的角度，目前宽带接入技术主要有以下几种：<code>数字用户线xDSL、光纤同轴电缆混合网HFC技术、光纤接入技术、无线接入技术与局域网接入技术</code>。其中无线接入又可以分为无线局域网接入、无线城域网接入与无线Ad hoc接入。</p><ul><li><p>数字用户线xDSLjishu </p><p>数字用户环路，数字用户线是从用户到本地电话交换中心的一对铜双绞线，本子电话交换中心又叫做中心局；xDSL技术按上行(用户到交换局)和下行(交换局到用户)的速率是否相同分为速率<code>对称性</code>和速率<code>非对称性</code>两种</p><ul><li>非对称数字用户线(ADSL Asymmetric Digital Subscriber Line)</li><li>高比特率数字用户线(HDSL)</li><li>速率自适应数字用户线(RADSL)</li><li>甚高比特率数字用户线(VDSL)</li></ul></li><li><p>ADSL(非对称数字用户线)主要特点</p><ul><li>在现有电话铜双绞线上，以重叠不干扰传统模拟电话业务，即普通电话业务POTS的方式，提供高速数字业务。ADSL允许用户保留他们已经申请的模拟电话业务，可以支持用户在电话铜双绞线上的新型宽带业务。</li><li>用户不需要专门为获得ADSL服务而重新铺设电缆</li><li>提供额非对称宽带特性，上行速率在<code>64 kbps~640 kbps,下行速率在500 kbps~7 Mbps</code>。用户可以根据需要选择上行和下行速率。</li></ul></li><li><p>宽带无线接入技术</p><ul><li><p>无线接入技术主要有：<code>802.11标准的无线局域网(WLAN)接入</code>、<code>802.16标准的无线城域网(WMAN)接入</code>、<code>Ad hoc</code>接入技术，在无线宽带接入网的结构中，<code>远距离</code>采用802.16标准的WiMAX技术，可以在50km范围内提供70Mbps的传输速率；</p><ul><li><p>802.16标准与无线城域网WMAN</p><p>IEEE802.16标准体系的主要目标是制定工作在<code>2~66MHz</code>频率段的无线接入系统的物理层与介质访问控制MAC子层规范；在802.16标准增加了两个物理层标准的16d与16e，16d主要针对固定的无线网络部署，16e主要针对火车、汽车等移动物体的无线通信标准问题</p></li><li><p>802.11标准与无线局域网WLAN</p><p>定义了使用<code>红外、调频扩频与直接序列扩频技术</code>，传输速率为1Mbps或者2Mbps的无线局域网标准；11b定义了使用直接序列扩频技术，速率在1、2、5.5\11Mbps;11a将传输速率提高到54Mbps</p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://albert-5.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机三级" scheme="https://albert-5.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"/>
    
      <category term="网络技术" scheme="https://albert-5.cn/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣电影top250</title>
    <link href="https://albert-5.cn/2019/08/01/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1top250/"/>
    <id>https://albert-5.cn/2019/08/01/豆瓣电影top250/</id>
    <published>2019-08-01T09:32:58.000Z</published>
    <updated>2019-08-01T09:34:11.547Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="豆瓣电影Top-250"><a href="#豆瓣电影Top-250" class="headerlink" title="豆瓣电影Top 250"></a>豆瓣电影Top 250</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h3 id="使用的模块"><a href="#使用的模块" class="headerlink" title="使用的模块"></a>使用的模块</h3><p><strong>chardet模块—判断编码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pip install chardet</span><br></pre></td></tr></table></figure><p>使用上述命令安装模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果你的python没有安装chardet模块，你需要首先安装一下chardet判断编码的模块哦</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment">#先获取网页内容</span></span><br><span class="line">data = urllib.urlopen(<span class="string">'http://www.pythontab.com'</span>).read()</span><br><span class="line"><span class="comment">#用chardet进行内容分析</span></span><br><span class="line">chardit = chardet.detect(data)</span><br><span class="line">  </span><br><span class="line">data1 = urllib.urlopen(<span class="string">'http://www.baidu.com'</span>).read()</span><br><span class="line">  </span><br><span class="line">chardit1 = chardet.detect(data1)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> chardit[<span class="string">'encoding'</span>] <span class="comment"># pythontab</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> chardit1[<span class="string">'encoding'</span>] <span class="comment"># baidu</span></span><br></pre></td></tr></table></figure><p><strong>BeautifulSoup库</strong></p><p>安装<code>bs4</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>代码使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">""</span></span><br><span class="line">html = requests.get(url)</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>find_all()方法返回文档中符合条件的所有tags，尽管有时候我们只想得到一个结果。比如文章中只有一个<body>标签，那么使用find_all()方法来查找<body>标签不太合适了使用find_all()方法设置limit=1参数不如直接使用find()方法</body><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"position":"left","width":150,"height":300,"jsonPath":"/live2dw/assets/assets/shizuku.model.json"},"mobile":{"show":false}});</script></body></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; soup.find_all(<span class="string">'title'</span>, limit=<span class="number">1</span>)</span><br><span class="line">&gt; <span class="comment"># [&lt;title&gt;The Story&lt;/title&gt;]</span></span><br><span class="line">&gt; soup.find(<span class="string">'title'</span>)</span><br><span class="line">&gt; <span class="comment"># [&lt;title&gt;The Story&lt;/title&gt;]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>唯一的区别是find_all()方法返回的结果是只包含一个元素的列表，而find()方法直接返回结果；find_all()方法没有找到指定元素时返回空列表，而find()方法找不到目标时返回None</strong></p></blockquote><p><strong>拓展</strong></p><p><code>关于find_all()和find()方法的介绍</code></p><p><code>find()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(name, attrs, recursive, text, **wargs)　　　　# recursive 递归的，循环的</span><br></pre></td></tr></table></figure><p>这些参数相当于过滤器一样可以进行筛选处理。不同的参数过滤可以应用到以下情况：</p><ul><li>查找标签，基于name参数</li><li>查找文本，基于text参数</li><li>基于正则表达式的查找</li><li>查找标签的属性，基于attrs参数</li><li>基于函数的查找</li></ul><p>通过标签查找：</p><p>可以传递任何标签的名字来查找到它第一次出现的地方。找到后，find函数返回一个BeautifulSoup的标签对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'ecologicalpyramid.html'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> ecological_pyramid:</span><br><span class="line">　　soup = BeautifulSoup(ecological_pyramid, <span class="string">'html'</span>)</span><br><span class="line">producer_entries = soup.find(<span class="string">'ul'</span>)</span><br><span class="line">print(type(producer_entries))</span><br></pre></td></tr></table></figure><p>输出结果： <class 'bs4.element.tag'></class></p><p>通过文本查找：</p><p>直接字符串的话，查找的是标签。如果想要查找文本的话，则需要用到text参数。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'ecologicalpyramid.html'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> ecological_pyramid:</span><br><span class="line">　　soup = BeautifulSoup(ecological_pyramid, <span class="string">'html'</span>)</span><br><span class="line">producer_string = soup.find(text = <span class="string">'plants'</span>)</span><br><span class="line">print(plants_string)</span><br></pre></td></tr></table></figure><p>输出：plants</p><p>通过正则表达式查找：</p><p>想找出第一个邮箱地址，但是第一个邮箱地址没有标签包含，所以通过其他方式很难找到。但是可以将邮箱地址进行正则表达式处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">email_id_example = <span class="string">"""&lt;br/&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;The below HTML has the information that has email ids.&lt;/div&gt; </span></span><br><span class="line"><span class="string">abc@example.com </span></span><br><span class="line"><span class="string">&lt;div&gt;xyz@example.com&lt;/div&gt; </span></span><br><span class="line"><span class="string">&lt;span&gt;foo@example.com&lt;/span&gt; </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(email_id_example)</span><br><span class="line">emailid_regexp = re.compile(<span class="string">"\w+@\w+\.\w+"</span>)　　　　<span class="comment"># regexp 表达式对象</span></span><br><span class="line">first_email_id = soup.find(text=emailid_regexp)　　</span><br><span class="line">print(first_email_id)</span><br></pre></td></tr></table></figure><p>输出结果：<a href="mailto:abc@example.com" target="_blank" rel="noopener">abc@example.com</a></p><p>通过标签属性进行查找：</p><p>上面html代码，其中第一个消费者在ul标签里面且id属性为priaryconsumer（priary consumer一次消费者，初级消费者）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'ecologicalpyramid.html'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> ecological_pyramid:</span><br><span class="line">    soup = BeautifulSoup(eccological_pyramid, <span class="string">'html'</span>)</span><br><span class="line">primary_consumer = soup.find(id=<span class="string">'primaryconsumers'</span>)</span><br><span class="line">print(primary_consumer.li.div.string)</span><br></pre></td></tr></table></figure><p>输出结果：deer</p><p>基于定制属性查找：</p><p>通过标签属性查找的方式适用大多数标签属性，包括id，style，title，但有 “-”，Class标签属性例外。</p><p>比如html5标签中的data-custom属性，如果我们这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">customattr = <span class="string">"""&lt;p data-custom='custom'&gt;custo attribute</span></span><br><span class="line"><span class="string">example&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">customsoup = BeautifulSoup(customattr, <span class="string">'lxml'</span>)</span><br><span class="line">customSoup.find(data-custom=<span class="string">"custom"</span>)</span><br></pre></td></tr></table></figure><p>那么则会报错。原因是在python中变量不能含有”-“这个字符，而我们传递的data-custom有这个字符。</p><p>解决办法是在attrs属性用字典进行传递参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using_attrs = customsoup.find(attrs=&#123;<span class="string">'data-custom'</span>:<span class="string">'custom'</span>&#125;)</span><br><span class="line">print(using_attrs)</span><br></pre></td></tr></table></figure><p>基于css类的查找：</p><p>class是python的保留关键字，所以无法使用class这个关键字。</p><p>第一种方法：在attrs属性用字典进行传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css_class = soup.find(attrs=&#123;&apos;class&apos;:&apos;primaryconsumers&apos;&#125;)</span><br><span class="line">print(css_class)</span><br></pre></td></tr></table></figure><p>第二种方法：BeautifulSoup中的特别关键字参数class_。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css_class = soup.find(class_ = &apos;primaryconsumers&apos;)</span><br></pre></td></tr></table></figure><p>基于定义的函数进行查找：</p><p>可以传递函数到find()来基于函数定义的条件查找。函数必须返回True或False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_secondary_consumers</span><span class="params">(tag)</span>:</span></span><br><span class="line"><span class="keyword">return</span> tag.has_attr(<span class="string">'id'</span>) <span class="keyword">and</span> tag.get(<span class="string">'id'</span>) == <span class="string">'secondaryconsumers'</span></span><br><span class="line">secondary_consumer = soup.find(is_secondary_consumers)</span><br><span class="line">print(secondary_consumer.li.div.string)</span><br></pre></td></tr></table></figure><p>输出：fox</p><p>将方法进行组合后进行查找：</p><p>可以用其中任何方法进行组合进行查找，比如同时基于标签名和id号。</p><p><code>find_all()函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_all(name, attrs, recursive, text, limit, **kwargs)</span><br></pre></td></tr></table></figure><p><strong>limit</strong>参数可以限制得到的结果的数目。</p><p>参照前面的邮件地址例子，得到所有邮件地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">email_ids = soup.find_all(text=emailid_regexp)</span><br><span class="line">print(email_ids)</span><br></pre></td></tr></table></figure><p>输出结果：[<a href="mailto:u&#39;abc@example.com" target="_blank" rel="noopener">u&#39;abc@example.com</a>‘,<a href="mailto:u&#39;xyz@example.com" target="_blank" rel="noopener">u&#39;xyz@example.com</a>‘,<a href="mailto:u&#39;foo@example.com" target="_blank" rel="noopener">u&#39;foo@example.com</a>‘]</p><p>使用limit参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">email_ids_limited = soup.find_all(text=emailid_regexp, limit = <span class="number">2</span>)</span><br><span class="line">print(email_ids_limited)</span><br></pre></td></tr></table></figure><p>限制得到两个结果，所以输出结果：[<a href="mailto:u&#39;abc@example.com" target="_blank" rel="noopener">u&#39;abc@example.com</a>‘,<a href="mailto:u&#39;xyz@example.com" target="_blank" rel="noopener">u&#39;xyz@example.com</a>‘]</p><p>可以向find函数传递True或False参数，如果传递True给find_all()，则返回soup对象的所有标签。对于find()来说，则返回soup对象的第一个标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_texts = soup.find_all(text=<span class="literal">True</span>)</span><br><span class="line">print(all_texts)</span><br></pre></td></tr></table></figure><p>同样，可以在传递text参数时传递一个字符串列表，那么find_all()会找到挨个在列表中定义过的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_texts_in_list = soup.find_all(text=[<span class="string">'plants'</span>, <span class="string">'algae'</span>])</span><br><span class="line">print(all_texts_in_list)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">u'plants'</span>, <span class="string">u'alage'</span>]</span><br></pre></td></tr></table></figure><p>这个同样适用于查找标签，标签属性，定制属性和CSS类。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div_li_tags = soup.find_all([<span class="string">'div'</span>, <span class="string">'li'</span>])</span><br></pre></td></tr></table></figure><p>并且find()和find_all()都会查找一个对象所有后辈们，不过可以通过recursive参数控制。(recursive回归，递归)</p><p>如果recursive=False，只会找到该对象的最近后代。</p><p>通过标签之间的关系进行查找</p><p>查找父标签</p><p>通过find_parents()或find_parent()。它们之间的不同类似于find()和find_all()的区别。</p><p><strong>find_parents()返回全部的相匹配的父标签，而find_parent()返回最近一个父标签。适用于find()的方法同样适用于这两个方法。</strong></p><p>在第一消费者例子中，可以找到离Primaryconsumer最近的ul父标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">primaryconsumers = soup.find_all(class_ = <span class="string">'primaryconsumerlist'</span>)</span><br><span class="line">primaryconsumer = primaryconsumers[<span class="number">0</span>]</span><br><span class="line">parent_ul = primaryconsumer.find_parents(<span class="string">'ul'</span>)</span><br><span class="line">print(parent_ul)</span><br></pre></td></tr></table></figure><p>一个简单的找到一个标签的父标签的方法是使用find_parent()却不带任何参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">immediateprimary_consumer_parent = primary_consumer.find_parent()</span><br></pre></td></tr></table></figure><p>查找同胞</p><p>标签在同一个等级，这些标签是同胞关系，比如参照上面金子塔例子，所有的ul标签就是同胞的关系。上面的ul标签下的producers，primaryconsumers，，</p><p>secondaryconsumers，teriaryconsumers就是同胞关系。</p><p>div下的plants和algae不是同胞关系，但是plants和临近的number是同胞关系。</p><p>Beautiful Soup自带查找同胞的方法。</p><p>比如find_next_siblings()和find_next_sibling()查找对象下面的同胞。(sibling兄弟姐妹)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">producers = soup.find(id = <span class="string">'producers'</span>)</span><br><span class="line">next_siblings = producers.find_next_siblings()</span><br><span class="line">print(next_siblings)</span><br></pre></td></tr></table></figure><p>输出结果将会输出与之临近的下面的所有同胞html代码。</p><p>查找下一个</p><p>对每一个标签来说，下一个元素可能会是定位字符串，标签对象或者其他BeautifulSoup对象，我们定义下一个元素为当前元素最靠近的元素 。</p><p>这不用于同胞定义，我们有方法可以找到我们想要标签的下一个其他元素对象。find_all_next()找到与当前元素最靠近的所有对象。而find_next()找到离当前元素最接近的对象。</p><p>比如，找到在第一个div标签后的所有li标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first_div = soup.div</span><br><span class="line">all_li_tags = first_div.find_all_next(<span class="string">'li'</span>)</span><br></pre></td></tr></table></figure><p>查找上一个</p><p>与查找下一个相反的是查找前一个，用find_previous()和find_all_previous()。</p><h2 id="slwt的使用"><a href="#slwt的使用" class="headerlink" title="slwt的使用"></a>slwt的使用</h2><h2 id="代理IP的爬取"><a href="#代理IP的爬取" class="headerlink" title="代理IP的爬取"></a>代理IP的爬取</h2><hr><hr><p>【参考文章】</p><ul><li><a href="https://my.oschina.net/u/3914536/blog/1860929" target="_blank" rel="noopener">https://my.oschina.net/u/3914536/blog/1860929</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="https://albert-5.cn/categories/python/"/>
    
    
      <category term="爬虫" scheme="https://albert-5.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="python" scheme="https://albert-5.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数学建模笔记</title>
    <link href="https://albert-5.cn/2019/07/03/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://albert-5.cn/2019/07/03/数学建模笔记/</id>
    <published>2019-07-03T01:47:39.000Z</published>
    <updated>2019-07-11T01:49:14.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center> 数学交叉建模</center><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>顶点集合 $V={v ~1~, V ~2~， ······ }$</p><p>边集合 $E={e1, e2, e3,······}$</p><p>关系函数  $F(e)={u,v}$</p><p>图的表示就有 $ G={V, E, F}$</p><p>欧拉图特点： 线图，连通，无奇度顶点（<a href="https://zhidao.baidu.com/question/208310107.html）" target="_blank" rel="noopener">https://zhidao.baidu.com/question/208310107.html）</a></p><p>边与边之间有相邻不相邻关系：共顶点则为相邻关系，反之亦然；</p><p><strong>求欧拉巡回的算法：fleury算法，hierholzer算法</strong></p><p><strong>求最佳巡回算法：edmonds算法</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/24/5d1026df850f079658.png" alt="图" title>                </div>                <div class="image-caption">图</div>            </figure><blockquote><p>巡回是指从一点出发经过一系列移动之后又能回到初始顶点；</p><p>不具有b结构的称为简单图</p></blockquote><p><strong>二部图</strong></p><p>二部图与完全二部图：</p><p>若$V(G)=X∪Y$, $X∩Y=φ$ 且$X$中任意两顶点不相邻，$Y$ 中任意两顶点不相邻，则称为二部图或偶图；若$X$中每一顶点皆与$Y$ 中一切顶点相邻,称为 完全二部图或完全偶图,记为 $(m=|X|,n=|Y|)$ </p><p><img src="https://i.loli.net/2019/06/24/5d107463c6aea44467.png" alt="二部图"></p><p><strong>有向图</strong>：就是有方向的图</p><p><strong>加权图</strong>：图中的边上带有权重的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/24/5d1074cfa603086041.png" alt="加权图" title>                </div>                <div class="image-caption">加权图</div>            </figure><p><strong>子图和生成子图</strong></p><p>子图：类似子集</p><p>生成子图：保留<code>原图顶点</code>，但是少了部分边</p><p><strong>路径和连通</strong></p><p>通路：只要可以走就行 <strong>walk</strong></p><p>道路：边不能重复，但顶点可以重复 <strong>Trail</strong></p><p>路径：顶点、边都不能重复</p><p><strong>圈</strong></p><p>定义：起点和终点重合的路径称为圈，长为K的圈称为k阶圈</p><p><code>起点和终点重合的道路称为闭通路</code></p><h3 id="图与网络的数据结构"><a href="#图与网络的数据结构" class="headerlink" title="图与网络的数据结构"></a>图与网络的数据结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>0不相邻，1相邻</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/24/5d10755ad4dc738663.png" alt="邻接矩阵" title>                </div>                <div class="image-caption">邻接矩阵</div>            </figure><p>1234567表示顶点，1表示相通，0表示不通；</p><p><strong>加权图的带权邻接矩阵 A=（W~ij~）n×n</strong></p><p>$w~ij~$$=\cases{权值&amp;$当Vi 与Vj 之间有边时$\cr 0&amp;$当i=j时$\cr∞&amp;$当Vi与Vj 之间无边时$\cr}$</p><p><strong>有向图的邻接矩阵 A=（W~ij~）n×n</strong></p><p>$aij$=$=\cases{1&amp;$若（vi,vj）∈E$\cr 0&amp;$若（vi,vj）∉E$\cr}$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/24/5d107b9d2015311537.png" alt="有向图" title>                </div>                <div class="image-caption">有向图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/24/5d107bf42bb1926417.png" alt="邻接矩阵" title>                </div>                <div class="image-caption">邻接矩阵</div>            </figure><p><strong>无向图的邻接矩阵  A=（W~ij~）n×n </strong></p><p>$a~ij~ $$=\cases{1&amp;$当Vi 与Vj 相邻$\cr 0&amp;$当Vi与Vj 不相邻$\cr}$</p><h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p><strong>边矩阵</strong></p><p>定义一个m列的矩阵第1,2行分别存放百年的起点和终点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/24/5d107c882f2e099187.png" alt="边矩阵" title>                </div>                <div class="image-caption">边矩阵</div>            </figure><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>MATLAB命令</p><blockquote><p><a href="https://www.cnblogs.com/markReaper/p/8454817.html" target="_blank" rel="noopener">https://www.cnblogs.com/markReaper/p/8454817.html</a></p></blockquote><p><strong>最小生成树</strong></p><p>kruskal算法</p><p><strong>关于图论中的匹配问题</strong></p><p><a href="https://mengzelev.github.io/2018/11/28/matchings/" target="_blank" rel="noopener">https://mengzelev.github.io/2018/11/28/matchings/</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8C%B9%E9%85%8D_(%E5%9B%BE%E8%AE%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8C%B9%E9%85%8D_(%E5%9B%BE%E8%AE%BA)</a></p><p><a href="https://www.renfei.org/blog/bipartite-matching.html" target="_blank" rel="noopener">https://www.renfei.org/blog/bipartite-matching.html</a></p><p>匹配：不相邻的边构成的集合</p><p>&lt;最大匹配，匹配，理想匹配&gt;</p><p>座位安排问题，任务分配问题（加权二部图的最大权匹配问题），旅行商问题TSP，最小费用流</p><hr><hr><h2 id="模糊聚类分析和模式识别"><a href="#模糊聚类分析和模式识别" class="headerlink" title="模糊聚类分析和模式识别"></a>模糊聚类分析和模式识别</h2><h3 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h3><p>聚类定义：通俗地说，聚类就是分类问题（没有任何关于分类的先验知识，仅靠事物的相似性作为类属划分的准则属于无监督范畴）</p><p>常用的模糊聚类分析方法：</p><blockquote><ul><li>基于模糊函数的聚类分析方法：模糊传递闭包法，直接聚类法，最大树法和编网法</li><li>基于目标函数的聚类分析方法：称为模糊C均值聚类算法</li></ul></blockquote><p><strong>模糊聚类分析</strong></p><p>建立在模糊相似矩阵之上对分类对象进行定量分类的方法</p><p><strong>主要内容</strong>有：数据标准化，建立模糊相似矩阵，动态聚类</p><h4 id="如何聚类分析"><a href="#如何聚类分析" class="headerlink" title="如何聚类分析"></a>如何聚类分析</h4><blockquote><ul><li>数据标准化</li><li>建立数据矩阵</li></ul><p>设论域$U={x~1~, x2, x3,······}$为被分类对象，每个对象又有m个指标表示性状，$xi={xi1,xi2·····xim}$，则得到原始数据矩阵$X=(x_{ij})_{n\times m}$</p><ul><li>标准差标准化 (使数据正规化，在$[0,1]$之间)</li></ul><p><strong>标准化方法</strong></p><p>​    极差正规化，极差标准化，最大值规格化</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11e6a97caab93898.png" alt="123.png" title>                </div>                <div class="image-caption">123.png</div>            </figure><p><strong>用最大最小值构造模糊相似矩阵</strong></p></blockquote><p><strong>模糊相似矩阵</strong>    </p><blockquote><p><strong>定理</strong>：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11e76b6224160599.png" alt="相似系数法" title>                </div>                <div class="image-caption">相似系数法</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11e7aecf14155871.png" alt="夹角余弦法" title>                </div>                <div class="image-caption">夹角余弦法</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11e7f1b9dbf20014.png" alt="常用方法" title>                </div>                <div class="image-caption">常用方法</div>            </figure><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p><strong>模糊等价矩阵</strong></p><p>定义：给定$U$上的一个模糊关系$R_{ij}=[r_{ij}]_{n\times n}$，若它满足：</p><ul><li>自反性（$r_{ij}=1$）</li><li>对称性（$r_{ij}=r_{ji}$）</li><li>传递性（$R\circ R \subseteq R$）</li></ul><p>称$R$是$U$上的一个模糊等价矩阵。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11e9aad9a6e31363.png" alt="传递性" title>                </div>                <div class="image-caption">传递性</div>            </figure><blockquote><p>相似性度量的相关、相似系数矩阵满足自反性和对称性，但不一定满足传递性。</p><p>对于传递性,可先计算$R○R(记作R^2)$,然后看其是否满足传递性。若不满足,经过$R○R=R^2, R^2○R^2=R^4 …$运 算,可将$R$改造成满足传递性的模糊等价矩阵;</p></blockquote><p><strong>模糊等价矩阵的$\lambda $截矩阵</strong></p><p> 设$R=[r_{ij}]<em>{n×n}$是模糊等价矩阵，对任意$λ∈[0,1]$，称$Rλ=[r</em>{ij}^{(λ)}]<em>{n×n}为$$R=[r</em>{ij}]_{n×n} λ$截矩阵，其中: </p><p><img src="https://i.loli.net/2019/06/25/5d11eb3e101d485378.png" alt="截矩阵1"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11eb6e3cf4a56835.png" alt="截矩阵2" title>                </div>                <div class="image-caption">截矩阵2</div>            </figure><p><strong>分类</strong></p><p>由模糊等价矩阵的$\lambda$截矩阵可知，当$r_{ij}=1$时，$i与j应为同类$，否则为异类</p><font color="blue">让$\lambda$ 由小到大变化，可形成动态聚类图</font><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11edbe0e1bb31830.png" alt="分类" title>                </div>                <div class="image-caption">分类</div>            </figure><p><strong>最佳阈值$\lambda$的确定</strong></p><ul><li>对于不同的$λ∈[0,1]$，可得不同的分类方案，从而 形成一种动态聚类图。这对全面了解对象的分类情 况是比较形象和直观的。但有的实际问题需要选择 某个阀值λ，确定一个具体的分类，这就是确定阀 值λ的问题。 </li></ul><p>&lt;动态聚类图&gt;</p><p><strong>用$F-统计量$ 确定$\lambda$的最佳值</strong></p><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11ee5bc344a91310.png" alt="最佳值的确定1" title>                </div>                <div class="image-caption">最佳值的确定1</div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/25/5d11eea02b86242422.png" alt="最佳值的确定2" title>                </div>                <div class="image-caption">最佳值的确定2</div>            </figure></li></ul><h3 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h3><p><strong>隶属度和贴近度</strong></p><ul><li><p>隶属度</p><ul><li><p>模糊向量和内外积</p><p><strong>若</strong>0≤a<strong><em>i</em></strong>≤1(<strong>i</strong>=1,2,…,<strong><em>n</em></strong>),<strong><em>则称向量</em></strong>a=(<strong><em>a**</em></strong>1<em>,**</em>a<strong><em>2</em></strong>,…,<strong><em>a**</em></strong>n<em>)</em>为模糊向量。设<strong>a</strong>，<em>b**</em>是模糊向量，则分别称：</p><p><img src="https://i.loli.net/2019/06/25/5d11efc75f34797456.png" alt="123.png">     </p><p>​    为向量<em>a</em>与<em>b</em>内积和外积。符号$∧$和$∨$分别表示两个元素取小和取大。</p><p><img src="https://i.loli.net/2019/06/25/5d11f028b820c93741.png" alt="取大取小"></p></li></ul></li><li><p>最大隶属度原则</p><ul><li><p>原则1</p><p><img src="https://i.loli.net/2019/06/25/5d11f0802f28c31255.png" alt="原则1"></p></li><li><p>原则2</p><p><img src="https://i.loli.net/2019/06/25/5d11f0aaa3be669807.png" alt="原则2"></p></li></ul></li><li><p>贴近度</p><p>贴近度是描述模糊集之间彼此靠近程度的指标,是我国学者汪培庄教授提出的,由于研究的问题不同,贴近度也有不同的定义形式,它的一般定义为:</p><p>设<em>A</em>，<em>B</em>是论域$U$上的两个模糊子集，则称</p><p><img src="https://i.loli.net/2019/06/25/5d11f14cca4bd18065.png" alt></p><p>为<strong><font color="brown">A与B的贴近度</font></strong></p><ul><li>择近原则</li></ul></li></ul><h2 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h2><h4 id="相关关系基本概念"><a href="#相关关系基本概念" class="headerlink" title="相关关系基本概念"></a>相关关系基本概念</h4><h4 id="一元线性回归分析"><a href="#一元线性回归分析" class="headerlink" title="一元线性回归分析"></a>一元线性回归分析</h4><h4 id="一元回归模型的检验"><a href="#一元回归模型的检验" class="headerlink" title="一元回归模型的检验"></a>一元回归模型的检验</h4><h4 id="一元线性回归分析-1"><a href="#一元线性回归分析-1" class="headerlink" title="一元线性回归分析"></a>一元线性回归分析</h4><h4 id="多元线性回归分析"><a href="#多元线性回归分析" class="headerlink" title="多元线性回归分析"></a>多元线性回归分析</h4><h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p><strong>非平稳序列的处理</strong></p><ul><li><p>$X_t=X_{t-1}+\delta_t$</p></li><li><p>$X_t=Z_t\times\delta_t, Z_t$~N(0,1)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Math" scheme="https://albert-5.cn/categories/Math/"/>
    
    
      <category term="数学建模" scheme="https://albert-5.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="图论" scheme="https://albert-5.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="回归" scheme="https://albert-5.cn/tags/%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>智能优化算法</title>
    <link href="https://albert-5.cn/2019/06/29/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>https://albert-5.cn/2019/06/29/智能优化算法/</id>
    <published>2019-06-29T11:59:12.000Z</published>
    <updated>2019-06-29T12:01:45.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="智能优化算法"><a href="#智能优化算法" class="headerlink" title="智能优化算法"></a>智能优化算法</h1><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p><strong>Genetic Algorithm</strong>，简称<strong>GA</strong></p><ul><li><p>基本思想：</p><ul><li>根据问题的目标函数构造<strong>适值函数</strong>Fitness Function</li><li>产生一个初始种群</li><li>根据适值函数的好坏，不断的进行选择繁殖</li><li>若干代后得到适值函数最好的个体即为最优解。</li></ul></li><li><p>构成要素：</p><ul><li><p>种群 <strong>population</strong>     种群大小 <strong>pop-size</strong></p></li><li><p>种群表达法 – 编码方法</p></li><li><p>遗传算子 genetic operator</p><p>交叉 crossover   变异 mutation  </p><p><strong>交叉率高，解空间大，但计算时间较长</strong></p></li><li><p>选择策略</p><p>一般为正比选择</p><p><strong>选择种群中适值高的个体，适者生存</strong></p></li><li><p>停止准则</p><p>一般是指定最大迭代次数</p></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/28/5d15caaa92ed790876.png" alt="GA算法流程图" title>                </div>                <div class="image-caption">GA算法流程图</div>            </figure><ul><li><p>解空间与编码空间的转换</p><p><img src="https://i.loli.net/2019/06/28/5d15cb05e84d380250.png" alt="空间变换"></p></li></ul><p><strong>各个步骤实现</strong></p><ul><li>初始种群的产生</li><li>编码方法</li><li>适值函数</li><li>遗传算法</li><li>选择策略</li><li>停止准则</li></ul><hr><p>$\Delta$ 初始种群的产生</p><p>  随机产生(依赖于编码方法)；种群的大小(依赖于计算机的计算能力和计算复杂度)。</p><p>  例：0,1编码</p><p>​    产生$\zeta_i\in U(0,1)$</p><p>​    $\zeta_i&gt;0.5,\quad x_i=1;$    </p><p>​    $\zeta_i&lt;0.5,\quad x_i=0;$</p><p>$\Delta$ 编码方法 –二进制编码</p><p>   二进制编码，用0,1字符串表达</p><p>   背包问题：0表示不取，1表示取</p><blockquote><p>特点：</p><p>精度高时编码较长，一般不采用此法而用实值函数</p><p>编码长不利于计算</p><p>便于位值计算，包括的实数范围大</p></blockquote><p>$\Delta$ 适值函数–根据目标函数设计</p><p>   用适值函数$F(x)$标定目标函数$f(x)$采用 <strong>-minf(x)</strong>和 <strong>manf(x)</strong></p><p>$\Delta$ 遗传运算–选择、交叉、变异</p><p>   $\bigstar$ 交叉 Crossover</p><p>​      $\heartsuit$ 单切点交叉</p><p>​    随机产生一个断点 $[1,n-1]$</p><p>​        <img src="https://i.loli.net/2019/06/28/5d15cf8d292d659120.png" alt="单切点交叉"></p><p>​      $\heartsuit$ 双切点交叉</p><p>​    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/28/5d15cfc3722ea67954.png" alt="双切点交叉" title>                </div>                <div class="image-caption">双切点交叉</div>            </figure></p><p>   $\bigstar$ 变异 Mutation</p><p>​      初始种群中没有需要的基因，在种群中按变异概率$\ P_m$任选若干位基因改变位值0→1或1→0，</p><p>有意想不到的结果，$\ P_m$一般设定得比较小，在5%以下。 </p><p>   $\bigstar$ 选择</p><p>​      最常用的正比选择</p><p>​      对于个体$i$，适值$F_i$，选择概率如下公式计算<br>$$<br>P_i={F_i \over{\sum_{1}^{NP}F_i}}<br>$$</p><p>$$<br>NP–Number of Population<br>$$</p><p>​     之后采用轮盘赌的方法进行选择：</p><p>​     令$PP_0=0，PP_i=\sum_{j=1}^{i} P_j$</p><p>​     随机产生 $\varepsilon_i \in U(0,1)$</p><p>​     当 $PP_i \le \varepsilon_i \le PP_i$,选择个体 $i$，</p><h2 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h2><p> <strong>Particle Swarm Optimization</strong></p><ul><li><p>基本思想</p><ul><li><p>粒子群算法q粒子群算法的思想源于对鸟群捕食行为的研究</p></li><li><p>模拟鸟集群飞行觅食的行为，鸟之间通过集体的协作使群体达到最优目的，是一种基于Swarm Intelligence的优化方法。</p></li><li><p>马良教授在他的著作《蚁群优化算法》一书的前言中写到：</p><blockquote><p>“自然界的蚁群、鸟群、鱼群、羊群、牛群、蜂群等，其实时时刻刻都在给予我们以某种启示，只不过我们常常忽略了大自然对我们的最大恩赐！……”</p></blockquote></li></ul></li><li><p>算法介绍</p><ul><li>每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。</li><li>所有的粒子都由一个fitness function 确定适应值以判断目前的位置好坏。</li><li>每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。</li><li>每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。 </li></ul></li></ul><p><strong>细说PSO</strong></p><p>D维空间中，有N个粒子；</p><p>​    粒子$i$位置：$x_i=(x_{i1},x_{i2},\cdots x_{iD})$，将$x_{i}$代入适应函数$f(x_i)$求适应值；</p><p>​    粒子$i$速度：$v_i=(v_{i1},v_{i2},\cdots v_{iD})$</p><p>​    粒子$i$个体经历过的最好位置：$pbest_i=(p_{i1},p_{i2},…p_{iD})$ </p><p>​    种群所经历过的最好位置：$gbest=(g_1,g_2,…g_D)$</p><p>通常，在第$d（1≤d≤D）$维的位置变化范围限定在$[X_{min, d},X_{max,d}]$内,速度变化范围限定在$[-V_{min,d},V_{max,d}]$内（即在迭代中若$v_{id},x_{id}$超出了边界值，则该维的速度或位置被限制为该维最大速度或边界位置）</p><ul><li><p>粒子$i$的第$d$维速度更新公式：<br>$$<br>v_{id}^{k}=\omega v_{id}^{k-1}+c_1r_1(pbest_{id}-x_{id}^{k-1})+c_2r_2(gbest_d-x_{id}^{k-1})<br>$$</p></li><li><p>粒子$i$的第$d$维位置更新公式<br>$$<br>x_{id}^{k}=x_{id}^{k-1}+v_{id}^{k-1}<br>$$<br>$v_{id}^{k}$–表示第$k$次迭代粒子$i$飞行速度的矢量的第$d$维分量</p><p>$x_{id}^{k}$–表示第$k$次迭代粒子$i$位置矢量的第$d$维分量</p><p>$c_1,c_2$–表示加速度常数，调节学习最大步长</p><p>$r_1,r_2$–表示两个随机函数，取值范围为$[0,1]$，以增加搜索随机性</p><p>$w$–表示惯性 权重，非负数，调节对解空间的搜索范围</p></li></ul><p><strong>算法流程</strong></p><blockquote><p>1.Initial：</p><p>初始化粒子群体（群体规模为n），包括随机位置和速度。</p><p>2.Evaluation：</p><p>根据fitness function ，评价每个粒子的适应度。</p><p>3.Find the Pbest：</p><p>对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值做比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest。</p><p>4.Find the Gbest：</p><p>对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值做比较，如果当前的适应值更高，则将用当前粒子的位置更新全局最佳位置gbest。</p><p>5.Update the Velocity：</p><p>根据公式更新每个粒子的速度与位置。</p><p>6.如未满足结束条件，则返回步骤2</p><p>​    通常算法达到最大迭代次数$G_{max}$或者最佳适应度值的增量小于某个给定的阈值时算法停止。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/28/5d15e714c42cc19599.png" alt="粒子群算法" title>                </div>                <div class="image-caption">粒子群算法</div>            </figure><ul><li><p>构成要素 群体大小$m$</p><p>$m$是一个整型参数，$m$很小时，陷入局部最优解的可能性就越大；$m$很大时，pso的优化能力很好。当群体数目增长至一定水平时，再增长将不再有显著的作用。</p></li><li><p>权重因子</p><p><img src="https://i.loli.net/2019/06/28/5d15e808ca9b121743.png" alt="权重因子"></p></li><li><p>最大速度 $V_m$</p><p>在于维护算法的探索能力与开发能力的平衡</p><p>$V_m$较大时额，探索能力增强，但粒子容易飞过最优解；$V_m$较小时，开发能力增强，但容易陷入局部最优解；因此$V_m$一般设为每维变量变化范围的$10\%-20\%$</p></li><li><p>邻域的拓扑结构</p><ul><li><p>将群体内所有个体都作为粒子的邻域</p></li><li><p>只将群体中的部分个体作为粒子的邻域</p><p>邻域拓扑结构$\rightarrow^{决定}$群体历史最优解</p><font color="blue">因此，将粒子群算法分为 全局粒子群算法和局部粒子群算法</font><ul><li><p>全局粒子群算法</p><ul><li>粒子自己历史最优解</li><li>粒子群体的全局最优解</li></ul></li><li><p>局部粒子群算法</p><ul><li>粒子自己历史最优解</li><li>粒子邻居内粒子的最优解</li></ul><p>邻域随迭代次数的增加线性变大，最后邻域拓展到整个粒子群。</p></li></ul></li></ul></li><li><p>粒子空间的初始化</p><p>较好地选择粒子空间的初始化空间，将大大缩短收敛时间，初始化空间根据具体问题的不同而不同，也就是说这是问题依赖的。</p></li></ul><p><strong>算法流程</strong></p><ul><li><p>在初始化范围内，对粒子群进行随机初始化，包括随机位置和速度</p></li><li><p>计算每个粒子的适应值</p></li><li><p>更新粒子个体的历史最优位置</p></li><li><p>更新粒子群体的历史最优位置</p></li><li><p>更新粒子的速度和位置，公式如下：<br>$$<br>v_{k+1}=c_0v_k+c_1\xi (p_k-x_k)+c_2\eta(p_k-x_k)<br>$$</p><p>$$<br>x_{k+1}=x_k+v_{k+1}<br>$$</p></li><li><p>若未达到终止条件，则转第二步</p></li></ul><p><strong>惯性权重 $\omega $</strong></p><p>  描述的是粒子上一代速度对当前速度的影响，$\omega$较大时，全局寻优能力强，局部寻优能力弱；反之，则局部寻优能力强。当问题空间较大时，为了在搜索速度沙河搜索精度之间达到平衡，通常是使算法在前期有较高的全局搜索能力以得到合适的种子，而在后期有较高的局部搜索能力以提高收敛精度。<br>$$<br>w=w_{max}-(w_{max-w_{min}})\times {run\over run_{max}}<br>$$<br>$w_{max}最大惯性权重，w_{min}最小惯性权重，run当前迭代次数，run_{max}为算法迭代总次数$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="优化算法" scheme="https://albert-5.cn/categories/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="遗传算法" scheme="https://albert-5.cn/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    
      <category term="粒子群算法" scheme="https://albert-5.cn/tags/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>课程</title>
    <link href="https://albert-5.cn/2019/06/21/%E8%AF%BE%E7%A8%8B/"/>
    <id>https://albert-5.cn/2019/06/21/课程/</id>
    <published>2019-06-21T07:14:35.000Z</published>
    <updated>2019-06-21T07:16:19.452Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="通识课程平台"><a href="#通识课程平台" class="headerlink" title="通识课程平台"></a>通识课程平台</h2><h3 id="通识必修课程（最少修读31学分）"><a href="#通识必修课程（最少修读31学分）" class="headerlink" title="通识必修课程（最少修读31学分）"></a>通识必修课程（最少修读31学分）</h3><ul><li style="list-style: none"><input type="checkbox" checked> 军事理论训练  2</li><li style="list-style: none"><input type="checkbox" checked> 英语1   3</li><li style="list-style: none"><input type="checkbox" checked> 体育1  1</li><li style="list-style: none"><input type="checkbox" checked> 体育2  1</li><li style="list-style: none"><input type="checkbox" checked> 民族理论与民族政策  2</li><li style="list-style: none"><input type="checkbox" checked> 思修  3</li><li style="list-style: none"><input type="checkbox" checked> 英语2  3</li><li style="list-style: none"><input type="checkbox" checked> 体育3 1</li><li style="list-style: none"><input type="checkbox" checked> 毛概  6</li><li style="list-style: none"><input type="checkbox" checked> 体育4  1</li><li style="list-style: none"><input type="checkbox" checked> 马原  3</li><li style="list-style: none"><input type="checkbox" checked> 近代史  2             ————28分————–</li><li style="list-style: none"><input type="checkbox" checked> 形策（一部分应该）</li><li style="list-style: none"><input type="checkbox"> 就业指导</li></ul><h3 id="通识选修课程（选修文科类课程最少修读4分）"><a href="#通识选修课程（选修文科类课程最少修读4分）" class="headerlink" title="通识选修课程（选修文科类课程最少修读4分）"></a>通识选修课程（选修文科类课程最少修读4分）</h3><h3 id="通识选修课程（最少修读6学分）"><a href="#通识选修课程（最少修读6学分）" class="headerlink" title="通识选修课程（最少修读6学分）"></a>通识选修课程（最少修读6学分）</h3><h3 id="大学生英语扩展课程（最少6学分）"><a href="#大学生英语扩展课程（最少6学分）" class="headerlink" title="大学生英语扩展课程（最少6学分）"></a>大学生英语扩展课程（最少6学分）</h3><ul><li style="list-style: none"><input type="checkbox" checked> 英语3  3</li><li style="list-style: none"><input type="checkbox"> 英语4  3</li><li style="list-style: none"><input type="checkbox"> 高级媒体视听说  3</li><li style="list-style: none"><input type="checkbox"> 学术英语阅读与写作 <strong>&lt;应该可以用 创意写作 代替&gt; </strong> 3</li><li style="list-style: none"><input type="checkbox"> 中国文化概况   3</li><li style="list-style: none"><input type="checkbox"> 英语国家社会与文化入门 <strong>&lt;应该可以用 跨文化交际 代替&gt;</strong>  3</li></ul><h2 id="学科基础平台（学科基础必修课程）"><a href="#学科基础平台（学科基础必修课程）" class="headerlink" title="学科基础平台（学科基础必修课程）"></a>学科基础平台（学科基础必修课程）</h2><ul><li style="list-style: none"><input type="checkbox" checked> 高等数学A(1)</li><li style="list-style: none"><input type="checkbox" checked> 线性代数</li><li style="list-style: none"><input type="checkbox" checked> 计算机基础</li><li style="list-style: none"><input type="checkbox" checked> 自动化类专业导论</li><li style="list-style: none"><input type="checkbox" checked> 程序设计语言</li><li style="list-style: none"><input type="checkbox" checked> 高等数学A(2)</li><li style="list-style: none"><input type="checkbox" checked> 大学物理B(1)</li><li style="list-style: none"><input type="checkbox" checked> 大学物理B(1)实验</li><li style="list-style: none"><input type="checkbox" checked> 大学物理B(2)</li><li style="list-style: none"><input type="checkbox"> 大学物理B(2)实验</li><li style="list-style: none"><input type="checkbox" checked> 工程制图与CAD</li><li style="list-style: none"><input type="checkbox" checked> 电路原理</li><li style="list-style: none"><input type="checkbox" checked> 信号与系统分析</li><li style="list-style: none"><input type="checkbox" checked> 模拟电子技术</li><li style="list-style: none"><input type="checkbox" checked> 概率论</li><li style="list-style: none"><input type="checkbox" checked> 复变函数</li><li style="list-style: none"><input type="checkbox" checked> 数字电子技术</li><li style="list-style: none"><input type="checkbox"> 微机原理  <strong>计算机科学学院的课</strong></li><li style="list-style: none"><input type="checkbox"> 软件技术基础</li></ul><h2 id="专业课程（最少修读43学分）"><a href="#专业课程（最少修读43学分）" class="headerlink" title="专业课程（最少修读43学分）"></a>专业课程（最少修读43学分）</h2><h3 id="专业选修（最少修读19学分）"><a href="#专业选修（最少修读19学分）" class="headerlink" title="专业选修（最少修读19学分）"></a>专业选修（最少修读19学分）</h3><ul><li style="list-style: none"><input type="checkbox"> 运筹学  2  <strong>已选</strong></li><li style="list-style: none"><input type="checkbox"> 专业应用软件 <strong>数学实验代替</strong>  2.5</li><li style="list-style: none"><input type="checkbox" checked> 自动化专业英语  2 </li><li style="list-style: none"><input type="checkbox"> EDA技术</li><li style="list-style: none"><input type="checkbox"> 数据库原理与应用  2.5 <strong>已选</strong></li><li style="list-style: none"><input type="checkbox"> 操作系统原理</li><li style="list-style: none"><input type="checkbox"> 近代控制理论</li><li style="list-style: none"><input type="checkbox"> 数字信号处理</li><li style="list-style: none"><input type="checkbox"> 控制系统仿真</li><li style="list-style: none"><input type="checkbox"> 智能仪表</li><li style="list-style: none"><input type="checkbox"> 网络与通信技术  2.5</li><li style="list-style: none"><input type="checkbox"> 计算机控制系统</li><li style="list-style: none"><input type="checkbox"> PLC技术与应用</li><li style="list-style: none"><input type="checkbox"> 嵌入式技术与应用</li><li style="list-style: none"><input type="checkbox"> DSP技术与应用</li><li style="list-style: none"><input type="checkbox"> 管理信息系统</li><li style="list-style: none"><input type="checkbox"> 人工智能导论</li><li style="list-style: none"><input type="checkbox"> 模式识别导论  2.5</li><li style="list-style: none"><input type="checkbox"> 计算机图象处理</li><li style="list-style: none"><input type="checkbox"> 机器人导论 <strong>&lt;可以用 机器人探秘 代替&gt;</strong></li><li style="list-style: none"><input type="checkbox"> 现场总线与测控网络</li><li style="list-style: none"><input type="checkbox"> 人工神经网络导论  2</li><li style="list-style: none"><input type="checkbox"> 最优控制技术  2</li><li style="list-style: none"><input type="checkbox"> 机器学习导论  2</li><li style="list-style: none"><input type="checkbox"> 过程控制系统  </li><li style="list-style: none"><input type="checkbox"> 运动控制系统  2.5</li><li style="list-style: none"><input type="checkbox"> 无线通讯网络</li></ul><h3 id="专业必修（最少修读24学分）"><a href="#专业必修（最少修读24学分）" class="headerlink" title="专业必修（最少修读24学分）"></a>专业必修（最少修读24学分）</h3><ul><li style="list-style: none"><input type="checkbox"> 电机及拖动基础</li><li style="list-style: none"><input type="checkbox"> 自动控制原理</li><li style="list-style: none"><input type="checkbox"> 检测技术</li><li style="list-style: none"><input type="checkbox"> 功率电子技术</li><li style="list-style: none"><input type="checkbox"> 电器控制技术</li><li style="list-style: none"><input type="checkbox"> 单片机技术与应用</li></ul><h2 id="实践教学平台（最少修读26-5学分）"><a href="#实践教学平台（最少修读26-5学分）" class="headerlink" title="实践教学平台（最少修读26.5学分）"></a>实践教学平台（最少修读26.5学分）</h2><h3 id="实践教学（最少6-5学分）"><a href="#实践教学（最少6-5学分）" class="headerlink" title="实践教学（最少6.5学分）"></a>实践教学（最少6.5学分）</h3><h4 id="社会实践（最少1-5学分）"><a href="#社会实践（最少1-5学分）" class="headerlink" title="社会实践（最少1.5学分）"></a>社会实践（最少1.5学分）</h4><ul><li style="list-style: none"><input type="checkbox" checked> 自动化类社会实践1</li><li style="list-style: none"><input type="checkbox"> 自动化类社会实践2</li><li style="list-style: none"><input type="checkbox"> 自动化类社会实践3</li></ul><h4 id="课程设计（最少5学分）"><a href="#课程设计（最少5学分）" class="headerlink" title="课程设计（最少5学分）"></a>课程设计（最少5学分）</h4><ul><li style="list-style: none"><input type="checkbox"> 软件技术课程设计</li><li style="list-style: none"><input type="checkbox"> 电子技术课程设计</li><li style="list-style: none"><input type="checkbox"> 单片机课程设计</li><li style="list-style: none"><input type="checkbox"> 控制技术课程设计</li></ul><h3 id="教学实习（最少修读15学分）"><a href="#教学实习（最少修读15学分）" class="headerlink" title="教学实习（最少修读15学分）"></a>教学实习（最少修读15学分）</h3><h4 id="教学实习（最少修读3学分）"><a href="#教学实习（最少修读3学分）" class="headerlink" title="教学实习（最少修读3学分）"></a>教学实习（最少修读3学分）</h4><ul><li style="list-style: none"><input type="checkbox" checked> 金工实习</li><li style="list-style: none"><input type="checkbox" checked> 电子技术工艺实习</li><li style="list-style: none"><input type="checkbox"> 生产实习</li></ul><h4 id="毕业实习（最少修读2学分）"><a href="#毕业实习（最少修读2学分）" class="headerlink" title="毕业实习（最少修读2学分）"></a>毕业实习（最少修读2学分）</h4><ul><li style="list-style: none"><input type="checkbox"> 毕业实习</li></ul><h4 id="毕业论文（设计）【最少修读10学分】"><a href="#毕业论文（设计）【最少修读10学分】" class="headerlink" title="毕业论文（设计）【最少修读10学分】"></a>毕业论文（设计）【最少修读10学分】</h4><ul><li style="list-style: none"><input type="checkbox"> 毕业论文</li></ul><h3 id="创新创业平台（最少修读5学分）"><a href="#创新创业平台（最少修读5学分）" class="headerlink" title="创新创业平台（最少修读5学分）"></a>创新创业平台（最少修读5学分）</h3><ul><li style="list-style: none"><input type="checkbox"> 创新学分（最少修读3学分）</li><li style="list-style: none"><input type="checkbox" checked> 创业学分  <strong>已经修超了</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="college" scheme="https://albert-5.cn/categories/college/"/>
    
    
      <category term="大学课程" scheme="https://albert-5.cn/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Waring</title>
    <link href="https://albert-5.cn/2019/06/14/Waring/"/>
    <id>https://albert-5.cn/2019/06/14/Waring/</id>
    <published>2019-06-14T12:38:56.000Z</published>
    <updated>2019-09-08T07:18:39.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="拒绝伸手党！"><a href="#拒绝伸手党！" class="headerlink" title="拒绝伸手党！"></a>拒绝伸手党！</h1><h2 id="什么是伸手党"><a href="#什么是伸手党" class="headerlink" title="什么是伸手党"></a>什么是伸手党</h2><p>伸手党其实指的是一类人，这一类人有的是出于不懂事而产生的伸手现象的未成年人，有的是依赖性极强的成年人，伸手党大致有以下特征：</p><ul><li><p>任何资源（图片、音乐、链接等）都只想通过他人直接获得</p></li><li><p>虚拟社区（线上游戏、讨论区）中的讨要点卡、高级账号者</p></li><li><p>理直气壮的向别人索要他人成果                                                      </p></li><li><p>他人发布的消息以及通知等不认真阅读，反复询问者【自己定义】</p><p>​                                                                                                                     ———————-来源于百度百科                                                           </p></li></ul><h2 id="为什么会有伸手党"><a href="#为什么会有伸手党" class="headerlink" title="为什么会有伸手党"></a>为什么会有伸手党</h2><p>我感觉伸手党的存在一定程度上反映了个人的一些所谓<strong>懒</strong>的行为，自己不想去寻找或者付出努力，一味的寻求他人，希望别人直接把资源或者自己想要的东西发给你，他们都要类似的表现，例如<strong>什么问题直接来问而不是先去搜索一下如何进行解决</strong>。连说明书都懒得去看，也不想着如何去做，失去了学习的能力，也不会想着提升自己。而且能「Google」的就别「百度」，原因你懂的，这时估计会有人说了，你能上谷歌？怎么弄的的 。。。。。。。【WTF 我竟无言以对】</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/14/5d038b35e7a7e16857.jpg" alt="原罪" title>                </div>                <div class="image-caption">原罪</div>            </figure><p>但是话说过来，又有谁没有做过伸手党呢？你敢说小时候没有抄过作业？【哈，作业写完了吗？借鉴一下呗】，哎呀，真香！但是这只是曾经，那是小时候，玩是天性，不想现在自己要去忙活学习之外的事情，<strong>经历、成长、适应社会</strong>，再做伸手党恐怕有点过分哦~</p><h2 id="自己定义的伸手党"><a href="#自己定义的伸手党" class="headerlink" title="自己定义的伸手党"></a>自己定义的伸手党</h2><p><strong>为什么会把这个列为伸手党，我感觉此等行为和伸手党行为莫名的一致。</strong></p><p>虽说不是音乐、视频等资源，但是作为一种信息的阅览，其中包含的也是一种资源。</p><p>【辅导员】【班长】【各大社团】等一系列的通知，公告等漫天飞舞，还有无尽的【@全体成员】铺天盖地，大多数还都是认真阅读后提出自己的疑问，但总有一些<strong>特例</strong>不去仔细阅读通知内容，一股劲的@管理询问</p><ul><li>这个活动时什么时候开始啊，地点在哪啊</li><li>活动的具体形式是什么呀</li><li>将个人照片交到某某楼某某教室某某老师，则会有人问了 <code>纸质的还是电子照片啊</code>，<code>老师什么时候在啊</code></li><li>$\cdots\cdots$</li></ul><h2 id="拒绝伸手党"><a href="#拒绝伸手党" class="headerlink" title="拒绝伸手党"></a>拒绝伸手党</h2><p>我们大多时候都会遇到这种情况，很简单，不理会就是了。一些明显的能一个「谷歌」解决的问题，有什么必要去回复呢？到最后只能回复一句 <code>请仔细阅读公告内容！</code></p><p>或者直接无奈的给你这个：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/14/5d038f8c69f4d18531.png" alt="So what?" title>                </div>                <div class="image-caption">So what?</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/14/5d039e7a7b1db19636.png" alt="啊哈" title>                </div>                <div class="image-caption">啊哈</div>            </figure><h2 id="如何避免成为伸手党"><a href="#如何避免成为伸手党" class="headerlink" title="如何避免成为伸手党"></a>如何避免成为伸手党</h2><ul><li>善于利用工具：遇到问题先经过自己的<strong>思考</strong>，实在没有主意就去<a href="https://www.google.com/" target="_blank" rel="noopener">Google</a> 或者<a href="https://baidu.com" target="_blank" rel="noopener">Baidu</a>寻找提示或者思路，人人都能及格甚至优秀，奈何你连翻书都不会</li><li>承认自己的渺小和无知：一个人说出【我不知道】【我不了解】可能会很难，但是正因为你不知道，所以你才要去不断的学习，只有这样或许才能不断的进步，如果连这种勇气都没有，成功？恐怕只是一个梦</li><li>信息要读Carefully：接到通知或者公告，要自己阅读，不能看到活动通知就说什么时候开始，什么形式，举办方花费精力做的文案<strong>可不是白纸，还有黑字</strong>呢</li><li>学好英语：学好英语更好的利用谷歌工具，更好的看懂论文文献，更好的交流和学习，这里检讨一下自己，曾经英语不努力，现在交流mmp。</li><li>做好自己的人生规划吧！</li></ul><center><font color="#138D75">本内容不针对任何人，只是提醒自己不要做伸手党</font></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Waring" scheme="https://albert-5.cn/categories/Waring/"/>
    
    
      <category term="伸手er" scheme="https://albert-5.cn/tags/%E4%BC%B8%E6%89%8Ber/"/>
    
      <category term="自我警告" scheme="https://albert-5.cn/tags/%E8%87%AA%E6%88%91%E8%AD%A6%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>Wechat爬取好友信息</title>
    <link href="https://albert-5.cn/2019/06/12/Wechat%E7%88%AC%E5%8F%96%E5%A5%BD%E5%8F%8B%E4%BF%A1%E6%81%AF/"/>
    <id>https://albert-5.cn/2019/06/12/Wechat爬取好友信息/</id>
    <published>2019-06-12T13:49:31.000Z</published>
    <updated>2019-06-13T17:13:01.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="微信好友-一览无余"><a href="#微信好友-一览无余" class="headerlink" title="微信好友 一览无余"></a><strong>微信好友 一览无余</strong></h1><p>【itchat】一个微信的开源<strong>API</strong>，微信是一种常用的社交网络应用程序。</p><p>通过python中的聊天访问个人微信账户，然后通过微信机器人进行处理个人所有基本信息。</p><h3 id="安装itchat模块"><a href="#安装itchat模块" class="headerlink" title="安装itchat模块"></a>安装itchat模块</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install itchat</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line">itchat.auto_login()</span><br><span class="line">itchat.send(<span class="string">'Hello, filehelper'</span>, toUserName=<span class="string">'filehelper'</span>)</span><br></pre></td></tr></table></figure><p>详情见<a href="https://pypi.org/project/itchat/" target="_blank">itchat官方网站</a></p><p><strong>主要用到的方法有：</strong></p><ul><li><code>itchat.login()</code>微信扫码登录</li><li><code>itchat.get_friends()</code>返回完整的列表好友，每个好友为一个字典，其中第一项为自己的账号基本信息，带入参数<code>update=True</code>，将更新好友列表并返回，具体使用<code>itchat.get_friends(update=True)</code></li></ul><blockquote><p>技巧：使用<code>itchat.login()</code>进行登录微信会有一个问题，就是每运行一次就会生成一个二维码，叮··· 扫描登录，是不是过于麻烦了？ 直接采用<code>itchat.auto_login()</code>，在一定时间内，可以不用扫码登录，只需要在手机移动端确定登录就行了，毕竟是在模拟网页登录</p></blockquote><h3 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需要的库</span></span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 启用热键扫码登录微信</span></span><br><span class="line">itchat.auto_login(hotReload=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 抓取好友信息</span></span><br><span class="line">friends = itchat.get_friends(update=<span class="literal">True</span>)[<span class="number">0</span>:]</span><br></pre></td></tr></table></figure><p>这时，好友信息已经在存储在<strong>friends</strong>里面了。</p><p><strong>定义函数抓取个字段信息get_var(var)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_var</span><span class="params">(var)</span>:</span></span><br><span class="line">    variable = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> friends:</span><br><span class="line">        value = i[var]</span><br><span class="line">        variable.append(value)</span><br><span class="line">    <span class="keyword">return</span> variable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数得到各个变量,存在csv文件中</span></span><br><span class="line">NickName = get_var(<span class="string">'NickName'</span>)</span><br><span class="line">Sex = get_var(<span class="string">'Sex'</span>)</span><br><span class="line">Province = get_var(<span class="string">'Province'</span>)</span><br><span class="line">City = get_var(<span class="string">'City'</span>)</span><br><span class="line">Signature = get_var(<span class="string">'Signature'</span>)</span><br><span class="line">Username = get_var(<span class="string">'UserName'</span>)</span><br><span class="line">ContactFlag = get_var(<span class="string">'ContactFlag'</span>)</span><br><span class="line">SnsFlag = get_var(<span class="string">'SnsFlag'</span>)</span><br></pre></td></tr></table></figure><p><strong>定义函数parse_friends()</strong>，将得到的好友数据存储在txt文本中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 收集并保存好友信息数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_friends</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 设置需要爬取的信息字段,使用字典形式,参考官网以及个人需求设置字段信息</span></span><br><span class="line">    result = &#123;<span class="string">'NickName'</span>: NickName, <span class="string">'Sex'</span>: Sex, <span class="string">'Province'</span>: Province, <span class="string">'City'</span>: City, <span class="string">'UserName'</span>: Username,</span><br><span class="line">            <span class="string">'ContactFlag'</span>: ContactFlag, <span class="string">'SnsFlag'</span>: SnsFlag, <span class="string">'Signature'</span>: Signature, &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> friends:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'myfriends.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> fh:</span><br><span class="line">            fh.write(<span class="string">'-------------------------\n'</span>)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">'myfriends.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> fh:</span><br><span class="line">                fh.write(str(r) + <span class="string">":"</span> + str(user.get(r))+<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"分析完毕！"</span>)</span><br></pre></td></tr></table></figure><center>设置最后打印标识，提醒已完成信息存储；<br><br><center>同时当前文件夹中出现一个文件<code>myfriends.txt</code></center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/12/5d010091e02f920002.png" alt="信息文件" title>                </div>                <div class="image-caption">信息文件</div>            </figure><hr><p><strong>定义函数male_female()</strong>统计男女以及其他人数和比例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/12/5d00ff1a51a3891536.png" alt="统计" title>                </div>                <div class="image-caption">统计</div>            </figure><p><strong>然后利用pandas</strong>模块将文件信息保存在<a href="https://baike.baidu.com/item/CSV/10739" target="_blank" rel="noopener">csv文件</a>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'NickName'</span>: NickName, <span class="string">'Sex'</span>: Sex, <span class="string">'Province'</span>: Province, <span class="string">'City'</span>: City, <span class="string">'UserName'</span>: Username, <span class="string">'ContactFlag'</span>: ContactFlag, <span class="string">'SnsFlag'</span>:SnsFlag, <span class="string">'Signature'</span>:Signature, &#125;</span><br><span class="line">frame = DataFrame(data)</span><br><span class="line">frame.to_csv(<span class="string">'data2.csv'</span>, index=<span class="literal">True</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data2.csv'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">    reader = csv.reader(myfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">         print(row)</span><br></pre></td></tr></table></figure><center>便于后续采用pandas中的 <strong>value_counts</strong> 进行计数可视化处理</center><hr><p><strong>简单可视化操作</strong></p><p><strong>采用pyecharts中的Pie绘制饼图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configure(output_image=<span class="literal">True</span>)</span><br><span class="line">pie = Pie(<span class="string">"性别比例"</span>, background_color=<span class="string">'white'</span>, title_text_size=<span class="number">25</span>)</span><br><span class="line">attr = [<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'other'</span>]</span><br><span class="line">v1 = [<span class="number">57.14</span>, <span class="number">27.04</span>, <span class="number">15.82</span>]  <span class="comment"># 好友男女百分比</span></span><br><span class="line">pie.add(<span class="string">''</span>, attr, v1, is_label_show=<span class="literal">True</span>)</span><br><span class="line">pie.render() <span class="comment"># render渲染，默认在当前文件夹中的render.html</span></span><br></pre></td></tr></table></figure><blockquote><p>再使用pyecharts时，可能会出现一些错误，比如不存在Pie或者无法导入Pie等</p><p>看了一些博客之后，我采用的方法是降级，即降低库的版本，可能是与python版本有冲突</p></blockquote><p><strong>效果</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/14/5d028204f24df25475.png" alt="比例.png" title>                </div>                <div class="image-caption">比例.png</div>            </figure><center>或许这就是你Single的原因吧 –苦笑–<br></center></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Wechat爬虫" scheme="https://albert-5.cn/categories/Wechat%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://albert-5.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="微信" scheme="https://albert-5.cn/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法导论复习</title>
    <link href="https://albert-5.cn/2019/06/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
    <id>https://albert-5.cn/2019/06/02/算法导论复习/</id>
    <published>2019-06-02T06:22:04.000Z</published>
    <updated>2019-06-23T15:28:06.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center>算法复习</center><h5 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1 插入排序"></a>1 插入排序</h5><p><strong>思想：</strong></p><p><strong>通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动</strong></p><p>•Sorting problem: </p><blockquote><ul><li>–<strong>Input:</strong> A sequence of <em>n</em> numbers <em>a</em>~1~, <em>a</em>~2~, …, a~n~</li><li>–<strong>Output:</strong> A permutation   (reordering) <em>a’</em>~1~, <em>a’</em>~2~, …, <em>a’</em>~n~ of the input sequence such that</li></ul><p>a’~1~&lt;=a’~2~ &lt;= … &lt;=a’~n~</p></blockquote><p>•An instance of the sorting problem</p><blockquote><p>–Input: 8 2 4 9 3 6</p><p>–Output: 2 3 4 6 8 9</p></blockquote><p>•Notation:</p><blockquote><p>–Sorting is a fundamental operation in CS</p><p>–A large number of good sorting algorithms have been D&amp;R</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/27/5ceba10f651f696716.png" alt="算法描述" title>                </div>                <div class="image-caption">算法描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/27/5ceba1dd9a94a76116.png" alt="伪代码" title>                </div>                <div class="image-caption">伪代码</div>            </figure><p>具体python代码实现参考<a href="https://albert-5.cn/2019/03/28/sort-algorithm/">博客文章</a></p><p>时间复杂度的问题：</p><p>•<strong>Worst-case:</strong> (usually) </p><blockquote><p>–T(n) = maximum time of algorithm on any input of size n. </p><center>T(n)=maxI {T(n,I)}</center><p>–Time Complexity (Default )</p></blockquote><p>•<strong>Average-case:</strong> (sometimes) </p><blockquote><p>–T(n) = expected time of algorithm over all inputs of size n. </p><p>–Need assumption of statistical distribution of inputs. </p><center>?</center> </blockquote><p>•<strong>Best-case:</strong> (bogus虚假) </p><blockquote><p>–Cheat with a slow algorithm that works fast on <em>some</em> input.</p><center>?</center></blockquote><h5 id="2-时间复杂度描述"><a href="#2-时间复杂度描述" class="headerlink" title="2 时间复杂度描述"></a>2 时间复杂度描述</h5><p>$$<br>\Theta(n) \quad既有上界又有下界<br>$$</p><p>•<strong>Engineering:</strong> </p><blockquote><p>–Drop low-order terms; ignore leading constants.  </p></blockquote><p>example:<br>$$<br>3n^3 + 90n^2 –5n + 6046 = Θ(n3)<br>$$</p><p>$$<br>O(n)\quad 只有上界<br>$$</p><p>$$<br>Ω(n)\quad 只有下界<br>$$</p><hr><h5 id="3-分治思想"><a href="#3-分治思想" class="headerlink" title="3 分治思想"></a>3 分治思想</h5><p>recursively  递归</p><p>subproblems  子问题</p><p><strong>median</strong>  中位数</p><ul><li><p>Merge sort</p><blockquote><p>•Problem:</p><blockquote><p>–Input: A[1,n]</p><p>–Output: A[1,n] in sorted order</p></blockquote><p>•Divide-and-conquer paradigm</p><blockquote><p>–<strong>Divide:</strong> Divide the <em>n</em>-element sequence to be sorted into two subsequences of <em>n</em>/2 elements each.</p><p>–<strong>Conquer:</strong> Sort the two subsequences recursively using merge sort.</p><p>–<strong>Combine:</strong> Merge the two sorted subsequences to produce the sorted answer.</p></blockquote></blockquote></li></ul><p><img src="https://i.loli.net/2019/05/27/5ceba889be77034819.png" alt="1558947965911"></p><p><img src="https://i.loli.net/2019/05/27/5ceba94921f3323702.jpg" alt="1558947965911"></p><ul><li><p>Recursion tree递归树解决递归式问题</p><p><strong>例子</strong>：<br>$$<br>Solve \quad T(n)=2T(n)+cn,\quad where c&gt;0\quad is \quad constant<br>$$</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/27/5cebaa7f899e747908.png" alt="1558947965911" title>                </div>                <div class="image-caption">1558947965911</div>            </figure><h5 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4 快速排序"></a>4 快速排序</h5><p>思想:</p><p>​    通过一趟排序将要排序的数据分割成<strong>独立的两部分</strong>，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>前言介绍</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/27/5cebae4968c7253022.png" alt="1558947965911" title>                </div>                <div class="image-caption">1558947965911</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PARTITION (A,  p,  r)  # A是待排序数组</span><br><span class="line">x ← A[r]</span><br><span class="line">i  ← p-1</span><br><span class="line">FOR j ← p TO r-1</span><br><span class="line">IF A[ j] ≤ x</span><br><span class="line">THEN i ← i + 1</span><br><span class="line">  exchange A[i] ↔ A[ j]</span><br><span class="line">exchange A[i+1] ↔ A[r]</span><br><span class="line">RETURN i+1</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/27/5cebb0702d86d20471.png" alt="1558947965911" title>                </div>                <div class="image-caption">1558947965911</div>            </figure><p>​        <strong>the run time drops from Ω(n log <em>n</em>) to Ω(n^2^)</strong></p><p><strong>提高快速排序的方法</strong></p><p>Median-of-three(三平均分区法)</p><blockquote><p>关于这一改进的最简单的描述大概是这样的：与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：<br>　　（1） 首先，它使得最坏情况发生的几率减小了。<br>　　（2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。</p></blockquote><p>提高的方法可以说是这样的：</p><blockquote><p>首先对整个列表的元素进行选取，第一个位置first，中间位置middle，最后一个位置的元素last，然后以这三个数的中位数（以middle）为基准，对列表剩余的元素进行比较采用插入排序进行sort，这样一来，左边的元素都是小于middle的元素，右边的元素都是大于middle的元素；</p><p>然后在对middle左边的元素进行上述操作，对右边进行上述操作，直至待排的元素个数为1。</p><p>至此，整个排序也就完成了；</p></blockquote><h5 id="5-Dynamic-programming-动态规划"><a href="#5-Dynamic-programming-动态规划" class="headerlink" title="5 Dynamic programming 动态规划"></a>5 Dynamic programming 动态规划</h5><p><strong>Rod cutting</strong></p><p>Given a rod of length n inches and a table of prices pi for i = 1,2,3,…,n, determine the maximum revenue(收入) r(n) obtainable by cutting up the rod and<br>selling the pieces.</p><blockquote><p>给定长度为n英寸的杆和i = 1,2,3，…，n的价格表p~i~，确定通过切割杆和杆可获得的最大收入r(n)来销售。</p></blockquote><p><img src="https://i.loli.net/2019/05/31/5cf11c9d992b622317.png" alt="问题描述"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/31/5cf11cd82ac6564716.png" alt="问题描述" title>                </div>                <div class="image-caption">问题描述</div>            </figure><p><img src="https://i.loli.net/2019/05/31/5cf11d99c7bdb91542.png" alt="Nothing" title="哈哈"></p><p><a href="https://blog.csdn.net/qq_27139155/article/details/79725084" target="_blank" rel="noopener">拓展阅读</a></p><h5 id="6-贪心算法"><a href="#6-贪心算法" class="headerlink" title="6 贪心算法"></a>6 贪心算法</h5><p>是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的<strong>算法</strong>；比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种<strong>贪心算法</strong>。 <strong>贪心算法</strong>在有最优子结构的问题中尤为有效；</p><p>通常情况下，贪心算法采用自顶向下的设计，因为不需要作出过多的选择求解所有子问题；</p><p><strong>找零钱问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Change-Making Problem</span><br><span class="line"></span><br><span class="line">Finding the number of ways of making changes</span><br><span class="line">for a particular amount of cents, n, using a given</span><br><span class="line">set of denominations C=&#123;c1…cd&#125; (e.g, the US</span><br><span class="line">coin system: &#123;1, 5, 10, 25, 50, 100&#125;)</span><br><span class="line"></span><br><span class="line">– An example: n = 4,C = &#123;1,2,3&#125;, solutions: &#123;1,1,1,1&#125;,</span><br><span class="line">&#123;1,1,2&#125;,&#123;2,2&#125;,&#123;1,3&#125;.</span><br><span class="line"> Minimizing the number of coins returned for a</span><br><span class="line">particular quantity of change (available coins</span><br><span class="line">&#123;1, 5, 10, 25&#125;)</span><br><span class="line">– 30 Cents (solution: 25 + 5, two coins)</span><br><span class="line">– 67 Cents ?</span><br><span class="line"> 17 cents given denominations = &#123;1, 2, 3, 4&#125;?</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/01/5cf1d0afbb57471277.png" alt="算法" title>                </div>                <div class="image-caption">算法</div>            </figure><p><strong>活动选择</strong></p><p>有一个需要使用每个资源的N个活动组成的集合S ={a1, a2, ···, an},资源每次只能由一个活动使用。每个活动都有一个开始时间和si和结束时间fi，且0=&lt;si&lt;=fi&lt;∞，一旦被选择后，活动ai就只占据时间[si, fi]，如果[si,fi]和[sj,fi]不重叠，则称ai、aj兼容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 活动选取的贪心算法</span><br><span class="line">Greedy-Activity-Selector(s, f)</span><br><span class="line">    n = s.length</span><br><span class="line">    A = &#123;a1&#125;</span><br><span class="line">    k = 1</span><br><span class="line">    for m = 2 to n</span><br><span class="line">        if s[m] &gt;= f[k] # 时间的比较</span><br><span class="line">            A = A U &#123;am&#125;</span><br><span class="line">            k = m</span><br><span class="line">    return A</span><br></pre></td></tr></table></figure><p><strong>最优子结构</strong></p><p><strong>如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。</strong>贪心算法要做的就是逐步求取局部最优解，以致达到全局整体最优。</p><p><strong>赫夫曼编码</strong></p><p>讨论赫夫曼编码问题，<strong>赫夫曼编码的思想就是变长编码；也就是说让字符表中出现概率高的字符的编码长度尽可能的小，而出现概率高的字符的编码相对较长；</strong>然后遵循前缀码的要求，<strong>即是任意一个编码都不是其他编码的前缀</strong>，便于解码。</p><blockquote><p>作者：JeffCoding<br>原文：<a href="https://blog.csdn.net/jeffleo/article/details/53557143" target="_blank" rel="noopener">https://blog.csdn.net/jeffleo/article/details/53557143</a> </p></blockquote><p>赫夫曼编码是一种广泛用于数据压缩的问题，该算法的主要优势在于节约了存储和传输成本。<br>举一个例子：<br>假设要传输的数据为</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210100959132?waterark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 0" title>                </div>                <div class="image-caption">Figure 0</div>            </figure><p>那么传输成本就是：<br>45<em>3 + 30 </em> 3 + 29 <em> 3 + 10 </em> 3 + 8 <em> 3 + 5 </em> 3 = 381个字符</p><p>我们可以使用赫夫曼编码思想来解决<br>先合并最小频率的2个字符对应的子树，计算合并后的子树的频率；<br>重新排序各个子树；<br>重复步骤1<br>重复步骤2<br>对二叉树中的边赋予0、1，得到各字符的变长编码。<br>对于上举的例子而言就是：<br>EF最小，首先构造EF的生成树，重新排序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210103651379?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 1" title>                </div>                <div class="image-caption">Figure 1</div>            </figure><p>构造EF 和 D的生成树，重新排序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210103733670?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 2" title>                </div>                <div class="image-caption">Figure 2</div>            </figure><p>构造EFD 和 C 的生成树, 重新排序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210103803780?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 3" title>                </div>                <div class="image-caption">Figure 3</div>            </figure><p>构造EFDC 和 B 的生成树，重新排序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210103828030?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 4" title>                </div>                <div class="image-caption">Figure 4</div>            </figure><p>构造EFDCB 和 A 的生成树，重新排序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210103845536?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 5" title>                </div>                <div class="image-caption">Figure 5</div>            </figure><p>赫夫曼编码后的二进制数据为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20161210104103615?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 6" title>                </div>                <div class="image-caption">Figure 6</div>            </figure><p>可以看见，利用赫夫曼思想设计之后，频率高的字符，二进制码短了，频率低的字符，二进制码长了，这样就有效得减少了总得二进制码数。</p><p>那么传输成本就是：<br>45<em>1 + 30 </em> 2 + 29 <em> 3 + 10 </em> 4 + 8 <em> 5 + 5 </em> 5 = 292个字符，节约了23%的成本！</p><center>End</center><hr><h5 id="7-最大流问题"><a href="#7-最大流问题" class="headerlink" title="7 最大流问题"></a>7 最大流问题</h5><p><strong>流网络</strong></p><p>digraph G=(V,E)</p><p>weights, called capacities on edge c(u,v)边缘容量</p><p>two distinct vertices (不同的顶点)</p><p>source, ‘s’; sink ‘t’</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/01/5cf1ea551012294327.png" alt="流网络" title>                </div>                <div class="image-caption">流网络</div>            </figure><p>The value of a flow is the net flow out of the source:<br>$$<br>\sum p(s,v)-\sum p(v,s)<br>$$<br><strong>流网络流出的值是净网络</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/06/01/5cf1ebf9b341b34472.png" alt="网络的值" title>                </div>                <div class="image-caption">网络的值</div>            </figure><center>The value of this flow is 1-0+2=3</center><p><strong>残存网络</strong></p><p>假定有一个流网络G=（V，E），其源点为s，汇点为t，f为G中的一个流。对即诶点对u，v，定义<strong>残存容量（residual capacity）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180612112701509" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></strong>，有：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180612112750298" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>残存网络可能包含图G中不存在的边，残存网络中的反向边允许算法将已经发送出来的流量发送回去。一个残存网络示例图如下：</p><p>Rabin-KarpRabin-Karp<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180612113041548" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><blockquote><p>图a是一个流网络，b是a对应的残存网络，注意每条边上的值，残存网络中针对<strong>每条正向边计算出该条边在存在流的情况下的剩余容量，并画出一条反向边，反向边的容量即是发出流的大小</strong>，方便将发出的流运输回发送地，并将权重为0的边省略。</p></blockquote><h5 id="8-字符串匹配"><a href="#8-字符串匹配" class="headerlink" title="8 字符串匹配"></a>8 字符串匹配</h5><p><strong>Rabin-Karp算法</strong></p><p>在实际应用中，Rabin-Karp算法的预处理时间为O（m）,并且在最坏的情况下的时间复杂度为O((n-m+1)m),相对于朴素字符串，它的运行时是比较好的。</p><p>整个<strong>算法思想</strong>介绍如下：</p><p>数学中有霍纳法则,我们运用霍纳法则在O(m)内计算p： </p><p>p=P[m]+10(P[m-1]+10(P[m-2]+…+10(P[2]+10P1)…))) </p><p>霍纳法则的解释如下：</p><p> <img src="https://img-blog.csdn.net/20170212231637204?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ2NzA0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>运用霍纳法则，类似的我们也可以根据T[s+1…s+m]计算出t. </p><p>但为了节约时间，我们可以利用一下方法在常数时间内根据ts,计算出ts+1.具体过程如下图解: </p><p> 如图所示，ts=31415,ts+1=14152,则 </p><p>ts+1=(ts-(T[s+1]=3)<em>10^(m=4))</em>10+(T[s+m+1]=2) </p><p>注：(ts-(T[s+1]=3)*10^(m=4))=31415-30000=1415 </p><p>即 ts+1=10(ts-10^(m-1)T[s+1])+T[s+m+1] </p><p>在计算过程中，可能会出现p与t的值过大，可以取模运算</p><p><strong>确定优先状态自动机</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160915154406936" alt="有限自动状态机" title>                </div>                <div class="image-caption">有限自动状态机</div>            </figure><p>上面这个图描述的就叫一个有限状态自动机，图中两个圆圈，也叫节点，用于表示状态，从图中可以看成，它有两个状态，分别叫0和1. 从每个节点出发，都会有若干条边，当处于某个状态时，如果输入的字符跟该节点出发的某条边的内容一样，那么就会引起状态的转换。例如，如果当前状态处于0，输入是字符a,那么状态机就会从状态0进入状态1.如果当前状态是1，输入字符是b或a,那么，状态机就会从状态1进入状态0.如果当前所处的状态，没有出去的边可以应对输入的字符，那么状态机便会进入到错误状态。例如，如果当前处于状态0，输入字符是c,那么状态机就会出错，因为从状态0开始，没有哪条边对应的字符是c。</p><p>状态机会有一个初始节点，和一个接收节点，以上图为例，我们可以设置初始节点为0，接收节点为1，当进行一系列的输入，使得状态机的状态不断变化，只要最后一个输入使得状态机处于接收节点，那么就表明当前输入可以被状态机接收。例如对应字符串”abaaa”, 从初始节点0开始，状态机根据该字符串的输入所形成的状态变化序列为：{0，1，0，1，0，1}。由于最后状态机处于状态1，所以该字符串可以被状态机接收。如果输入的字符串是:abbaa, 那么状态机的变化序列为：{0，1，0，0，1，0}， 由于最后状态机处于非接收状态，因此这个字符串被状态机拒绝。</p><p> 在程序中，使用<strong>二维表</strong>表示一个状态机：</p><table><thead><tr><th><strong>输入</strong></th><th><strong>a</strong></th><th><strong>b</strong></th></tr></thead><tbody><tr><td>状态0</td><td>1</td><td>0</td></tr><tr><td>状态1</td><td>0</td><td>0</td></tr></tbody></table><p>接下来我们看看一个文本的匹配流程，假定要查找的字符串为P=”ababaca”, 被查找的文本为T=”abababacaba”. 一次读入T的一个字符，用S表示当前读入的T的字符，一开始读入一个字符，于是S=a.然后看看，从P开始，连续几个字符所构成的字符串可以成为S的后缀，由于当前S只有一个字符a,于是从P开始，连续1个字符所形成的字符串”a”,可以作为S的后缀。把这个字符串的长度记为k,于是此时k 等于1. 继续从T中读入字符，于是S=”ab”, 此时，从P开始，连续两个字符所构成的字符串”ab”可以作为S的后缀，于是k = 2.反复这么操作，于是便有以下序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S=a, k = <span class="number">1</span>, P[<span class="number">1</span>] 是S的后缀</span><br><span class="line">S=ab, k = <span class="number">2</span>, P[<span class="number">1</span>,<span class="number">2</span>] 是S的后缀</span><br><span class="line">S=aba, k = <span class="number">3</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]是S的后缀</span><br><span class="line">S=abab, k= <span class="number">4</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]是S的后缀</span><br><span class="line">S=ababa, k = <span class="number">5</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]是S的后缀</span><br><span class="line">S=ababab, k = <span class="number">4</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]是S的后缀</span><br><span class="line">S=abababa, k = <span class="number">5</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]是S的后缀</span><br><span class="line">S=abababac, k = <span class="number">6</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]是S的后缀</span><br><span class="line">S=abababaca, k = <span class="number">7</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]是S的后缀</span><br><span class="line">S=abababacab, k =<span class="number">2</span>, P[<span class="number">1</span>,<span class="number">2</span>] 是S的后缀</span><br><span class="line">S=abababacaba, k = <span class="number">3</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 是S的后缀。</span><br></pre></td></tr></table></figure><p>从上述过程中，我们可以看到第九步的时候字符串P已经成为了S的后缀，此时的S是文本T的前缀，因此可以说明在字符串T中找到了模式串P。</p><p>如果问题变化，构造一个方法，使得一次运行便能知道从P开始，连续读取几个字符能使得这几个字符构成的字符串是S的后缀。这个方法，就需要上面我们提到的有限状态自动机了</p><p><strong>用于字符串匹配的自动机</strong></p><p>假定字符串P和文本T只由a,b两个字符组成，也就是字符集为∑={a,b,c}, P含有m个字母，于是，我们要构造的自动机就含有m个状态节点。假设我们当前处于状态节点q, 那么当下一个输入字符是a和b时，从当前节点q该跳转到哪一个节点呢？ 如果用$P_q$来表示长度为q的P的前缀，以q=4, p=”ababaca”, $P_q$ =”abab”, 那么当处于状态4, 当输入为a时，我们构造字符串 S = $P_q$ + ‘a’ = “ababa”, 然后看看字符串P从第一个字符开始，连续几个字符所构成的字符串可以成为S的后缀，就当前S为例，从第一个字符开始，连续5个字符，也就是P[1,2,3,4,5]可以作为S的后缀，于是，我们就有，当状态机处于节点4，输入为a时，跳转的下个状态就是5. 同理，当处于状态q=4,输入为字符b时，S = $P_q$ + ‘b’ = “ababb”,此时从P开始，连续读取0个字符才能形成S的后缀，于是当状态机处于状态4，如果读入字符是b, 那么跳转的下一个状态是0，同理，如果输入字符是c, 那么S = $P_q$ + ‘c’ = “ababc”, 此时从P开始，连续读取0个字符所形成的空字符串才能作为S的后缀，于是当状态机处于状态节点4，输入字符为c时，跳转到节点0. 如果q从0开始，一直到m,反复运用刚才提到的步骤，便会产生下面这个跳转表：</p><table><thead><tr><th><strong>输入</strong></th><th><strong>a</strong></th><th><strong>b</strong></th><th><strong>c</strong></th></tr></thead><tbody><tr><td>状态0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>状态1</td><td>1</td><td>2</td><td>0</td></tr><tr><td>状态2</td><td>3</td><td>0</td><td>0</td></tr><tr><td>状态3</td><td>1</td><td>4</td><td>0</td></tr><tr><td>状态4</td><td>5</td><td>0</td><td>0</td></tr><tr><td>状态5</td><td>1</td><td>4</td><td>0</td></tr><tr><td>状态6</td><td>7</td><td>0</td><td>0</td></tr><tr><td>状态7</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><p>状态I就是上面介绍的K的值，也就是P中形成的字符串可以构成S的后缀的长度；</p><p><strong>KMP算法</strong></p><p>算法流程</p><ul><li><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li><li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。<ul><li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。</li></ul></li></ul><p>next数组的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀，例如如果next[j]=k,代表j之前的字符串中有最大长度为k的相同前缀后缀。</p></li></ul><p>此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符；</p><p><strong>步骤</strong></p><p><strong>①</strong> 寻找前缀后缀的最大公共元素长度</p><ul><li>对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：</li></ul><p>  <img src="https://img-blog.csdn.net/20140819173639786" alt="img"></p><p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k+1 = 2）。</p><p><strong>②</strong> 求next数组</p><ul><li><p>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示</p><p><img src="https://img-blog.csdn.net/20140819173649739" alt="img"></p></li></ul><p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）</p><p><strong>补充</strong></p><p>寻找最长前缀后缀</p><p>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140725231726921" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（<strong>下简称《最大长度表》</strong>）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721222801918" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>而且，根据这个表可以得出下述结论</p><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值<br>    上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p><p>给定字符串“ABCDABD”，可求得它的next 数组如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721230250468" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>把next 数组跟之前求得的最大长度表对比后，不难发现，<strong>next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1</strong>。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p>  <center>kmp算法的复杂度是O(n+m)</center><p><strong>参考文章</strong></p><p><a href="https://blog.csdn.net/tyler_download/article/details/52549315" target="_blank" rel="noopener">https://blog.csdn.net/tyler_download/article/details/52549315</a> </p><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827#t5" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827#t5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="插入排序" scheme="https://albert-5.cn/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法导论" scheme="https://albert-5.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="最大流问题" scheme="https://albert-5.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    
      <category term="KMP算法" scheme="https://albert-5.cn/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络流Network_Flow</title>
    <link href="https://albert-5.cn/2019/06/01/%E7%BD%91%E7%BB%9C%E6%B5%81Network-Flow/"/>
    <id>https://albert-5.cn/2019/06/01/网络流Network-Flow/</id>
    <published>2019-06-01T04:44:08.000Z</published>
    <updated>2019-06-01T04:45:35.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>内容来源于<a href="https://zhangxiaoyang.me/categories/intro-to-algorithms-tutorial/intro-to-algorithms-tutorial-7.html" target="_blank_">爱美工的程序员</a></p></blockquote><h1 id="网络流（Network-Flow）"><a href="#网络流（Network-Flow）" class="headerlink" title="网络流（Network Flow）"></a>网络流（Network Flow）</h1><p>网络流和线性规划、动态规划是有关系的。它们都属于数学规划，也就是用数学的方法来帮助决策。（详情参考清华大学《数学规划》）这样来看，就没有神秘可言了。小样，换个马甲我还认识你。所以，网络流也是一个解决极值问题的数学方法。</p><p>要解决问题，总得先有个靠谱的模型吧。动态规划和线性规划里边都有公式啥的。总之，要先形式化（建模），再解决。所以，就有了流网络。</p><h2 id="流网络（Flow-Network）"><a href="#流网络（Flow-Network）" class="headerlink" title="流网络（Flow Network）"></a>流网络（Flow Network）</h2><p>顾名思义，流网络是一种用流构成的网络，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E6%B5%81%E7%BD%91%E7%BB%9C%E7%A4%BA%E4%BE%8B.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可以把边想象成自来水的管道，把节点想象成管道的连接组件。其中，管道的容量不一定相同，所以就有了不同的边的权重（管道容量是一个大于等于0的常量）。流网络是一个有向图，所以，管道是有方向的（水的流向只能按照管道的方向流）。注意图中两个特殊的连接组件，s代表源，也就是水的入口，t代表汇，也就是水的出口。也就是说，水从s点灌入，从t点流出，具体有多少水流入s，我们不用管，反正是源源不断；从t流出的水去哪，我们也不用操心。</p><p>这样，我们就得到了一个流网络，s是流的入口，t是流的出口，s和t之间有若干个管道连接。要谨记这个流网络中管道的容量限制和方向限制，若是没有它，又何必来学网络流。</p><h2 id="流（Flow）"><a href="#流（Flow）" class="headerlink" title="流（Flow）"></a>流（Flow）</h2><p>流网络可以看成是一张线路图，这里是自来水管道的线路图，相当于硬件基础设施。</p><p>我们现在要做的是使用这个基础设施，也就是往管道里灌水，确保每个管道里的流量不超过容量限制。比如，我们可以这样灌，如下图。边的权重增加了流量参数，使用斜线与容量进行分隔。</p><p><strong>注意：这里的所有图中，如果有斜线标识，则左侧表示流，右侧表示容量。如果没有斜线，则只是表示容量。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E6%B5%81%E7%A4%BA%E4%BE%8B.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>对流网络灌水得到的就是“流”。当然，这只是其中一种满足流量不超过容量限制的灌水方法。还可以有很多种灌水的方法。但是都要遵循以下两个原则：</p><ul><li>容量限制：管道的流量不能超过容量。</li><li>流量守恒：流入管道连接组件的流量等于流出的流量。</li></ul><p>至此，我们成功的得到了“流”。</p><h2 id="s-t流（s-t-Flow）"><a href="#s-t流（s-t-Flow）" class="headerlink" title="s-t流（s-t Flow）"></a>s-t流（s-t Flow）</h2><p>现实往往是不按套路出牌的。比如，连接的地方（节点）可能有权重，能够蓄水。比如，有多个源多个汇。比如，有多个管道连接两个节点。</p><p>总之，现实的种种迹象表明，我们需要设计一个兼容并包的模型，考虑种种情况。</p><p>但是，我们不想考虑那么多情况。</p><p>于是，就有了一个小伙想了个点子，定义一种标准模型，我们只研究这个标准的模型。其它的情况通过一些方法转化成这个标准模型。</p><p>是的，这个标准模型就是s-t流。一些转化方法如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E8%BD%AC%E5%8C%96%E4%B8%BAs-t%E6%B5%81.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h1 id="最大流（Maximum-Flow）"><a href="#最大流（Maximum-Flow）" class="headerlink" title="最大流（Maximum Flow）"></a>最大流（Maximum Flow）</h1><p>费尽心思，从初步的流网络，到我们比较喜欢的标准形式s-t流，是时候考虑正事儿了。</p><p>流网络是固定的，但是流是不确定的。所以，我们想在多种灌水的方法中寻找最佳。</p><p>何为最佳？</p><p>在源灌入大量的水，通过选择最好的管道流量和流向，使得汇流出的流量最大。但是，最大流不是想找就能找到的，所以这是个问题，即最大流问题。</p><h2 id="Trial-1-Dynamic-programming"><a href="#Trial-1-Dynamic-programming" class="headerlink" title="Trial 1: Dynamic programming"></a>Trial 1: Dynamic programming</h2><p>既然是数学规划，首先想到的是能不能使用动态规划。</p><p>现实情况是，目前还没有解决最大流问题的动态规划算法。</p><h2 id="Trial-2-Iteration"><a href="#Trial-2-Iteration" class="headerlink" title="Trial 2: Iteration"></a>Trial 2: Iteration</h2><p>想到的另外一种方法是迭代法，伪代码表示如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = x0;</span><br><span class="line">while true do</span><br><span class="line">    x = improve(x);</span><br><span class="line">    if stopping(x) then</span><br><span class="line">        break</span><br><span class="line">    end if</span><br><span class="line">end while</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><p>主要是思想是从某个流开始，不断的改进这个流，直到到达我们想要的最大流。</p><p>不得不说，这想法太粗略了。一些问题没有解决，比如，如何选择开始的流，如何改进，何时停止算法。</p><p>为了解决这些问题，我们需要继续补充一些基础知识。这样才能干掉这个问题。</p><p>（为什么不试试线性规划？线性规划是可以解决的，但是对于这种网络的结构，并不能很高效。）</p><h2 id="割（Cut）"><a href="#割（Cut）" class="headerlink" title="割（Cut）"></a>割（Cut）</h2><p>对于一个流网络，在若干个管道上切一刀，使这个网络分成两部分，这两部分将无法连通。所以，我们有很多种切割的方法，把这个网络分成两部分。每一种切割的方法对应于一个“割”。</p><h2 id="s-t割（s-t-Cut）"><a href="#s-t割（s-t-Cut）" class="headerlink" title="s-t割（s-t Cut）"></a>s-t割（s-t Cut）</h2><p>s-t割是一种特殊的“割”，这种切割的方式需要保证在切割之后s和t不再连通，即s和t不属于同一部分了。</p><p>对于一个s-t割，必然会把s和t分到两个小网络中，并且切坏了若干个管道。这两个小网络之间的管道容量之和就是割的值，只计算从包含s的小网络流向包含t的小网络的管道容量之和，反方向不考虑。一个s-t割如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/s-t%E5%89%B2.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可以计算出，割的值为12+14=26。可以看到，割的值只与流网络有关，和流无关。对于一个确定的流网络，一刀切下去，割的值就确定了。</p><h2 id="最小割（Minimum-Cut）"><a href="#最小割（Minimum-Cut）" class="headerlink" title="最小割（Minimum Cut）"></a>最小割（Minimum Cut）</h2><p>对于一个流网络，我们可以得到多个割的值，因为切的方法有很多种，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E5%90%84%E7%A7%8D%E5%89%B2%E5%80%BC.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>在这里，我们更关心割值最小的情况，即最小割。为什么更关心最小割？下面会说~</p><h2 id="净流量（Net-Flow）"><a href="#净流量（Net-Flow）" class="headerlink" title="净流量（Net Flow）"></a>净流量（Net Flow）</h2><p>注意到，割的值是和流无关的，只与流网络有关。也就是说，割的值只是取决于管道的容量和方向，以及切的方法。</p><p>如果我们观察一下流，发现了一个规律，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E5%87%80%E6%B5%81%E9%87%8F.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>真的是固定值有木有！这个固定值就是净流量。之所以有这个规律，是因为流量守恒。</p><p>需要注意，在计算净流量时，需要考虑两个方向的值，并求代数和。从s流向t记为正，从t流向s记为负。对于割值的计算，则无需考虑从t流向s的。因为割值实际计算的是管道容量，净流量考虑的是真实的流量。</p><h2 id="残留网络（Residual-Network）"><a href="#残留网络（Residual-Network）" class="headerlink" title="残留网络（Residual Network）"></a>残留网络（Residual Network）</h2><p>残留网络，顾名思义，就是流网络中去掉流剩下的网络。对于某条管道，其容量减去流以后剩下的流构成的网络，就形成了残留网络。每一个流会对应一个残留网络，残留网络 = 流网络 - 流，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E6%AE%8B%E7%95%99%E7%BD%91%E7%BB%9C.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>需要说明的是，蓝色的边称作反向边，方向与原来的方向相反，数值为原来流量的值。</p><p>为什么要加上这个看似多余的反向边？</p><blockquote><p>反向边的作用就是给程序一个可以后悔的机会。（来自<a href="http://blog.csdn.net/leolin_/article/details/7202691" target="_blank" rel="noopener">这里</a>)）</p></blockquote><p>也就是说，加这个边是为了寻找最大流的程序的执行。</p><h2 id="增广路径（Augmenting-Path）"><a href="#增广路径（Augmenting-Path）" class="headerlink" title="增广路径（Augmenting Path）"></a>增广路径（Augmenting Path）</h2><p>扯这么多，主要是为了引出这个增广路径。因为增广路径能帮我们找到最大流。</p><p>增广路径就是残余网络中的一条s到t方向的路径，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E5%A2%9E%E5%B9%BF%E8%B7%AF%E5%BE%84.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>如果我们找到了这样一条路径，说明原来的流不够大，还可以在这条路径上压入一些流量，在这里是3，取11、12、3中最小值。</p><p>这样，我们就可以得到更大的流。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>从流（我们更关心最大流），到割（我们更关心最小割），到残留网络，再到增广路径，我们在做啥子吗？</p><p>我的理解是，这些流呀割呀都是理论储备，最终是想证明一句话：残留网络$G_f$中不包含增广路径时，f就是G的最大流。</p><p>而残留网络、增广路径是解决这个最大流问题的手段，通过寻找增广路径的方法来改进当前的流，朝最大流逼近。但是，问题是何时停止算法呢？这就是理论储备部分告诉我们的，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%9D%E8%80%83.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="最大流最小割定理（Max-Flow-Min-Cut-Theorem）"><a href="#最大流最小割定理（Max-Flow-Min-Cut-Theorem）" class="headerlink" title="最大流最小割定理（Max-Flow Min-Cut Theorem）"></a>最大流最小割定理（Max-Flow Min-Cut Theorem）</h2><p><strong>重述一遍，残留网络$G_f$中不包含增广路径时，f就是G的最大流（或者说，最大流的流量等于最小割的容量）。</strong></p><p><strong>这就是传说中的最大流最小割定理。</strong></p><p>这个可以用反证法证明，假设当不包含增广路径时没有达到最大流，那么就会找到一条路径来增大流，也就找到了增广路径，所以矛盾。大致是这样证明。</p><h1 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><p>Ford-Fulkerson是一种求解最大流的方法，依赖于上面积淀的基础知识（主要是残留网络、增广路径、割的功劳），也称作“扩充路径方法”。之所以称之为方法而不是算法，是因为这个只是一种指导思想，在此指导之下，有很多种实现方式。</p><p>Ford-Fulkerson是一种迭代法，过程如下：</p><ol><li>流网络中所有顶点对的流大小清零（此时，网络流为零）</li><li>每次迭代，通过寻找一条增广路径来增加流的值</li><li>无法找到增广路径时，迭代结束</li></ol><p>可以看到，最关键问题是如何寻找增广路径，而Ford-Fulkerson方法的效率正取决于此。如果选择方法不好，就有可能每次增加的流非常少，而算法运行时间非常长，甚至无法终止。</p><p>但是，Ford-Fulkerson并没有告诉我们如何寻找增广路径。所以，它是个方法，而不是算法，伪代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> initialize f(e) = 0 for all e</span><br><span class="line">while there is a s-t path in residual graph Gf do</span><br><span class="line">    arbitrarily choose an s-t path P in Gf</span><br><span class="line">    f = augment(P, f)</span><br><span class="line">end while</span><br><span class="line">augment(P, f)</span><br><span class="line">    let b = bottleneck(P)</span><br><span class="line">    for each edge e = (u, v) ∈ P do</span><br><span class="line">        if (u, v) is a forward edge then</span><br><span class="line">            increase f(u, v) by b</span><br><span class="line">        else</span><br><span class="line">            decrease f(u, v) by b</span><br><span class="line">        end if</span><br><span class="line">    end for</span><br></pre></td></tr></table></figure><p>其中，<code>augment</code>是一个改变当前流的函数，即使用找到的增广路径P来压入流，增大当前的流f。而<code>bottleneck</code>从当前的增广路径P中找到瓶颈边（残留网络中，路径上流量最小的边），把这个流量压入。</p><p>正是因为在选择增广路径时是<code>arbitrarily</code>，所以Ford-Fulkerson方法有多种实现。</p><h2 id="Scaling-technique"><a href="#Scaling-technique" class="headerlink" title="Scaling technique"></a>Scaling technique</h2><p>第一种是scaling的方法，通过伪代码更好解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">initialize f(e) = 0 for all e</span><br><span class="line">let △ = C</span><br><span class="line">while △ ≥ 1 do</span><br><span class="line">    while there is a s-t path in Gf(△) do</span><br><span class="line">        choose a s-t path</span><br><span class="line">        f&apos; = augment(P, f)</span><br><span class="line">        f = f&apos;</span><br><span class="line">   end while</span><br><span class="line">   △ = △ / 2</span><br></pre></td></tr></table></figure><p>可以看到，通过定义一个△来调节增广路径的选择顺序。C是一个定义的常熟。如果残留网络中的边（流量值）小于C，则“删除”该边，在新的网络中选择增广路径。如果这样的网络中找不到增广路径（也就是说，所有的边都不符合△的限制），则把△缩放为原来的一半，继续寻找增广路径。直到△不满足大于等于1时，算法结束。</p><p>例子来自卜老师的课件，△初始化为96。第一次的时候，残留网络的所有边被“删除”（标记为蓝色），因为都小于96。然后△调整为96/2=48，这样就获得了一条增广路径，并压入流。直到找不到增广路径，算法结束，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E7%BC%A9%E6%94%BE%E7%AE%97%E6%B3%95.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，scaling方法是通过加一个△（阈值）来选择增广路径的。通过这个阈值，可以尽可能的一次压入多一些的流。我们的目标是迭代的次数少且每次压入的流要多。</p><h2 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h2><p>Edmonds-Karp算法是使用BFS（广度优先搜索）的方式，选择最近的路径作为增广路径，伪代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">initialize f(e) = 0 for all e</span><br><span class="line">while there is a s-t path in Gf do</span><br><span class="line">    choose a shortest s-t path in Gf using BFS</span><br><span class="line">    f&apos; = augment(P, f)</span><br><span class="line">    f = f&apos;</span><br><span class="line">end while</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>走了好久终于等到现在…</p><p>总结来说，前面一直在铺垫，积累些基础知识，为了得到最大流最小割定理，然后证明Ford-Fulkerson方法能够获得最大流。</p><p>但是，这终归是个方法。方法没有告诉我们哪一种寻找增广路径的算法是最好的。于是就有人搞了各种算法，进行了各种测试，性能也就各不相同了，如下图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhangxiaoyang.me/drafts/categories/intro-to-algorithms-tutorial/images/%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>总之，是为了算法实现的更好，终极目标是高效的找到最大流，也就是解决最大流问题咯。</p><p>一些参考：</p><ol><li><a href="http://www.csie.ntnu.edu.tw/~u91029/Cut.html#2" target="_blank" rel="noopener">http://www.csie.ntnu.edu.tw/~u91029/Cut.html#2</a></li><li><a href="http://blog.csdn.net/leolin_/article/details/7202691" target="_blank" rel="noopener">http://blog.csdn.net/leolin_/article/details/7202691</a></li><li><a href="http://blog.csdn.net/smartxxyx/article/details/9293665" target="_blank" rel="noopener">http://blog.csdn.net/smartxxyx/article/details/9293665</a></li><li><a href="http://blog.csdn.net/kk303/article/details/6728400" target="_blank" rel="noopener">http://blog.csdn.net/kk303/article/details/6728400</a></li><li><a href="http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html" target="_blank" rel="noopener">http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html</a></li><li><a href="http://chhaj5236.blog.163.com/blog/static/112881081200982835124243/" target="_blank" rel="noopener">http://chhaj5236.blog.163.com/blog/static/112881081200982835124243/</a></li><li><a href="http://xpgc.vicp.net/course/ada4ia/TechDoc/ch09/ia-09-maxflow.pdf" target="_blank" rel="noopener">http://xpgc.vicp.net/course/ada4ia/TechDoc/ch09/ia-09-maxflow.pdf</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- EOF --</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法导论" scheme="https://albert-5.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="网络流" scheme="https://albert-5.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流问题" scheme="https://albert-5.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Typora语法</title>
    <link href="https://albert-5.cn/2019/05/31/Typora%E8%AF%AD%E6%B3%95/"/>
    <id>https://albert-5.cn/2019/05/31/Typora语法/</id>
    <published>2019-05-31T08:35:16.000Z</published>
    <updated>2019-05-31T08:47:44.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora-语法"><a href="#Typora-语法" class="headerlink" title="Typora 语法"></a>Typora 语法</h1><h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3><p>要启用这个功能，首先到<code>Preference</code>-&gt;<code>Editor</code>中启用。然后使用<code>$</code>符号包裹Tex命令，例如：<code>$lim_{x \to \infty} \ exp(-x)=0$</code>将产生如下的数学表达式：</p><p>$\lim_{x \to \infty} \exp(-x)=0$</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>下标使用<code>~</code>包裹，例如：<code>H~2~O</code>将产生H~2~O, 即水的分子式。</p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><p>上标使用<code>^</code>包裹，例如：<code>y^2^=4</code>将产生表达式y^2^ = 4</p><h3 id="插入表情-happy"><a href="#插入表情-happy" class="headerlink" title="插入表情:happy:"></a>插入表情:happy:</h3><p>使用<code>:happy:</code>输入表情:happy:,使用<code>:sad:</code>输入表情:sad:,使用<code>:cry:</code>输入表情:cry:等。以此类推！</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>用HTML的语法<code>&lt;u&gt;Underline&lt;/u&gt;</code>将产生下划线<u>Underline</u>.</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用<code>~~</code>包裹的文本将会具有删除的样式，例如<code>~删除文本~</code>将产生<del>删除文本</del>的样式。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>使用`包裹的内容将会以代码样式显示，例如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用`printf()`</span><br></pre></td></tr></table></figure><p>则会产生<code>printf()</code>样式。</p><ul><li><p>输入<code>~~~</code>或者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure></p><p>​<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class HelloWorld&#123;</span><br><span class="line">  System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将会产生</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public Class HelloWorld&#123;</span><br><span class="line">  System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>使用两个*号或者两个_包裹的内容将会被强调。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**使用两个*号强调内容**</span><br><span class="line">__使用两个下划线强调内容__</span><br></pre></td></tr></table></figure><p>将会输出</p><p><strong>使用两个*号强调内容</strong><br><strong>使用两个下划线强调内容</strong><br>Typroa 推荐使用两个*号。</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*</span><br></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。</p><p><img src="http://typora.io/img/drag-img.gif" alt="drag and drop image"></p></li></ul><h3 id="插入URL连接"><a href="#插入URL连接" class="headerlink" title="插入URL连接"></a>插入URL连接</h3><p>使用尖括号包裹的url将产生一个连接，例如：<code>&lt;www.baidu.com&gt;</code>将产生连接:&lt;<a href="http://www.baidu.com&gt;" target="_blank" rel="noopener">www.baidu.com&gt;</a>.</p><p>如果是标准的url，则会自动产生连接，例如:<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p><p>也可以借用HTML中的语法结构，使用<strong><a></a></strong>标签</p><h3 id="目录列表Table-of-Contents（TOC）"><a href="#目录列表Table-of-Contents（TOC）" class="headerlink" title="目录列表Table of Contents（TOC）"></a>目录列表Table of Contents（TOC）</h3><p>输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。</p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>使用<code>***</code>或者<code>---</code>，然后回车，来产生水平分割线。</p><hr><h3 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h3><p>我们可以对某一个词语进行标注。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">某些人用过了才知道[^注释]</span><br><span class="line">[^注释]:Somebody that I used to know.</span><br></pre></td></tr></table></figure><p>将产生：</p><p>某些人用过了才知道[^注释]</p><p>[^注释]: Somebody that I used to know.</p><p>把鼠标放在<code>注释</code>上，将会有提示内容。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|姓名|性别|毕业学校|</span><br><span class="line">|:---|:---:|:---:|</span><br><span class="line">|1|男|1|</span><br><span class="line">|2|男|1|</span><br><span class="line">|3|女|1|</span><br></pre></td></tr></table></figure><p>将产生:</p><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">毕业学校</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:center">男</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">2</td><td style="text-align:center">男</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">3</td><td style="text-align:center">女</td><td style="text-align:center">1</td></tr></tbody></table><p>其中代码的第二行指定对齐的方式，第一个是左对齐，第二个是居中，最后一个是右对齐。</p><h3 id="数学表达式块"><a href="#数学表达式块" class="headerlink" title="数学表达式块"></a>数学表达式块</h3><p>输入两个美元符号，然后回车，就可以输入数学表达式块了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>将会产生:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/31/5cf0e9f57e0df95282.png" alt="123.png" title>                </div>                <div class="image-caption">123.png</div>            </figure><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 逛街</span><br><span class="line">- [ ] 看电影</span><br><span class="line">- [ ] 约泡</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 吃饭</li><li style="list-style: none"><input type="checkbox" checked> 逛街</li><li style="list-style: none"><input type="checkbox" checked> 看电影</li><li style="list-style: none"><input type="checkbox" checked> 约泡</li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**无序的列表**</span><br><span class="line">* tfboys</span><br><span class="line">* 杨洋</span><br><span class="line">* 我爱你</span><br></pre></td></tr></table></figure><p><strong>无序的列表</strong></p><ul><li>tfboys</li><li>杨洋</li><li>我爱你</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**有序的列表**</span><br><span class="line">1. 苹果</span><br><span class="line">6. 香蕉</span><br><span class="line">10. 我都不喜欢</span><br></pre></td></tr></table></figure><p><strong>有序的列表</strong></p><ol><li>苹果</li><li>香蕉</li><li>我都不喜欢</li></ol><h3 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h3><p>使用&gt;来插入块引用。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一个块引用！</span><br></pre></td></tr></table></figure><p>将产生：</p><blockquote><p>这是一个块引用！</p></blockquote><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>使用#表示一级标题，##表示二级标题，以此类推，有6个标题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://albert-5.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="typora" scheme="https://albert-5.cn/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="https://albert-5.cn/2019/05/23/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <id>https://albert-5.cn/2019/05/23/模拟退火算法/</id>
    <published>2019-05-23T15:51:26.000Z</published>
    <updated>2019-05-24T11:56:46.207Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <strong>模拟退火算法</strong></p><p>模拟退火算法(SimulatedAnnealing)是基于Monte-Carlo迭代求解策略的一种随机寻优算法,主要用于组合优化问题的求解。</p><p>假设现在有这么一个函数：<br>$$<br>f(x) = x^3-72x^2+4x+5<br>$$<br>现要求其在[0,100]范围内的最小值，如果不求导计算，可能第一反应都是穷举法，把范围内每个值都算一遍再比较大小。如果求的是整数范围，那么要算100遍，但是如果要精确到小数后8位，则要算10000000000次，即便使用计算机依然是一个庞大的运算过程。而优化问题中很多都类似于问题，无法用穷举法解出答案，我们叫这类问题为NP难问题（可查看维基百科：<a href="https://en.wikipedia.org/wiki/NP-hardness" target="_blank" rel="noopener">NP-hard</a>），于是，有人提出了<a href="https://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">爬山法</a></p><p>也可以参考下<a href="https://blog.csdn.net/lvhao92/article/details/50826709" target="_blank" rel="noopener">争取几句话描述一下爬山法，模拟退火，遗传算法</a>他的博客文章博客文章</p><blockquote><p>但是这个方法的缺点在于最优解的产生依赖于最初值的选取，无法解决非凸函数，即容易收敛于局部最优解；同时，也无法解决有平台的函数的问题</p></blockquote><p>于是，Kirkpatrick等提出了模拟退火算法，它是一种<strong>启发式搜索算法，即按照预定的控制策略进行搜索，在搜索过程中获取的中间信息将用来改进控制策略</strong></p><p><strong>1. 模拟退火算法的原理</strong></p><p><strong>1.1 概念</strong></p><p>模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><p>模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以一定的概率准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果。</p><p><strong>1.2 状态空间与邻域函数</strong></p><p>状态空间也称为搜索空间，它由经过编码的可行解的集合所组成。而邻域函数应尽可能满足产生的候选解遍布全部状态空间。其通常由产生候选解的方式和候选解产生的概率分布组成。候选解一般按照某一概率密度函数对解空间进行随机采样获得，而概率分布可以为均匀分布、正态分布、指数分布等。</p><p><strong>1.3 状态转移概率（Metropolis准则）</strong></p><p>状态转移概率是指从一个状态转换成另一个状态的概率，模拟退火算法中一般采用Metropolis准则，具体如下：<br>$$<br>P = \begin{cases}<br>1 &amp; E(x_{new})&lt;E(x_{old}) \<br>exp(-E(x_{new})&lt;E(x_{old})\over{T} &amp; E(x_{new})\geq E(x_{old})<br>\end{cases}<br>$$<br>其与当前温度参数T有关，随温度的下降而减小。 </p><p><strong>1.4 冷却进度表</strong></p><p>冷却进度表是指从某一高温状态T向低温状态冷却时的降温函数,设时刻的温度为T(t)，则经典模拟退火算法的降温方式为：<br>$$<br>T(t)={T_0\over{lg(t+1)}}<br>$$<br>快速模拟退火算法的降温方式为：<br>$$<br>T(t) = {T_0\over{t+1}}<br>$$<br>另外还有其他的降温函数，其实只是收敛的速度不同罢了。</p><p><strong>1.5 初始温度</strong></p><p>一般来说，初始温度越大，获得高质量解的几率越大，但是花费的时间也会随之增加，因此，初温的确定应该同时考虑计算效率与优化质量，常用的方法包括：</p><p>(1)均匀抽样一组状态，以各状态目标值的方差为初温。</p><p>(2)随机产生一组状态，确定亮亮状态间的最大目标值差，然后根据差值，利用一定的函数确定初温，如：<br>$$<br>T_0 = -{\Delta_{max}\over P_r}<br>$$<br>其中Pr为初始接受概率。</p><p>(3)根据经验公式给出</p><p><strong>1.6 循环终止准则</strong></p><p>内循环终止准则：</p><p>（1）检验目标函数的均值是否稳定</p><p>（2）连续若干步的目标值变化较小</p><p>（3）按一定的步数进行抽样</p><p>外循环终止准则</p><p>（1）设置终止温度</p><p>（2）设置外循环迭代次数</p><p>（3）算法搜索到的最优值连续若干步保持不变</p><p>（4）检验系统熵是否稳定</p><p><strong>Python实现过程：</strong></p><p>下面便通过python求解开头提到的问题，首先定义函数，然后通过pyplot看看函数在[0,100]上的大致图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment">#define aim function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aimFunction</span><span class="params">(x)</span>:</span></span><br><span class="line">    y=x**<span class="number">3</span><span class="number">-60</span>*x**<span class="number">2</span><span class="number">-4</span>*x+<span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">x=[i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">y=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    y[i]=aimFunction(x[i])</span><br><span class="line"></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/23/5ce6be9b1a85441627.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可以看到最小值大概在48左右，通过求导计算得到最小值为48.45。</p><p>接下来便构造SA模型：</p><p>定义初温、低温阈值并通过随机得到初始x，同时定义时刻t。通过均匀分布构造邻域函数，同时设定内循环次数为50次，降温函数使用<br>$$<br>T(t) = {T_0\over{t+1}}<br>$$<br>代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="number">1000</span> <span class="comment">#initiate temperature</span></span><br><span class="line">Tmin=<span class="number">10</span> <span class="comment">#minimum value of terperature</span></span><br><span class="line">x=np.random.uniform(low=<span class="number">0</span>,high=<span class="number">100</span>)<span class="comment">#initiate x</span></span><br><span class="line">k=<span class="number">50</span> <span class="comment">#times of internal circulation </span></span><br><span class="line">y=<span class="number">0</span> <span class="comment">#initiate result</span></span><br><span class="line">t=<span class="number">0</span> <span class="comment">#time</span></span><br><span class="line"><span class="keyword">while</span> T&gt;=Tmin:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="comment">#calculate y</span></span><br><span class="line">        y=aimFunction(x)</span><br><span class="line">        <span class="comment">#generate a new x in the neighboorhood of x by transform function</span></span><br><span class="line">        xNew=x+np.random.uniform(low=<span class="number">-0.055</span>,high=<span class="number">0.055</span>)*T</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>&lt;=xNew <span class="keyword">and</span> xNew&lt;=<span class="number">100</span>):</span><br><span class="line">            yNew=aimFunction(xNew)</span><br><span class="line">            <span class="keyword">if</span> yNew-y&lt;<span class="number">0</span>:</span><br><span class="line">                x=xNew</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#metropolis principle</span></span><br><span class="line">                p=math.exp(-(yNew-y)/T)</span><br><span class="line">                r=np.random.uniform(low=<span class="number">0</span>,high=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> r&lt;p:</span><br><span class="line">                    x=xNew</span><br><span class="line">    t+=<span class="number">1</span></span><br><span class="line">    print(t)</span><br><span class="line">    T=<span class="number">1000</span>/(<span class="number">1</span>+t)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line">print(aimFunction(x))</span><br></pre></td></tr></table></figure><p>经过循环输出x与y，结果如下：</p><p>​            48.45411386249023    -55082.24210065413</p><p>可以看到SA算法很好的逼近了最优解。</p><p><strong>参考文章</strong></p><p><a href="https://www.imooc.com/article/30160" target="_blank" rel="noopener">模拟退火算法与python实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="智能算法" scheme="https://albert-5.cn/categories/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://albert-5.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="https://albert-5.cn/tags/python/"/>
    
      <category term="模拟退火" scheme="https://albert-5.cn/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="https://albert-5.cn/2019/05/16/Leetcode/"/>
    <id>https://albert-5.cn/2019/05/16/Leetcode/</id>
    <published>2019-05-16T08:29:30.000Z</published>
    <updated>2019-05-16T08:31:51.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><font color="indigo" font-size="5">领扣–引领新时尚</font></strong></p><h4 id="1、两数之和问题"><a href="#1、两数之和问题" class="headerlink" title="1、两数之和问题"></a>1、两数之和问题</h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>解法1–暴力解法</p><p>思路：</p><blockquote><p>给定一个数组和一个特定的目标值，对每一个数进行遍历，然后利用两层循环遍历的值进行if条件判断，如果相等，则返回下标；否则返回None.</p></blockquote><p>具体实现：</p><blockquote><p>class Solution:<br>def twoSum(self, nums,target):<br>       for i in range(len(nums)):<br>           for j in range(i+1, len(nums)):<br>               if nums[i]+nums[j] == target:<br>                   return [i, j]<br>               else:<br>                   continue</p><p>nums = [2,7,11,15]<br>target = 9<br>solution = Solution()<br>print(solution.twoSum(nums,target))</p></blockquote><p>缺点：过于暴力，两层循环使得时间代价过高。</p><p>时间复杂度：O(n^2^)</p><p>解法2–较优化算法</p><p>思路：</p><blockquote><p>相比于暴力解法，此法优化了双层循环</p><p>一次循环遍历，然后用目标值减去数组中的每一个值，然后判断减去得到的值是否在数组中，进而再判断小标问题；</p></blockquote><p>具体实现：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">&gt;    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)):</span><br><span class="line">&gt;        a = target - nums[i]</span><br><span class="line">&gt;        <span class="keyword">if</span> a <span class="keyword">in</span> nums:</span><br><span class="line">&gt;            b = nums.index(a)</span><br><span class="line">&gt;            <span class="keyword">if</span> b != i:</span><br><span class="line">&gt;                <span class="keyword">return</span> [i, b]</span><br><span class="line">&gt; </span><br><span class="line">&gt; nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">&gt; target = <span class="number">9</span></span><br><span class="line">&gt; solution = Solution()</span><br><span class="line">&gt; print(solution.twoSum(nums, target))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>解法3–优化算法 &lt;来源于网络，怪自己 :sweat:···&gt;</p><p>思路：</p><blockquote><p>优解:创建一个字典，通过循环把 target - nums[x]作为键，x作为值存入字典，边存边检查当前正在处理的nums[x]是否存在于字典中，存在：返回字典中nums[x]的值，和当前正在使用的x的值。</p></blockquote><p>具体实现：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">&gt;    dic = &#123;&#125;</span><br><span class="line">&gt;    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">&gt;         <span class="keyword">if</span> target - nums[x] <span class="keyword">in</span> dic:</span><br><span class="line">&gt;            result = [dic[target - nums[x]], x]</span><br><span class="line">&gt;            <span class="keyword">return</span> result</span><br><span class="line">&gt;         dic[nums[x]] = x</span><br><span class="line">&gt;        </span><br><span class="line">&gt; nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">&gt; target = <span class="number">9</span></span><br><span class="line">&gt; solution = Solution()</span><br><span class="line">&gt; print(solution.twoSum(nums, target))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="2、回文数问题"><a href="#2、回文数问题" class="headerlink" title="2、回文数问题"></a>2、回文数问题</h4><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>解法1–较优化解法</p><p>思路：</p><blockquote><p>将所给数字转化为<strong>字符串</strong>，因为回文数是具有对称性的，所以比较字符串的第一位和最后一位、第一次位和末尾次位 ······<font color="indigo">但是由于一位数以及负数和末尾为0的数的特殊性，应该加以判断。</font></p><p>由于对称性，所以考虑字符长度，奇偶数：通过模2判断只需要判断一般就可以了。</p></blockquote><p>实现：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">&gt;         n = str(x)</span><br><span class="line">&gt;         print(n)</span><br><span class="line">&gt;         m = len(n)</span><br><span class="line">&gt;         count = <span class="number">0</span></span><br><span class="line">&gt;         <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt;         <span class="keyword">elif</span> n[<span class="number">0</span>] == <span class="string">"-"</span> <span class="keyword">or</span> n[m<span class="number">-1</span>] == <span class="string">'0'</span>:</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">&gt;         <span class="keyword">elif</span> m % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">&gt;             <span class="keyword">for</span> i <span class="keyword">in</span> range(int(m/<span class="number">2</span>)):</span><br><span class="line">&gt;                 <span class="keyword">if</span> n[i] == n[m<span class="number">-1</span>-i]:</span><br><span class="line">&gt;                     count += <span class="number">1</span></span><br><span class="line">&gt;                 <span class="keyword">else</span>:</span><br><span class="line">&gt;                     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">&gt;         <span class="keyword">else</span>:</span><br><span class="line">&gt;             <span class="keyword">for</span> i <span class="keyword">in</span> range(int((m+<span class="number">1</span>)/<span class="number">2</span>)):</span><br><span class="line">&gt;                 <span class="keyword">if</span> n[i] == n[m<span class="number">-1</span>-i]:</span><br><span class="line">&gt;                     count += <span class="number">1</span></span><br><span class="line">&gt;                 <span class="keyword">else</span>:</span><br><span class="line">&gt;                     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">&gt;         <span class="keyword">if</span> count == int(m/<span class="number">2</span>) <span class="keyword">or</span> count == int((m+<span class="number">1</span>)/<span class="number">2</span>):</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; X = <span class="number">0</span></span><br><span class="line">&gt; solution = Solution()</span><br><span class="line">&gt; print(solution.isPalindrome(X))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>时间复杂度为 O(n)</p><p>执行代码，运行时间108 ms</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://albert-5.cn/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://albert-5.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="两数之和" scheme="https://albert-5.cn/tags/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
      <category term="回文数" scheme="https://albert-5.cn/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>sublime配置有关问题</title>
    <link href="https://albert-5.cn/2019/05/06/sublime%E9%85%8D%E7%BD%AE%E6%9C%89%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://albert-5.cn/2019/05/06/sublime配置有关问题/</id>
    <published>2019-05-06T07:42:54.000Z</published>
    <updated>2019-05-06T07:46:34.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Answer-amp-amp-Question"><a href="#Answer-amp-amp-Question" class="headerlink" title="Answer &amp;&amp; Question"></a>Answer &amp;&amp; Question</h2><h3 id="安装Package-Control"><a href="#安装Package-Control" class="headerlink" title="安装Package Control"></a>安装Package Control</h3><p><strong>安装Package Control有两种方式，第一种方式为：在控制台中输入安装命令。调出控制的方式为：Ctrl+`。Sublime Text2和Sublime Text 3的命令如下：</strong></p><p><strong>sublime text 2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2,os,hashlib; h = <span class="string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ipp) <span class="keyword">else</span> <span class="literal">None</span>; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by) <span class="keyword">if</span> dh == h <span class="keyword">else</span> <span class="literal">None</span>; print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h) <span class="keyword">if</span> dh != h <span class="keyword">else</span> <span class="string">'Please restart Sublime Text to finish installation'</span>)</span><br></pre></td></tr></table></figure><p><strong>sublime text 3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure><p><strong>这一种方法我试了，好像没有卵用，打开console时会出现错误—由于连接方在一段时间后没有正确答复或者连接的主机没有反应，连接尝试失败</strong></p><p>So, 失败告终，唯能另寻别发</p><hr><hr><p><strong>后来在网上找了大量文章，看了好多解决方法，但大多无用，因为那个官网是无法访问的，好像是因为ip6什么的问题，但是除了······*<a href="需要的可以联系我981287080@qq.com">^注释1</a>这样可以下载得到package control压缩包</strong></p><p><strong>万事大吉？？？想的可真多啊 ^-^</strong></p><hr><hr><p>下载之后在指定的preferences/browser packages进行拖放下载好且解压好的文件，之后看是否出现<strong>package setting</strong>，如果出现，<strong>Ctrl+shift+P</strong>，输入<strong>install package</strong>，你就会看到这个包</p><p><strong>也就说明 You are ok</strong></p><p>但是<strong>不可避免出现 there are no packagesa avaliable for installation</strong>的错误。</p><p>怎么办？？？？</p><p>可愁死我了·······</p><p>找了资料发现是这个原因 <strong>在利用sublime进行插件下载时，sublime会调用channel_v3.json文件，点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default，可以看到该文件是放置在网络中进行读取的，而由于GFW的原因，导致无法读取该文件（但是竟然可以直接访问？？），这也就是导致插件无法下载的原因</strong></p><p>所以只需要修改这个<strong>json</strong>文件即可</p><p>方法也有很多，这是我在<a href="https://www.zhihu.com" target="_blank" rel="noopener">知乎</a>上看到的<a href="https://www.zhihu.com/question/26373122/answer/156739767" target="_blank" rel="noopener">https://www.zhihu.com/question/26373122/answer/156739767</a></p><p><strong>但是我没有成功，嘤嘤嘤</strong>，主要是因为json文件没法下载</p><p>后来找到了,<a href="https://raw.githubusercontent.com/Albert-5/Stark-Lab/master/channel_v3.json" target="_blank" rel="noopener">给你</a></p><p>添加到本地文件夹，然后在<strong>点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default</strong>看到一个<strong>channels</strong>，后面的路径修改下就可以了</p><p>别慌！！</p><p>记得试一下哦，老方法，</p><p><strong>Ctrl+shift+P</strong>，输入<strong>install package</strong>，你就可以开始玩耍啦~~</p><p>学习之中遇到的问题就记录下来了，小白上路，若有问题可联系me<a href="Email:981287080@qq.com" target="_blank" rel="noopener">^contact me</a>,欢迎指正。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="sublime" scheme="https://albert-5.cn/categories/sublime/"/>
    
    
      <category term="sublime" scheme="https://albert-5.cn/tags/sublime/"/>
    
      <category term="python" scheme="https://albert-5.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>摄影理论篇</title>
    <link href="https://albert-5.cn/2019/05/03/%E6%91%84%E5%BD%B1/"/>
    <id>https://albert-5.cn/2019/05/03/摄影/</id>
    <published>2019-05-03T03:00:03.000Z</published>
    <updated>2019-10-20T11:06:17.437Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试!" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容!"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="您好, 这里需要密码!" /><label>您好, 这里需要密码!</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="b9a7a5cb3afd7a4d581653298b3627193b77a51180229a6f8db6002e3ef9c30e">682fa8c006cfdd34dc241390361c3f4d62f3b9bff4e97b5cb2cc89c71ae63b24ac300401b2988a87269ebd70c294925cd677eb94796ef720fbd061e7573f73da45e67a1a682db3378fe342356049664a2ef4f1e9028bb18bb18fbb231cf14762c6ec62019364510c0df339412cf2c6db67b73a1e72d47babfbaba648e5aa2c78af9c37c61ff3cd21d0cdd88a20c0099ac090fb2655b0614f0714b465c9dee69cbd7837f566cd2ddb20d4b9c1cc7d1a6fd75a14a5fbe87e7a94e8b552b47389b04443f85347e24e81f615bb31e37e8d30c09937bcf6485fafcd974182afe570bf6daef1488c28e8af021e1db089e6de5506bdcb55ad1968e6f47dcf03535d924ac6ab0e0fa5d9e9f86dba3c303b9dd2cafb8d5995c4a86e4a5aae19aed9242ee86467c338f627d264fe9d2beec5ccf86422b52fd97f512766defb0b4b7d773c6b51073ad43c27fac6b46c9877731724bab9411fc254bcb37f2782d93583aa182878a243dee5eb9feefd0e6ea63a3e80c49cd6f0f42fa3639697881f901bd9139ce054adf73ad1124eb65ecf0cf0c1940cbe434c90b49a9c87b2bfc54ce334b3efdd26ec7265698d9d41ac80e15e5f5d9d4406f1ff3835163aa81b872183f3f8aaff255e1e1578ca6be8dd94a6e5eb930cc0814e99c987e45b8ba612c5bed76c37af7bd4a1a35c76f91d55d7237115f0587910ebdb579e023d3c5fac9e5623c4f25c4e67b12163a87be25f35cb0f94f8516c1f9ba0d63e6c4efce51706f14fd089e051850f7c5c8d66a67a89385671094100a6c2277c490376ac7c425771b59470ff197f3f82181f6af89bcf34d8cada58386bc8a0b161f82e33eafbb87efd1011e906f322f4c40b816ddbecd6e515b7db42293bbcc9669e2a033d9ab871acee7bb695553ee2561d2305e6198a2d12fa370d582271e0c0197a9dbe3f020986c881dbcd9ecc2e3412c05ab436bd2a68e74959059eee240e8b26dcbd95c3ef5ac98a245a5c39d3e76bf83ee9511134bdbcf52605fd04043e5ed85f598f80d3465a36df871392ede4922b40212bd8f7369060d5f63709bd08fceee844a5ede4c4503815fd399a87432dc930350d660cd2a2a805bdb3019b5b07cc03fe78bb1bdd5ab03867015e7dd5e88e11f4acac2d91e6e8c5a65c35be2c331f4cc88aaf8a93faab9e317f59ab48a02ec661c3aae74056521a585cf56adece707cfaec7c88265d1ef17bc2a239502db80d2f74630af930c51b378aaf41668e8fee52a64e78fbda35edf903deee4d22a53652955a2384d9fdd86062ec677672ba74c00bfe45bfd590600ea7d8fc0ee332c3b8e7e0c35d3329e15ea65fd1a7122d3f44d9509bedeedc0b4f0ce887aee935fc3f03e95032b43089484f141303905a1e18df08e9deddc4f0658b772d5289e1b5307b0ffb7a8689440fca91f94471fb4b8f6c31d6c6d2a3ab9725c12d7209cbe7223ad7e568a3c1ad24423cb38fb0269f17ad9c5b5f955ba2e78b67fc9918c874c5d00a4d522eb2b6fda1c9a1aa53ea62faef9b547c1a515509944e7f0e1d56834501b85440d58b2128bd2ccdeae41fe086916fe5b696842dc3a42521fff89ee51a101aa217bf7df7bc1755c55a3dfadcb7bc62bc8ce30aaef2f96dd414ad4f21863586e1bee14337932cd2b4e8a50df95c2810d5e3eb7cf8e356c5dc812a4328a655579d39e141b04efe762b38ad45119ea86402efe4de70123bfd593496b68348b4e8dd0738b1c0f137e1390e377e24fa90dd365fa719997a89e0ab4fee9e0c60cc9ff6aa095075a33eb79c5d2fc44824bf0608cc5a75c422c876aad19336dccecfcd2ea137c8e1ed8da3eb2b07fa4181df9d977c5747a2def00915d335e8e4b00bf8c7b943a148c5dfdb46dca2ed2d799a16a1e1ab1bb40d0da690ade636685efc2bc6e75e7c1af6f89b39654b681801bcf47653b64b0dd828fd48fa36eb8740286844e0b94bf9d8846a6a6b372c604338dbc6d58d77dd59ab6bf6a1325910872588634abb253c71233961d807f95ee9ab849b726a2445ab80d27157a7ced5900da7fab7d81423834b57dafc1602d3ec6a90c3a606d68066764888ef4f1c14bf997af5abbaa3eb45415569624e415f496f2e2d86160e6cc965c3032981ec20eaba8b85a548489e5daf274eecc1f0313819a7fdc616d8b0509cdfd1f4b18ff4c5f9b34ae33ae32574a2d0914e00ead3f7816d01f2470c2b47ed01517e73804d539a3c3d65576e5b2653b118fa7df44a1a84335da24daed59504e959a779d5bf7a6c3db4eff006d46c8e522f06bf89202a5e8455bd9cfee25c2aa94e6e1f3bcdd2d77fcb66cf5a61cad61f5945211aa49a1e9b986c9cf72c33e2def4dff7ef5bc8ab71aeee08b5b0375793985763ea60ece54c0d6638ee28c7e7697f02529b380b0cfb69e10852c89b71992bfb864d176147f43857567158b57f65371fd6f6a6a5553a019befb0f9d218e518df11b72684b36b4c4a65dc76cb4749fa35c801835ecb842006f303dfda2c52062ff1cb127ed10fdaa71572745ddfa67746ce6dbbbaf3ce5b79ac0d0aeeb07ec6b686322a567ba57fb0b88bfe2f245637aa588a29ce5250b9a394e5a91bbf6ad86332bd38397cdd9169036a1808a1e54f5af9656faa9a882e3005b85ef54d60e44095eba5cbb5e4b2bb59582d53880d113cdab502b992e4c17058e4fb26cd0afba7139979d27fd468188a996ec83994dd4c810a94fb2ca1e4adc86225dfe60e2cbdfb7f41815e787cd8abf6b1d786a7c24675471489a8abc6275305fb252c191a1fd83a230f867815856d88fea848f278575f1597b44133fc9cd4399e98d520e18dc5072c73c13b92b14ff672fda8e3595ee1fc7d4bfc58fd2380bd36dc5f44585d5ebbf21c9ddbbf1146db72e87727a0ee523e8da52ba0341eefc684c2a55b2557692a704ce56fa0c2b4b98c3c654d5b9951414f796366ed21d8668f815b0d3c17b3e79bfc217b8feae5eb8098e9a0958c697c63ea207b05272c3ea3a3174d1c3fefdb9ba6339294e299012fd5ff4c40f1c7061e213f0c928318f1cd1ca6af5f4ba68e99dccc1653045a5e7436483c3761e4cd393d9427a4b5786a0e3abe3a0cb4c6f8c08f33cbdd9bb2df86d4c3e1dd865aebe3823f4c4e99870bc78a715a12d430c3d282a44ec9527807561e7fe4e6c36512bb14f094c2e1f21f674ba799a05db919b7966301da4397f776f0e8eab6125a0a79001c4c55652fbd55b76fb5bb6008e2c9675f1ef7c969c8f6a6b76f2dc3d6267868598993af4087cac7ff6e50cacb262f7a894c308869408003f2b4d045ff7b2509c6dd18b232a29af6c560d47d20cdcab1acb840515afc1c617f42843d0b87ebd188c6bfbb38b1346df98d48240a097245d6c9fd3a2fb24467903e15abdd26ec1126956ee2d940f6bc264274579f44019e942b4d90d78c27f1cc7b7731956deaa01871d0ac03d07f93175f6bb2b8ecd601d98fe64e65e395b17b8b8fed70e21f79228cbf16209b7c140fa376f392f058d164f17979e00167cf61fbd44c2ce678b740dad4c2aa1a6a9d90c17ad92668d98d67a21935135c611431397856acb38a8bad043df11bcc57ebb6f090b85cff09782c5aef97f6b07a6350572b537fbe898bdbd66b7c366d7eb95b2a9eab1b93f414dd1c189bb0290cf422b35148c979ae16ba076cf28b5db13bc2ce7682f46b3e09fba911aeecbf5b761d421be8810c2dd2d6813824e77a3bcccc218b1744ec1e13b54adb5307b402667824fa520bdb65e4e025df5981bc2fef13671cfc13173f3a56f6d15f6b568b370b20874013c259bd0a948eb7c5fc1fc5ef2d3173f57f28a14fb14108b81b0b2451b3353a1936a3ddd164449f4505ef664e2f43b315a34c9241ae80b0aa23f5024ad4f53c4cdc184542e9fa2f90dad33cda81e4afde814973b2d31a19f8a512ddcfee1d93bbe8ab4f3a843745deb3fb0e8f7eba6c274bb558bfa51df171661bdc7cdfa9a9d702574379537d762c6463470787432a408b125a12a461086ba97dbd2b91425ee60a00e159a24c9aceca9b1fc10e1f37510573ccb8769ce5b3b868c56c968147001a9c5b6410d63e4873e57378824ab8c010ec1ca2d33abf6d677a1bf506dbbb59665d8981fa8ac9420b26ff9940d8e2a0e334e855bc021abeb0e73eef9ed4b076fb0320d8caab288a388c0c6281ef977f99a3358de578af61e0c37a930e7635bb5c86b85d501bd9f3b42f15ce8931cd2b381085dbdb2931a8cc1c2393fd14d1db0310e6d87f067a0f6cd723f03ccc08c48866f5f1471a87c523dcc6e4c5b52af71928c05887f39dbba0ef59b0b87c4d5ed655aa9a0c4c153f196456013b41ced70eda38bbd42cd7f8c31b59d71d526445f3d788f2cebbf72789c255e5a39cb61994867e9d275838a6fd2e2ac27a4e6296277a34eda7461f4c0730b40844df3dd043c6e229af60d40b19624b7e9e51d1bc460049917fd4e08b4dfd3810e82676cbc6510cc927122609ce21481a903e66bf5f3290fafd53d1df55e3972f4bc7a6bda009faebd90051891fa2d7264ef5981bf5422d6ae543767fae62eb65445ecc3114225a18ae7b17dd52a85ec08f9895121d94b32c6d1bd994da24df9629a0f3f39c1f3cc0558315dcf4902b1582a0a219eb6512f04ef64cb9cffc020af84b58016544f6951d2ee49568bd86603c044267c670a031dace54fd940376d8aa33c49ae84b249ebcbb19e52474839f265fb6bb7bfda4ade8ae7919373045e5fce375a5027f4f19d93afc1a3c352fd7699f40f73c5db72b3f7e511f86dcbe298dbcd57fc6d78722e08005f7d1951398cbe9d8ee967fb2c47b6a9fc589a0efd5ea6d67d4151cf2eb596aac81b84b0918b965909d299d703ba42a7fd4c8f20bfda4b68d68ec7ff92bb536465b00f1d0944b39347a37043096bde0276aa049da34a832b508ea5b5ba51269dcf0ebf8c04975f9eb361f68a022272a28d56326501819af09f0a30037267cd05c33930d4ad443a6e03953fd81afbcb140dc697b1cfb9bea769c8114c312e5035e7377b85e76e34413a2d32efa946d20bdb3722eed1f9424b87a94cb598100095547880bb31d7b6e48402abf825c8c5f8a4cbbf2dec98a1a7ccd7c0a6b743927e734a0579fb767e9f7616768ffe056498a6b4799c449822c0ca731f6f95894356034069a2e4466405ea23d76d3ffebf58f4508be5e47e716f8d0b750b3e34fb433c5ce18778c19cac013ea1eed4106862424e80298d9ce0dd34f31af432e558064ed68e1db442ab00f805d26f01e3e4d8016336354ee5123b46c9a8a346aaf96c8e3676f2566ace8bd91d7a6670d15a17fc496448cae8ad6c7e973e7702943d61acb2721acbcc0b3ebeb1cc2955e1ce8278921ce35410956863f78bdf5f26c56fd993cd0c023a66c0143ba7abc043fc5cea0a98f11ca4fff4bc9c8b66e169f8a3f28a64f73b1b4a5a20adef2180a06f209ef8ac6f3553523fac0490c3c4dc8ff3f815d1417fdcba37c1ad774e0da24ee8c6996b87369bb99e1e41d13644491c4f54f88ffe3e3727925ecdcfd308f75bd77bca280dda691cb6db3b29e589b5195b13f1a34df4d60391ed905e662f88ba087436577f0fac84bcf36811c7286c01914e852d48a602a229fceba58b28604878ab7201d52956bc895c21ecd933c7a1ae7d16dcb5ebe71cbbe814f1ff84327850ccdd86c743d649d5fbaea7657a158177610be12c222f3d378ec0318e897e842c91746996ddac8630436c4a98f2a885b28880c42bd11b847c1f581f6ffcad73cde36deab8500302b3cf03699b41eee864f7d15157118ba9786a3d06588f19f12ffa8051fdfb23ed84944992a17214931ec9b2048a4e1a91dcc332da550969b910decbeaddcb50f72c0c48cd5c7367b14e971deccbaf94ae4ad5b844f4e0f75dbd37a39ac7bde9bf33d9d2365450986a6ab403174c0d6a45d6bd614c0a76d21f11d34b4b47f723ba9e092f6acaf38fc5756698e61c3b997c5a5fa83607d8c1a6cfb1fda4451dd335f2d23269bbcbde479130273ec830072cfe422f3a3251334474a91fbbf30e480ea205dc5e09908d00aae18e13bf88bdf5a072f4a9ac641c89a77791bd651f66b4e13ef21c9dbcc66b91b7205f7a5d7f1aeb1f776caefc33499125383f04b9cecc49344b806a51a91d292499838c2d5af0684a78b1399734ead3a464b9076bb92d418731b803a991014fe01c70a5a185b0e0d2ecda0ae95c0a87d8f2602a83eb0a9f025c17957c3242c6e196a3a77e08b0d85ada99370b9623ecd27f531f0842ab68b3d5a278ed94bea6432ac47ec69ac03f2caac914287fb0b47f54afd2e966558a76eb8f00d9b40b8767e3ae3add8b072e569ef7bf24674a470d2bd48f7aa3fcd8377f8063dacea9fd5ecb87f638081d91df57803a66d37d8536a943c90abb6315eb461f267a30ee11888b84dfa67f3f24949af57d72b011aefb90e249a384b406327b03fea21b7950b84d5212019328cbcf8346d78179ce89c759ba30f67c9255ed11de7dbd2fd1851bfa353f7ef9ddf2b2e8a02a27d59c735ae936f9c2298b1b0338e570de001d8698191c7a7e3f31f5ec92e2c9d55e069d37cfa6f9c4eb8a75aa4063dcd319d2bc443293b9cfa7d9ecc27e3075644a3690367c654149a19083914cec0ef75c069fd3a00bfe5ce6a6f7fc609a3cb0401abf99bf1ea879a37ffaf0e3bde810f016189d074a79b1b82ef239c1ca37dde81332b1ea260de06f4deae9ac514956e9fa9cb2180a456ae69e8e0ee8f9d4e88b7d46026d47c15ca45937b898335c6921d26babf18a48f696196a6852f41144e8f68d7c8ae84b800aeaf2f624bd05d33209148d73c8e22874745ece5049c10bd0ad646c22173b0bffab28a75acff1a245ea0d1ce1d5994816322964f0b867307b7f56f8c1796816550f6c5d0953b24c2b4b0b9bd46f7d6e04cbf01519b671568aed001d3f37e1e70dd2e4140fc29c234dcdb6bfa85929f31a1e9c28b3d1bc10f46ff36d9325c13f822524bc81bc7afe5f9ffed92a51019ecb32ce1e24e7db7466e9da4ad964431cf8578987fe32b7cc6f93ea9ad94c648daf24deaaa90b76451e99f5463e4b9b7269a3e3872e35d12bb739e4baa5b617a714a33ce3972671c796022a8bcc20a67d6c93542e3af5409a9c6346cfd4d93b16f9b424fea214eaa0830277464c6dba201f0e280d57c6bef81a5b1005578b87a8894abd8a41dc54e895608ac1b3609c3fef419a064befe84c186ecac437cbe58472db9555c00deaade7b5e4cdfb2c3ff2fca3a705de59c176ee6059a5f6348b0854767284dd37c968dbd9615737f0520f9b3ca77370e2cb3be32aea5e24c0756b73328b498e05f064689a982c3ae92442a400b3dc7d6ced8f96f4a072408c93683ca75d5ed000d370f7116c006bfa19985d160209ba2ad0061f36a230bbfe11c18aa851238c7376b32d44aa6f70bf7a35ee331c7281dab1ba98326e3faee26e92a73f809285c9813298f18946c77faee637f2894ca62c491d4f9ed16d09f9cf29eea89b942e01f9d03d36ba2742795844483f97613fc51c0aa4e33e95be9d5dbb118d90826608ff772165960f45784f5924555adb6026765daea25ce1ed4e840382d619e573760a1f0f6228c622ce8cd07c4687c029410b9918b516cf07c6de431bb831f14528e32065a7c4e16c4faa15d25a3aad365f4c72804f133bc42860ccbef81a218b5afe8f040c918b8dff5d93315bddad6baba70bbed49101db92b7ea437d91308514081e3752950801e31df36365838b76486f3d696e4ac8eb11b80234a19c4a0c667367fcb0be578935e8cb468d1b211aa06e0cd4363651fc07e96c447c4c10e379bdd65d3cbfe31692792cb290f5565d796ad413691a9cdf7bcc25ec2ec54eea1951ee45a16bf2ec2344acf7e180f6c3f2d3a25805cfabed219ea9e0e06172bee4bb135ca4c764948f673b830c4caa63598ae02b212ee831dd159edfede786eee4390b871026398f49dfc55d0c0333bc76fb17d3e933b1cfbc2f5983e3f31521864979c35debd67cfd174c6027678171e6635cd124c409f946abd0b5beb1699cf8cbcab49e67b8514f16add564eafd90cf2a741d00e45036219826fd8896e089681d6168109df05c59db6c9d2e9cc08f3892d672017cfc89249e98c6db7c4902b3d860d03fe0b5d75554e3f09fb98d3beb7ec42f870241f3da05634942b1656ac60c3bc6b1bbdc011d219e3518473c03f0c399c4743b4ad5969fb90da874ab8ec617abf6ca1f7063a47a15035c869c70073eedddd3e4ccda85489f9d3ccb34ae75d065c9997c47ac41e9c52dbcc7209d3971655e6127b1eea1b77b8095422c5519af7f90d41454566d4c4782ff1384653e65dd8d65a03f2abcf8d9482976aeef864d8e06d7b5f1f366c2cea1514a8186d169ca348adb234f7b56a2a5358d97e6cbc5e8ea2666d94ff5da340f18985cbf658cd5bc862a5ea846fbdd8d335a8d56e80607e38449bbb6b73a57a8ad0cd4a6ab08aabe0ed3f472fa55ef309f064126d6196e6b12c4a22fbbbbba8574dc734ae527fcadd4541cd05714ccc16bcf23b65bc191bb2e7b217a6f2932bb9fd23943b0fc4ad6063d20335b154c0c1914de946b5abd92ba8a56827ac4b023bb46c832e3932a12427a5506a772a1e1760c704076899f605531244d32bdab3b6ddc19f35e0c855e50709aad4d216620864cfd98a9dc75d4a951ac54faf125f495ab3af9fafe2f1e23ff6703ef8524aae0a9c5298740a7b3ba436cc025bc52e7f9cceee50abea36887ff388b8f4971906863400472d9932c49752c7c8f9eea876e2b4f1a7c9db6ba995f608ab268a2866ecc0a6483398d7020117f26fccb2c16d992f9bed8303d9b7f398a0f1240bd9259f2d955d93c9ab093abed9cb5a27b14fa0dc6a14f8cd59611cf9eb8f96ecf02871ae964107d0f4778c8008bb25393ad9652358c24d6b1c0b9e8326bedde67cf2602579236b310c68866207f0ae9fe75e80cb2cab085febb3df439a8665c9ae4365ff095bfc0a4d1bbbf8ef155a9f3c977ebaec9b8bbc2851397ff3460539d07acdd56c8fc1f6e16b9a1b3d5c3db1eb77049016582153a2a3ceee64d7e3c481b6b7bf3a15d7d113126c244c5e7094147858162d64d96fa4333a18878f3728cd99b46a4a0922de018c6a38ae561acadb636affa211b368c648af92a74df3e5ad68217800671801a6c2d730dc6d4954d52f5f46c86226149b62b802f85204b94d78014d6ebb82ebbcad0a3b258a9f33eb482db2a4a4a69b7d04529101e64ce3446fda45e6a44517a0db61392998d08675e9f5acf71689ded60b4a50a75e6e10b880608940d5ac7e6c3ca1f4963eb19c77569281f99f63a2fc3a6da0f24084fbf0d6ee13b2bc51ec008d01bf2fc3b1280775c4596137de22a6b1ea5df56bfd58bda6b3c30989815df97cdefe3b376fc7ef76ee9b5ef4344ba19a70d84b42bc62480055736c5278dcbfa58c1a6f092c34edc97d6b42205425d075568dbbe59ef30880e3c3330a435b36877e585b44c2a9bf35575b8f33dfcf2ca739c3be60bd7a1c3b05960c3e3efd87b56e982796b8e74bbe5395d3f612019776ffe06ea0888660ba52750d1c8438bd72cb4aabedc9727088891e13fa585283057b507b620072f7f1690c3d8906872ccf6db1313bebe543fd6d9c5055d177b4ef75ef23fd20541e1afb1e5899402ce152e6c3bb0b0bd267525e0239ebd9c1bc22f85a6625d9f60665d77d36d07952bb497b482631bdc8baea74e12eaa41d0608c09ceca982c0a429e00086bea80cc61324936c39995b92af9934e43e750eac03b737045be4c59119c46d97364f3ec824146480663d777061bfcb8090da558ff1cd76c08ea6a034da645f6be0c9f4f816a5e6e4c0ef20f2f2472cc21d21563846e569dcf4b52664566cb1adb665dd9801d18be9c0858afba83c03841bea3ed0a309691ca18a9894ddda98a9cdabc0d3cac35249ac19ea4b88dc486c5d7d99266568ec2ecf5b4c76075c21fb7e032263c84f8887a8c2de6ac36d86e12aebd2d359b12e0c48e9715a1e01fd685064dd25509bdc4b5b01ff80ade5e114523f5fa44777a2f48b87e088c5d456b8a94572d02b061da29abe13679d4824a692ec88ecff798a6d03caf6935793287a4e91fcd88b9a3354389a66b26fdc920b8b00b8bfd649f6835b7143255e74bc9d128c15145b0a8dbd2da975a7f4f3a13d218f81d39845a0b8dac9e19dd5d3d69cb6a09979f5e62845baec037fd5e4c59fb4ec1751ead37a9ea14c4862a3b6875e16bcadae01e11b3968ef3178c66f913f05bd53e24cbcc86ea4b133952be5b89788aade033416e02ba4cbf9a21953f87636e6abbcd8c5d48a5649f564ba823a7d5ef9753e52c85462c64dd54d63289a492e37fa4c96cb69fc65ce99dfde50fa83865a8039c89aa9e9f81332e31a952891c5a2addf03c0757dd8ad3da4898db3e3a23bbda516cd018e9386f4d5621cc15956bf20775aa32bb045cf0058dde68a88eeedcea88dea9ca7d5894116fa165cbd2bc7d9d8fd725439d8085d81194da81226685578a27beb5cf998af2607588923aff92fad1eaa89838a95ee28b2f916389890a01cb420dc9c165072245f174cb090c3d343bfd22e9abe443f94b472d5a4426f29ac5f22cbb49eea535d022a07727619b9c7d13526cf5f3ecce174ac946e8a474848b903c9b628663e1ce77307cda90efe9740faf2920a102049102f9461f1fac1e21bd32730bd6385f1b70d7d9ee36f6c68a7fc9e1a30a2ca16abbd9aecad2d8b1c2b0d62d4dc806ce530203b3690ff8e98f9eb47b6797a8fc6efe610a8ea1f085621e2a9f7082566fea87aedf7be150d500f5479a19c4a21e243df8dc044b936bed2214c93b3c57db7d14418a30023037187adb4b5d870f082f559e8523fb4923db2e0c354aa72f312bc94b71fe84c2a6630fcaaadd383d743b737d9910f31381f47ba5c119d3292437b527816698f0f4e1a130be3431d9d8b86da2db38e82145d78ea76645813a45c24a614cb1c786a3aa6a1de452000cfea0f935e5424c1613cc6e1391c607a45b5704d4f5e54916fd13df2ae1162d81819496d234ffbc2fa838dd28a3d61962fdc66d1ecdb5de7de27790ddfd595ae685c0cf014d42a4cbb9e5ebe573937faac591b9844d20dac5321f9e239426d77024d7ecf8c011993edbbe1c4188d16f26f5840f739793fa10f4f034b6eedb325c77f2e3941250989cf7ced4239ecb1d5880ab6592def85b64f841baab7f6bc2de65d46152952c2b484919c64e424c45b2d819c8e1b910d0a85a8d128b633a5984909289f27b758bf9de6bda83a133308f417697d241cb38c7257c8c750d407d376f1dd7151f4d7fed6f54bd40e69bd7e563c096bcb570da592274b3663ab070c8bec736da473f844f5821278cf0d42e336263d1a7577ccf8493e75876c9f1227e34a37546e76199696539bef2abc89f602aeeb2b5df2e9f2a38f682ee618c14440091c78fb6925da7687fa1889e387ea5f41e97c89f3380778b06ba3428c30ca7e59b68c8897d4efc9caf7fe7e45816746eecd019ee58e9c53cb74a678573c7efbcd15658fbdb71a2f9f6dc728f73233a1dbc350e75ce3d26e694a6f757178ad7cc68ba627fc89e167cfbc4a54174e34623a729ef4714afcc34f04cbd6dd2ee85aa67a5df664dac87cc9bd793bcac8344dbdab447f0e9f01f77c594e0fc2d7724632aa77c99116774e405de4cb3d45a9a5a7adced4da452676dcd3507f97a2789c5f6008b99d84e7c549447d7bf7bd8bb18c23b2ee25ff727514a58cacf153509f5ddc19869927ff2ec4b751c347e890c921fc61082a7d577f0fed534755712a3692842fb8a73feff2a11818efdb464d7a514452549b4b4e825c46f5fb9da98ff757f566e01dcc062fa8ceaa9babd7e300d349784173e941c21640be0ba28104195db21aaf0d37edb7bc4c88b0341e7269a57fb2b0f69422a4ce3c199ae1083a128e32162249d580db24ce2e64fb822ac4bd1faf85e0bbe7cfb4611403493f37e863e80c287e1ba9c4cf6bb0864ada865604eafac3f7670c9d4aeeb1ff9fd064b5bd3637722266c4f766dbadc36444e83fd36d351ead57d4aa6ed0aa3b692a6651f17769049cb6392c5bad3ad74537871e77c27e22a5f7224f6aeab9a46f6df5dfba76843fc4b752ab4bd2494a10a28fe4c884302f03dfa919168922e24bd63805656433461b23f4d4e3b271d19c2d5617da0f3d84d0db6cd6410e4616c0af23683afb3397320a7508a0530c6facd815b2ae55a43c962439fc66a8acfbca6b74592f23f6f9108569b1f35444dfd692da7bfd911c1cf289b6ed4d654c006dcc7dea5fb082b832182195d16f68baeef1e393ef5cd297a72dabd099790804f3ac8a4d0a850ac963f67cc8ca3d6856cee92e51ab1a861039b6cbd3a6d5a1c5b3815b9ce7ffe4994806527233cc5ef64bd283526d3114bf74e8a346d393825f016d674a4f2698d96c2e0980aa79d83eb331d6247b1fa8c03d87290a5f1c4dc4b88ff89bb4be7562a07ad4aca05eec0068531c6bc310347fff562cc4d1386b299ca9cc352d0f13781abf1a9f3a6ffc8f0d9870a0c2698453e97bc78f0358ed7df3f3288d945e2d4b37eeb6cc3bc0f49c12e4635dad434425b697b563cde826828e42a5146bd73d987173977665b29d5b3b6b5e12d137ad71006c683616cef5cdb395d4e93038403f860e86256a31a5c3d28b81890737a333280bdd7cfe195d03c1d8b16bcb7c14f5e5fdc781afea6cce358f113fb5758528d7c39dae5f62772384c0d95d668d36d26d6a0c9b1363dcfe095ba36b9e58cbab2edb4df0c35053b20d36b11a4baf69b4562f7df37021aac808e99a312fd4fd7ad6aa4bbf4b6dbc624ec8243a9e88f0741f2623a1eae9c0b7692d26788f882c12ff687bac6b5d215ee8c783f57909de394cd057ad5da8dd52428ea2c3ab0f582f1b281d8104c26fd8e3ebaefa5d4280bcc2e8f4c3657f17de79fc00d4a72d55c12275d865d7f99e6865e62c0cd6c17919e86e31c9365f90ce758429517ea012a6d9d38e60456f5b915d03ed4ce3d59ce0bbd992cea656d0f70f96a2cf39b8fcc26864635b28e1de8f16517195536ee99387ff801fd6ee160f1c1e16dde8c3c80d0c5dfaaea7d0bd97b0098cd0c68dd92fb9136e4bd3aad1cadde34bdc71719ff07f872e202477ea335d641eb2436e31a0358a0584f88c2072a953958a87a35d83ac824e70018b7a88489ac2a187dc0f2f3069e1799caa410c6d25ea3968f69d5add1798e88dd74c5b2202d202edce8d7ca1cea78a50a95a0492ed00df618ed8626bb2d9c9043bade3edc0a6257da8ed3dbef775c7cfdb0e84a7c1fe7f823fd2074f67f6f32a8a51135da87752bc0b6e2f9a4f7e4fb203810bcb82026c1af97feba9a5489575319f90676c5a664ea2755cd3db9843142cb013a6de0223af71806460afe546d291ae1006943de6b2c12d6411e87515b9ad2d82f925fcc404c9b1a07ab83a920d74bb0f9a71363c9b84c3ba7b17dbc7e624d9ba3665e05fc7861fb4b72654306f18a49f590f537cd44b8cf0cefbdfe60eb217b6beb8e3d2999c3175baca7df44fa492452963375999695fb36448f1c8bb1c1ff750534e59b7543010305220b93e0e198646bc81b5a1c3393911baa168299c3982892a951f0cfd4b96b4eaf72ff82207d0f6808cfe64da673bb8ec77884ae55e474404288a73115cb1d32d32beec5cbfa3f4ff1ea73bc5cd9c5c8808a143f3d035ed9d7f184254b4995e7ddbb5726888d0171aa6ccc3c15d916f5ad286611817fee77cf869510cefbe69bc44995a76163f467cc5f0976a1b214c8f9aaa450cd7ed612074bea0112899190a200ef7d1f65bde7eb8ddb5a3e1bcb1dc62701aed60fa55868837a56b19d50855049c04e6df6f6a9c80de460bbd20962e246ae4c2d6bf6f5bbefe88ddc6400d8fc60eb6354d6f7fa232c24ad98ed1aeb5961c5741cf01dabf1ddc5bb970fccc0816f6ec42a03271754aaaa962f8705b1f8437a513cf1bfd0d59f4f4dad4c6a025dc9362155ff5e3f545087a406988e0ec0c2a2adc829cc146bbf14c3ddc795e3cad33c34c5dd5c06a33324d81308969341da90bafb9a3d6a93340243301427a9457d3c6ef39ffe0035c3df3dc2d119b1f8f98e7be394386ec7f4f9b9928b45535080fa8fb507a9c1b79124eabeb51f127797d43e96a46ab090ea993f1465cbddba3982975de041b9599678a4e2f84b709dc69f95f509ea9b05419684bdaf13382ff37720e3997516dd93633c88119938052dd0e545485874d86294a95e10e5ab9133852e802ae43a11487fae1e3a8b7b55009118796b8e06b504f6fdf611e8a77051e939b9ca96d48b6a08f7bcd89dedccb3da32096fb224fea2a6269ad72bd4e27fc248da33b60312a89c79a6dfe5ff970764bba87635650682b95e8899a5d16aad96fc7b36bfaf92484852b4237b69e57be28d53bd42b62d41bf198106a6d2fa84dbeccdaeff4ecd98596b65a4837419a634d016f1ce453418ef10b603e36e43e62e43362bce33c1e7deca64e528ec0cf96950f1e84d89a99d2b60902d5927744917511b0fd6041dc891ea2b881a972dab01de751610dd3418b94987af440106a2c903c30092b5e65f1b5d32c955bbf05b4e53b4884fd7665e07e580538bb74edd5d44817ddbfa21e0b2d5315749ffd85f2d75419e7e1811bc3aff541de49378640ef70b70c137bc2153b59e5153ba8a93b2021c51709dd771c72e1bafff7f1d7a1f11dd92d385d274b47026de08f131d501ce77e7bf4934f8c933c9c58225ff30de9b9f04f99db9aec8f880ececb4f404a64b25eca00571d47f88e1a8fae2780c1fe3392a0f11b41cc4d1ba6d4e2a778a08e16f47468eb24f3ded96d9654ef392f1b93a7adc8eac3dfa45caffcf5314ad3eea325674f0f664396dcb3ebacbc1fd66d74a456704e41879bee0eeb9d298b2370e9ab1c603794042277aa3893ac8e2299d9f397ec086b55ed7bfdf2d181a4d2863b715b7cbeca12f874fc79a304a5bef3ab8d1c56cdd229d0b25f0efe63bd2a84366a44372c943900db161731949e08a6c5ef7be5610f281543dcf5e326e73fc065d298fe3dd63c4741a8c80b6940ec4268c30f359bf974bae2408b080d37f3726ed1afc9e103a2a5610388cb4f5594924252d9e451be4eba4933afa445e18f2adda5a7b1d72db69d1e6fe9cc0f056b8c6ba0fed7c9c0c66362849f9acdd5e2d126ff840927d3808f6d685b0c68cd4e86cdbf5ce3ccf7ded91951ce564c4f52202f0871e41f29109450c82b67f9ac98410605258988f0016eb81942354a429d87861a743e53bad264b88105aee23e347ebb80e0ca7b2b2f97ee045d37d63d19e0289ded27607507045f90ca3b157cac397398f2cfc86a32a2b9175909023b04f27fb38bb8c04d640d3b8f73629a74df13a32044fdca73188ca948bafbb6967cb5347ba8379d3d64da4d0d32b877109f9e39602e23591806e28b54a86ed6a5f8603d54bbd2d8a9e90b9c54249d7b11b9b6bbea88a23e963905d5b9f6d978bcb2a796dcf67a36b3fc1bb910ab3bdc7665140d79432cd14762f90a5ca76777c66066120bea59b5aaf63d4ae21bd5113da279ef80314063a8e551ec8befbb5dc18a98f0de4d25fbb7fae8790a485c36d92457d5162594902b4dbe2ee5d43fa737b2ddc4371d30edf12789a8e3b643769e6e8e254cedd133f293214771dd5ff9299c329c5b72e86b9f2f4a4c23d635ba29bb777ebc31f378a11ed3d34b0c136a4c95caa6759a40cfa678720ac4575d93385e6d6f27deaa703ba0b08a8302472694f7760bcfbb20e5bc350c2b81d1ad71ab98ad66242063fbbd3bdc718f00ba9f7581b5e76a4d2d823052dc006298932886e4be5f4ceab8009706f24bf5dc8fdf7973e6f55bbf361a8d3e9345265da1d2537c4d686c1c71db1d060595c53c147fec8f7f788c4d6917fda3ca10232ca4f006eb741fe50a74bc94698dbae3a12745b7d74b607e8b96130f0343c2d76de96d3f53cf6fe852e88f8b0226e2927ac56fca3e5586e8f7b34dc3071cd9bd829da6b985c4977928d12d2770c39a5f11ebb9c7cef6415d26623df746e0251b04038ff07508057c4175954f91b113ab9e6320fd8ede2a77f41b90d0826a5e3eb2b19bcc1ad7788b83bead2f6ffa21cfb864b79d25dd3d410615f87e421f1cb921973bfe30db6dec571be466ce44ec48b51c0ce9af63d26deb56ef86006c919f0c081b63b1f547589cf29eec48885b8dabcf0d53eec6428caea20d537c490026a4d172cbe48b4ed4daf81a74e9f982341527b91f055426617f0e157431ac15ad2957e07c48a03590c53a0716f3cbc29b707fae54da1d4d5225174f0ffad7138005f617ff8cf1bffb5c68c8979024064bf3003d920f10624bb05853b0f983ae5a7f239582de5d86a3dc3d01a2a66b0c6f2ea0453eab0609f9d077412f02cfbfb12c79c83acd74757a65d7753ece17bdd8355baa8211b88fa7262b375e6b738d9dc5ed4c0b73bca74fef81df3ec178a0cb005c8e15ee5ff54468cb34d17388df83701d4500205a421981327cc255249aa113f07e99e76e204e6f9d080435c90cc33bab7b373a6ead260f55a34dac8cecb76a5d6f46159c15e6122e3d1f9dc409727d324d230b535e0092ad46b322178f58317bbe6246757fb40f1956cbea1fa01dde197322386248fa1e4cd912822f1f15d7335c1c9f1cbe42c7bff84dbdcf5e43a720fd23737a0e8b9b894db7edc5b840760d64c2696d82e00a84b4bff1ad0d7ba4b8a58b5bdf54d777b3fa7e8f95d1407f6b48c2f746f5e7df9f71d74733618a9618a6e6e1d739ce82ccb23c9ca3976b6592ea260d8bc1a7f968ca40541a3592583438c92af325680aab07f050b2beb32bc32aa1712b0ac756455c6af2805ea6c76456d2dffcf6ac26170415c1475cb13567d066c45b36105511f3efaa310cf9822e8f4222acff2fa467c45edd72eee362f74305802cf24257832c866dc43eda83175a7246c78a75474c3ef252bd516d4a21701c9914f5840ba846734aaf7776c4dc7bcde2309d23b5711d10ef9ab2b7ff5791820591c1c5ccf842ca0be25b828c27af437d382650283eefe707300d4757b05874159b584e495c394307ee87eb2b63602877c66cabfc905a38c4881581d817cc8c04d75f2d08a6eb3f134f3778c13d89e8a2e8a007ba10036a19f70e83ebf3d24d6a1dcda62ea43677c97ba3ca962ef8d7df1754c84b115cbbda87b0312fc9736aedd41bc0b7eae8abbb74de3868cf6318c0d36ac7848e0b77493299783f87977ea8c4ce7c6a4e5e49e328fce6602336b59b81bb4e9847a80ef834fe0a6a5daef0a8ca9402b912e3586ca911545177f342c03d904265b2307983cbcc482d4f76af8bc08cde85ac3a1588ec4a31786a0e3c917a10fd0c885da1731db1b08f6f415474bdb967d7becf1341cf51aed7f7e6cbfafd1d484972508d75f2e84513041bbb10dc872f4faf571085548f75990dfe261e7ce0d0e399160e255ccb5cceab7a4a34650211f7d0f40bb15b42553a0886d00a85806ead3eae707df4731869b41ec2d91849bb4d75b89dcc59fa39f09545d1bd274fa64a597a56272ec88d3e4cc3a43df7a74bd4e0caee41e67068ce46d3ad475b8f6a0dcfd38041d7bea21ad3cdf06d7358904c7268b84cd0ca22a99fccf13723d51eac2fb7d99744e6042d7d289e1126fc7099b4557027dca7c46a48c6fd3c9b0c4875f76a01a212d08a40f384753c945e7bca2b64f839a9abdfc62479a517fbb248ff043b7aae38bdab0a1fd16e8a5ffd18b3c92a2c3edc43d69f452d0522e8927842213601e3a6e9af76652f8f7591ea348d30b842098458fc78015bd6fb317ddad4fb8af660d0721a7e778be5560f15a4fe98b8a87bc9e8cdf8a79a9ffaea72ab14a6baa82047e683b5f11410557aab0da1c116d39098041e114ad6e3accd283df80fe275cb2940321589b062e39c531b547e8c7eb21e93a8890590654ed1c2f964d140d532ca3168d76c511e743d762fd0455c3c8f78e8d74fb99a5079078f92e6edc5084046555dc256ba28e9915c3679cc8afda9a14d12af4ef565b1658c75a43b815904c50d2a3b712f22827c67cb4a5c39afdb073c0b63cbdcd853bc5d8f91819ab456a2bcc4aab4d1c3bfbf3b1cc69764838c805752d17082cf00b332a027049a0a0596a54d8fa68a04e364a1a60b57f0d3659a8cebae9a267b6bc82718e40f779bad9945ee8878f9a5670607e3e6551921bbddc5da6b3e247b62a9a17fed7cbceb62f9c703b788fb7cd0d3c90d06cf4e4627408e4714cface473366baa0b93b612481d6e07126150b09733d2bda23288ef229e682080e444577f8fd48753578e091efd46b163ba782ee4e0882d67154d2cb3c052985b0a3225e06cd90cf0047f76f57e51bb34a53746b59cfc97eb5a50f3a603e5e9c814054e9b12badcf031bfba4cfc4f86e25d7ae7db9c9e4c35d67a23f09e3c8f9b430ce415f381de34e436c57d8b12dbcb800821afecc88ca2105996dfd6c1cc24aaa452e0e5cbac0ce5c6842bc9dc96a6f211b08bd310bcacebb279e4b1d977ff22c6e5ab5e42403abccc328cdccb5885e033fceb62b57d25ba841d6ea0b74df288480dcfde4e6db0cd19f4da52f4f78e4e5e8bd85a3e5cb65990ca919fe2d46f47445afbe154aa0833c3df5745a84994b32e72331172df71e4069758cae461358e1528cc0036cbd90577c7b498b3cb17ab186c98de55c1438697bdc5fbe3a581d63eb5f4a85b1e73610f9a1983454bd9dc8a70d445f9899ef1332aaf73fb81cb1417fe815ff102ede05e9f8585723d9dfa24e9b7c3cbd9f9e0b1cc616de1bb87b5122619e24a4ab787476f05a2e546a976d4349a6b0ae943f8000f7b460db03609c1db758cd9f7438a8add84bdfae5c209da908338b097444c7e007e0cf9a6137f0406c3c23af4e836156499954512ab37757f713672abe61685b6d1f2247c3d7d964ea8e8e73a26c869f377cf07c6a085343a700a2f144318657b89c33fd5e769e780f75cc1a9c9575d51eb92fdd1ef3539f420e75b35dfe9dc989c6a347ca3c31e73ab6c5c240d7bfc1733cb71af4176aebf1571e2e1553814f6f0cb399bea3c4d48e840a61d040df7eb9ce950490e076323c4009849255b6bd017af44cfe3f6f62ffd21955771e1b6b37274963efe0fdfd42b80b10446535651974d9c09b2c08bd2a59d2ba0f80f3f023a58b55eac4315f74ff0b76498cae1d5a72b6f8e74957c45065343c014dc7f997317f9208e2c5a937d384a0e9f409458ee0118d329655b942799fcbdce64393cdcc1a75df733654887e5f92f4bc945e004a1e1fd19f607516959cade47abbf908afe91eb529a5b82036f4b9cdd0b59cf2cd5d3678f047bf2247a61b57150d7f7296547f606e73a78be9f4d2d124b96ae7ae2f09493a88bb8d43cecfc0e3d26cb95f5b5fbe6ccc08b2f7534629b48a28e2fef31b0f48376b7abdcccbb7c4d56e65da97e03772aa1968f7e5d0fe204cfece5c6e66238172fba4ac3a450051af962ab9288014847f32294d91a524d6fa19041269ee5afa36035a74b3dc63f4dcef3d583da8a82cc898106d433fc5ed4ab8d04d0f0935bfdd0c04223b153743f39ff6859d00ec6f193cd1ca78259bb18cbd1ad5a248d6bb34570d42b71b1c88381db2bc106a0f6509ff6a3c26d0048c3f5bffb09b6f01259f94c4a9c24b962411fd2c6ee029383e3b6c5f15b18a8ad004b99946903b642a1c2c37df1ddee47e1df8cb47ff6252cf23f4f001750c1215cd27a31fccb9eb361331909599550c087846b7a5bf0ca7c1d9bd9483fe2fccea8dad782591852b9b195b0d46ce40e08fab96f5b4a483953d3d086450a2d384ce4f01ffeeb9c0a9f106cdf0b450ee28272302cc77dd21efb0464670ed21c9b4cc6d203933a32c39195bc90f1f964df267be61bd65efcf9b38cdaee8e027d0373ff3fe9b05f5d00ba1045e746f6625e9e7093ef0bbee5f42c5c29980a70010266a0e273dcf46e26aa678a5da95b0ad26d9540f46ef138f1afe148a3cda36b76e9bb7841a964996a2b445d3d7f1a8a3a976443c99f32c6f3b9b5db9d2d5c781977df45c953214b63db27efd4a7abfb5209615d9856cfda33afaf4fe90bf0f453c2955a303b2d1c4b4805f13b65be7bbca7e1041935a8b46f985ed30053865bb941b776b78baca1f51b3cf7ad4d185ebaafc47b85539160b1b7253e0dd66be3d57214c348eefabf7401abb68102bae68f36270b8ad0e5e27959615e4b5ec8afee35a3305a4e9c8a2729625e56baa851423e42020d4cf978c9680ff21326dfcad5cc736fd9cfdb389eebd158425f5bebf6cb9651b65a6f1d785ab895dbafb795e6f5ccf6aad705db23ce198670aaae940860924d7a6629275caa378ff1583b4efa74d16b2d6378f22481c0032d545d4b0c7c5bc38636f124d9837ca9d392ce351d15a918648c09252a39cc280259fe60354361339e36716f584bf65b12159a5a8bc66f297bf0abda6bbc8a1e6afc97fb4f2e71c29fe08d270adef8321fe72a86d566d1b9630e93ae7a2acc7c12ec0f9c08057fff4b0b3cb72957cb57239f719a120bb3f5e6b79858ac9aa354e06f995ee264b6e5cd5962bb9829bf1365f14d251b9345402a3c9d49b95bc12f147af6e629ab08824f273f847fae4f16b25d48c4ae38ec373afc7ebdafe4eab384b40fea46afe8fa75e05c92cc84dfde201db953e5539b337204f9a24247435b0f6427d78d08fee9b5b9e3638c7c4f0ffef25ff62cb0d0a503d3a4baa3becb724af8c4d19629512002dd5bd3e8566c3bda2e08884776f061cb0b0426ba9dc6f2d12b7bda5f27a80447f64567e3bdb9d4d6efdaefedbb8f4d91f55d4030fa72591536ee5ea2caed32ee3474dc7d6017e194a93042f30103233c15f2652f5c181a7c93acb84b84ed0db3b9a9ca3a20e450938513b3217d1ff3f89bf254134eeae7a2bc9a28c318ddce0f98d2d37e4440f35f094dcd14157cea58a9658f68754a770b0d439712599641647b4ac770867f73fb499f3089ffd53e649eec66e3ca218f273ae214cebd412e98e616774c19276b7cd9f79e12fe2fd5eb177ee20ba5f072c9984074b7a700489f0974702d8972dce2acdb3673a619902b3c070c392c679a418c3256fb7c1bfe6ce7394b5f70c28c0eb89694ddf512ca91e70616d1d12714618a07eb271c7f08d9e68b4cd1bc75b8b141b8ad1ff09a452d9561e87c06ac09092edab04d657301d00c5273a7907046e537f80d27773df7cfb411d82d0885b894bd3187349cdac79b35387729f1e314999bc8b9ee4089e58dd47ff1cf2fada96a7ad9115c404729cbba6e6310a51c64a0d500c423fdee4178c3d7d4d8146cf1cdff3a1f4eb15b6143946d54f1979298871331d8edcbf10fdd3c7d44ec2a6c5a06a3a16eb1642ace8f4197587bff4315a0dcae54b99f8bf409dd332d455f5380cf1cf781ee87e82a73bfad616b298dc848d2ed2185ea9b7567d65c9f28ad226b526abcf9099631c87e582fd488840e2c2939b799e687768f1b95acd19cc3196f40a89288a754b12667968660531b086dca2f1958c0c71fe767fd6130c177e2f3d86682c146269b7277d4f5077d53b83dad4d991a45d7f24fcdf1ac8f3498deb6aa32bc160a833d79fbfcff8a134a4d98f27beb12c56fe9ac649796ffb843b725418de85f3255e56673170c53c23beb4515eda36e834fc222d37a63d3bb47fc96e90c2e0deed27711ea73af203ed456b08e3258fcccf4d1cfe3e42bfa1439fecb9f8dc56fcd4b111e8e04c6b9024a12415b8626b44ff4c25e10a9e896cc7c1c103c820daa57f5bf81188464956da164088befdf98c15f507ff80eb49bc083124310fd37bdc61f50d6ebb32ac857930496bc7cc5c027d826bd5565ccdf02e8e526ea9efd827736911a5a8b52eb6ebf424c86904ebe8933e22a795e29d12ec4e281a60da79dc87b36a194e0f85b1396478cd262b9e572f897b0f33ef841d53200fac94e46031f299b5f3e8b1ecdb269fa07eab866562d3919fc1e9551a15d09e53560ebdb58da5e155c57c7571052a672fb25bdb6ceec08f2c342cae681a216024c60ba194e0ce013e9e7f5f34e0059e683f80fd11696f71367cc73592a4f29b3d38acc17b1c10e2b49e7e691d4746b73de377d66b19b14c3af1daa9d8f6274d77744c52dabc2dda83fc9f98284c4691ed7b79eed690d99e6843569a0e016c80317ec8b653a2ee374ecd094fd1c9eecfb8ce8c3a94da31b1331ff01702600f09104ce0937b59fcba3e07160cc0e671def9e115abf117267e1f83529ae81fc5b11c760af81e4eb981912f7525d9f141b5c29311513e24584fd81d7016593838c3df5ee8c8943d65e8a0536ad2fe297784367eb7f20246790373a771bd82108d4185fb7f6d339934564f508ab055d386db3a33a829d188190a327ff8a46019efc8d0c8ab95ff0704baaaaf3543945d20dcca3f13ce457a0c01ccd9097eea79a95c55e9e88532620950b12c8c04529ac376e0f8c10f020b475013d0b506c9775204cd922315e0a03d091c2abf404b7a7514016376e66a870b7a6d4dc7df41bf1cf7d92d7bcf6b3205bc60946c1a904e4c44b554d3f668878d03c9430c8230c08275832f99cc481f3475b6d44004d9cda685a45ab24fe09286449208435ebaa63c677d7e1803c1bdd40fcef55c2a331df1226709098c40a224dbe3bf90dc6db3863869b1e4dce29e16d2aa029cccd7e352dff42ade99ed16dc6150664ede51dbbdf125d42b2d26f77a5bd6804ef6c1463a41c5977563c45ea6bea3f6f6752aaca346687499b0e51a14036113f0c2b817152653f04215d3c12ed6e1b131c3b07b70ecc3543d77e26ec9fda25f93cd7a1d0a2b6af81c58eeb6ebc2878f428ed8224322823429aec0cc15af09feb8f90513048a4d6cbe54508016745e910ce2964d27117cc2aeac14d52c88242fcea2a3ba3f88bb635d716d8c454991de063ab171c5567852318ee5466fcf58cf4f2225734eeb26237fad4743ed3959451303d04416937bf86cc9b772706085a90061a8598bdc8d72acc04e0715ee903c5b14f44dff3a8b75fd58fa1a076dcdf20f8803bdf90bb1ae56c2a84d50de364046f756b65aedd04a4575f663c45030939ae3c18613e363c0879b6451cb960d2aeb0e144e80cf7a2fcdfb0015007d92570ec44d14165e8a3dfd89a8c3b7c7669c654f32cd820d8ae25aed1bd54e23f3561e74ae752fae327f4b6e9ab8bd61d4795d5004e9ec52a172c244fa8de31040a666f379be7b9fd5332dbc21f77a175b55a3d1bc913f480c56073b2083f417d58b079397a64e1ce2c0eb2630c989d8b1aaef5a1f9039ab45f28f5da5e0ea41f95229e55886446e4be59e92242235d7ae8093d4f727738d46eb078d8d5154e0ba0e7a9a058993ead40b1e55bc4358563da58b71eeed9d35221983aab03782976e02d52ffc6c6f51bcdd30a562ef3e8cef36c053c72d60db5db35c6e710f0488323352463afb33687c3edbf49ecf6d6d1d3c5939fe9dbe4d44e0e289853371848f02edaecacc190be83c9283cff1365e4030883ec820498aa83c1e36f35e685c8f99f3c85b90f7659dc9c4201e30d64fa288b5699af16fdb6d6aa0a9fa694fdb973a18a8e278a1f679b590838d7dd32aaadd3b2be7712b9098846d4f91b40436a7795c2e0107e3f810572436029072b9a91f3e088c92256b08b998f20c51695b4cb7400ad2626c7fdf49ac2f87d01c56654f285c35c0b181616e1952b41b758848358215143564b3448db139bcdbdd29fb522a4f0ffec2e4947ae52aab2a07dd0c0fe814aaf8bcfd2e7a0eacf7960cfc120f572410568b2b29da99be8baeece7c1062076e7c5c6c8e573b25112cd983125755fdef583e73171d8f5bbe4ab8742a4f0e54bd949e0dede1412c9b77e90276e94a7c1eaa419b1ce09206ff379a2217c366bf3bd36517b504026e5a361af1dfee51be2368299fb18edd263a1cb76dff1c90ec338f59394004ba613860359ef6fce315cc39fb17d47ff85ba7da954411f6ca99ab96b6caf2e8a0cdcd79627c45f692de65dce19d77157f28eb2b1f394e311b2dae8d4572c4bd3cacd21d2bda3b1e04683399f6f743e5d5ab3a2ba48c7e103796dce574b505029391a4f197145ca31272a22f88a9d648dbf3e8942125c002590e7bae9b4d6a75fe551a988db210ed73e01b8a4cb6fe9c0f749de3ae3dc124fc5537dc2bbe5aad2b61c417698a1e92c78bf24016618ee2e1f0a67c8101e8f1de228a33f1db1d1f35b35791f0fd68173971f032a6e80638e29c326cced56932957c92273d50d1e49bc1e346ef8295d897e3721e8ca471b0068361b8cd7687997f28e3b7add448c61ad7d26ecf5caf7dde3df62be9a3f30f1a75755f89deda1f07cfd352298f897c5cf8af2ea1270d0a18112569c702493f1cba7d8325dd8637f07d29aad7e9bcdb6b7d2e920a12fd7a06c1f42bde13fc36b6a74b8d55da8b39a16500ad38012c6d3ac4b447606500ad34b46d8cd9b3e5a6b226335b84d14e434de67286657d697f3f71c3b0ee6c96b1f37423aac465ca913567107c2ae33ff7bd678130c7ef1e0d3bada9c809886a5a704cf9c6a8a2ca381d516c66c696f9a7a9ca5a420091cd153c93ff8d1eeb7b5d2a97e2e61a5dade37d526fa3daca28afb0ab2599c77cee1b7d76b5f1597c4570da8732bba1093e1fa9154e778145f4f3b39fad41292194cbaf7dd7647579e52c67355fc94df157bb47717c4a3693edad092e10b874311bb377540d3f086e5d69aca3ed455240bfdc71b9891a160428dcd04f089bc72fa9c6a2660d308c1734bc82a534868577981c950ed092a9db31a338bc8fce3ef2aa18c16998f834d5aba3c45a7b8b1581f0208aca2e8f8114ac6cf32f77cfc3c058855027c34c55167c233141e3d009fd563b87f86fe43910963fc162cc54238c451df0ffd7605c4859a080f207513225b227234c47f6d070620ba43b72ca2c3da1eb677e9e7048c5c275c9a6141df2d95d0d25fd7940a71555793fc6adb542579f710581a5d87f198953350ce459adc4bab1416996df09c23ee0543e0e5093fe82fbf34825365bc7fd9937f3257fd981405da94ac7b1290ab1c3fc525e48bb25703c69d4f0e24e1318cb8d99b4586afe62f838431cfccb0c39f8e70eed97825d2895fb7d3e15a19c23e8ddbcda7f82e1677924b73ed8ebf48679d1d37107e36aa4dae5407e2cf67a4ec2c55e195f2ce5b7524868f71a2af224c6c5e703d53981c5d3308ea017bb7bd2d0860036e170028b5c28b00dabd0ea727b2b24f516285bfecb447e9e63b177a8cec64c6d5645ef602b6e65a502eef62ed1880c9bac9e416698c7fbe076a9707daebce1035532a963e4cfdc2a776ca6ff62a5a9f545d3676305b11e41b8bef060bc715aa9505db37dd0f7716cc369acaf175abbff128383479584ededdf555d0edafea2d031ff61c4644ba42d8ce52111367f4a50d5b719caf7c0d28c6be3f211f4525faf15b3591aac52c58acc5c5a99365a1191bbe1c21ffe8d13640c92772d95beadc273ce785a285a14320c4a00ade83dc47c9acb49b3d0b620e1f569f45d988a158601bcbba8a828ebae8ae58a4a03fea746232c89800d201f6e7523034c6016543a60665427626877aba5b9d64a8066775a30d1610e78303c55f485c6be149cc54b348e4845e8dc776a0fc98f55c4bd873524073a8c4847c68b72ab6dfcbe41b1db866d2295d2a866028b555ed58662ee95a62548657ad85c2572b3412fa9d85c4e97ab53ad4bf8aa0146fd4f1079cbceac1a1f17e6ee4689bf0f46f2fba633becdaf09317b5d68959d4b7e372f040b355df54eff56b416226137468e92ee220d611558f2ec7efd5b5a7a64f5ed0e77b4e5c95dcb7d88b6f56e16e5fe5a003f80f9753cc7c889557a16835f3684eae3b62ca9481bf09126008ae3f6eee74b4e2cf292a30c4334f6666bca5ed799f3324212cd21a5337c5b84675d9527172d30d71d9af747cbb9cbc8f320b23e23be29629d03160a5cbf859cc40ec637046150d6d0edc118b040346fca1fb5dd613389afe3a23b752f4403ca5b327948812dfa59b2dbdd0cf777cf1d7f56a68a8e996b2cc71eda9f9677be9ed1dc1d43395e4fef8090542a669b7eda244a1a13359741dafc6c1f2b756b87aa7417325533a291ebd8e43f66b4dbe1e3fcaa891e5f01810edf150f85a840e338884a7f20f836d19bdaaa70063fa13b9b7cde06aa9c305ba68c5cf367b9ec695048510148e86d5a4c784425f496e6ffbaf6d3471e2ee2285d26928d3baf07f808d897e350f86813e32fad494194b959ef4d7249048772c5f86f189306098fed98ac72b40bd11a154c767449cae988416f1462d262dc35e7a4cfaf9f9a5c51ab77c2998015779e5f402227b1dc73cb907568964efe8c7e9842a277bcf1a4ef83f96269b790fb87d7821c0f74d2f8db0be8efbb7e4bc2c98fa21510dfdd6caf6ffe437252718ca9a481dcf9da61e2aa733a07fd873c8a1ec29677cfe0b50f9c014663a557e8794f57503aaac2fc9b99eae0c6ed493c47ef107cfc896ed67f6d71b191618f792438ad6ca4e5a9ab7e884fd5ec92da902aec773bb372550d524b9248a57ad5381869dfbd617f9970e4b35ca1f3cd7e12a28600eda11b26ee56ec46aef869d2159320f6b8745476c76610d21acd2d14eee4b864f62ec2ec55d21293aa3907c0d0849e698ff27616c02fbc33d2aabc3de3efc2d24abf0cbfc975f40759931991c0c044f93b535e977a901d541fc0dcf488dd2cd5bd1e724274f7a6d3fb4071185683d4075d7408f43f48640d815242e601cbb64b9833234a124d49dfdf4a799ecfd71b0c31f00b54a8eb27ab2295cf8ec55c035a684e1722da0ee157709a05fdf1d2d0469e2a4706e1c834f33c71d49f0844140055f56ef6c01479dc39826fdf04b5450cd46e43800853ea41d06c114e556d671cfb147c5866806f49205603de0149d5dace176aac523224654caa368da78119b680a09b819ddb59d16e135aeaef1b45ed15ccd3c206af021e8fb7ad58b264011c1360fac7d45078cdde70bf42a48f37164c6fd17cf96d526e572fa73f9cdc2a22e0bfe0cdfa6924d629fbfdc42faf59ed5aa4c65a100de98bd913b5c1039e5106018a307993505a1d90a6d8e63476bf6b145343aaff30131879fa4d510d5c731876c709899a674bbd6a0c940a8b1c41d6e3915f7353d585f464a1ddaea263c91b0c5ea3677b1cfc1dc0bd2c453f76933ca61b41be97d53c1358e0ce1d2267b5b2250bee0297210853fff2d557377d40d8a4261229459eba5f71660bac0c63c68816d400201424f8c47e65b02d6ef0103</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看!
    
    </summary>
    
      <category term="摄影" scheme="https://albert-5.cn/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="人像摄影" scheme="https://albert-5.cn/tags/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/"/>
    
      <category term="LOMO摄影" scheme="https://albert-5.cn/tags/LOMO%E6%91%84%E5%BD%B1/"/>
    
      <category term="红外摄影" scheme="https://albert-5.cn/tags/%E7%BA%A2%E5%A4%96%E6%91%84%E5%BD%B1/"/>
    
      <category term="延时摄影" scheme="https://albert-5.cn/tags/%E5%BB%B6%E6%97%B6%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>toefl &amp; ielts</title>
    <link href="https://albert-5.cn/2019/04/28/toefl-ielts/"/>
    <id>https://albert-5.cn/2019/04/28/toefl-ielts/</id>
    <published>2019-04-28T03:50:51.000Z</published>
    <updated>2019-08-04T09:02:41.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="TOEFL"><a href="#TOEFL" class="headerlink" title="TOEFL"></a>TOEFL</h2><p><strong>托福是美国教育考试中心开发出来的给非英语国家学生的英语水平测试</strong></p><h3 id="1、认可国"><a href="#1、认可国" class="headerlink" title="1、认可国"></a>1、认可国</h3><blockquote><p><strong>北美国家（特别是美国）包括日本对托福成绩的接受度较高；</strong></p><p><strong>英联邦国家（英国、荷兰、加拿大、澳大利亚、新西兰、瑞士等）更接受甚至只接受托福成绩；</strong></p></blockquote><h3 id="2、考试形式"><a href="#2、考试形式" class="headerlink" title="2、考试形式"></a>2、考试形式</h3><p><strong>雅思和托福的考试内容也不相同，虽然都是对“听说读写”四种英语能力的测试，但是雅思更加注重生活应用，词汇量没有托福要求的那么多；而托福更加注重学术方面，对专业性的要求更高一点</strong></p><blockquote><p><strong>托福是纯机考，也就是说不管是听力、阅读还是写作，甚至口语都是对着一台电脑，以“人机”的方式进行考核的</strong>。</p></blockquote><h3 id="3、分数分配"><a href="#3、分数分配" class="headerlink" title="3、分数分配"></a>3、分数分配</h3><p><strong>托福是四项单项各30分，总计120分，最后几项分数加起来为总成绩；考试时间大概在4个小时左右，可能会有加试的情况；</strong></p><p><strong>其中，托福成绩在100分以上是不错的分数</strong></p><blockquote><p><strong>有限期为两年</strong></p></blockquote><h3 id="4、考试费用"><a href="#4、考试费用" class="headerlink" title="4、考试费用"></a>4、考试费用</h3><table><thead><tr><th>项目</th><th>金额</th></tr></thead><tbody><tr><td><strong>托福网考考试费</strong></td><td><strong>1985</strong></td></tr><tr><td><strong>逾期报名附加费</strong></td><td><strong>310</strong></td></tr><tr><td><strong>转考费</strong></td><td><strong>620</strong></td></tr><tr><td><strong>恢复已取消的成绩</strong></td><td><strong>154</strong></td></tr><tr><td><strong>成绩赠送费（每份）</strong></td><td><strong>146</strong></td></tr><tr><td><strong>口语或写作单项复议</strong></td><td><strong>615</strong></td></tr><tr><td><strong>口语和写作双项复议</strong></td><td><strong>1229</strong></td></tr><tr><td><strong>托福复习套餐Prem(不包含考试费)</strong></td><td><strong>1086</strong></td></tr><tr><td><strong>托福复习套餐prep</strong></td><td><strong>395</strong></td></tr><tr><td><strong>折扣报名费</strong></td><td><strong>1716</strong></td></tr><tr><td><strong>考费差额 1</strong></td><td><strong>44</strong></td></tr><tr><td><strong>考费差额 2</strong></td><td><strong>224</strong></td></tr><tr><td><strong>考费差额 3</strong></td><td><strong>1104.5</strong></td></tr><tr><td></td></tr></tbody></table><h2 id="IELTS"><a href="#IELTS" class="headerlink" title="IELTS"></a>IELTS</h2><h3 id="1、认可国-1"><a href="#1、认可国-1" class="headerlink" title="1、认可国"></a>1、认可国</h3><p><strong>雅思是英国大使馆文化教育处来出题的</strong></p><blockquote><p><strong>相对的英国目前大部分高校只认可雅思成绩</strong></p></blockquote><h3 id="2、考试形式-1"><a href="#2、考试形式-1" class="headerlink" title="2、考试形式"></a>2、考试形式</h3><blockquote><p><strong>雅思</strong>则是笔试 +面试的形式，口语环节是面对面直接和考官交流的，分数的弹性相对更大一点。对于喜欢交流的人而言考雅思更能会更加有利。</p></blockquote><h3 id="3、分数分配-1"><a href="#3、分数分配-1" class="headerlink" title="3、分数分配"></a>3、分数分配</h3><p><strong>雅思的四项单项都是九分满分制，最后以四项平均分定为最终分数，一般情况下，雅思在7分以上是不错的成绩</strong></p><blockquote><p>有效期为<strong>两年</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="English" scheme="https://albert-5.cn/categories/English/"/>
    
    
      <category term="toefl" scheme="https://albert-5.cn/tags/toefl/"/>
    
      <category term="ielts" scheme="https://albert-5.cn/tags/ielts/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://albert-5.cn/2019/04/22/hello-world/"/>
    <id>https://albert-5.cn/2019/04/22/hello-world/</id>
    <published>2019-04-22T15:42:22.451Z</published>
    <updated>2019-08-04T09:02:02.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="hexo" scheme="https://albert-5.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://albert-5.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>sort_algorithm</title>
    <link href="https://albert-5.cn/2019/03/28/sort-algorithm/"/>
    <id>https://albert-5.cn/2019/03/28/sort-algorithm/</id>
    <published>2019-03-28T09:47:54.000Z</published>
    <updated>2019-06-14T15:38:00.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h1><p><strong>排序算法是一种能将一串数据按照特定顺序进行排列的一种算法</strong></p><p><strong><font color="#660000">稳定性:</font></strong> <font face="宋体">稳定排序算法会让原本有相等数值的记录维持相对顺序，也就说当有两个相等的数据A，B时，且原本A在B的前面，则在排序后A仍然是在B的前面，这就是稳定性的概念；</font></p><h1 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a><strong>二、冒泡排序</strong></h1><h2 id="1、啥子叫冒泡排序"><a href="#1、啥子叫冒泡排序" class="headerlink" title="1、啥子叫冒泡排序"></a>1、啥子叫冒泡排序</h2><blockquote><p>它是一种较为简单的排序算法，具体过程就是遍历所要排序的数列，每一次比较两个数，如果他们顺序错误则交换顺序，直至所有的数据交换完毕，也就是完成了数列的排序；由于在交换过程中，最小的元素会处于顶端的位置，所以叫做<font color="#32CD32"><strong>冒泡排序</strong></font> 。</p></blockquote><h2 id="2、过程分析"><a href="#2、过程分析" class="headerlink" title="2、过程分析"></a>2、过程分析</h2><blockquote><font color="#008B00" face="黑体">在实现冒泡排序的过程中，每次循环之后，数列中最大的元素移动到了最末端，然后在进行下一次的循环遍历，选出次大的元素，继续循环，直至排完序，则最小的处在顶端的位置</font></blockquote><h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>，len(alist)<span class="number">-1</span>-j): <span class="comment"># 操作下标而不是直接作用于元素上</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 优化情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>):</span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 记录交换的次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(alist)<span class="number">-1</span>-j):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">is</span> <span class="number">0</span>:  <span class="comment"># 如果count为0，则说明没有进行交换</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">    bubble_sort(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="#CD2626">说明：</font></strong> </p><ul><li>最优时间复杂度为<font color="#dd00dd">O(n)</font> &lt;<strong><font size="2">遍历一遍发现全都排好了</font></strong>&gt;</li><li>最坏时间复杂度为<font color="#dd00dd">O(n^2)</font></li><li>稳定</li></ul></blockquote><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a><strong>三、选择排序</strong></h1><h2 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>一组数据相当于分成了两个部分，后一部分是待排数列，初始默认第一个元素是最小值，然后从这些待排的数列中进行遍历找到最小值并记录下标位置，然后与记录的初始最小值比较，如果找到的小于初始值则进行交换，然后继续遍历；也就是说,<font color="#CD2626">整个过程就是在找最小值。</font></strong></p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">'''选择排序'''</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br></pre></td></tr></table></figure><p><strong><font color="#267C19">时间复杂度：O(n^2)</font></strong></p><p><strong><font color="#267C19">稳定性：简单的考虑这种情况，在一个乱序的列表中[11,23,12,23,6],排序时第一个23较大，则在排序时会由于交换而移动到最后面，则在排列第二个23时，因为它不比第一个23大，所以不变化，由此可见，二者交换了顺序，稳定性就是不稳定</font></strong></p><h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a><strong>四、插入排序</strong></h1><h2 id="1、思想-1"><a href="#1、思想-1" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动</strong></p><h2 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">'''插入排序'''</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># j表示循环次数，也即是有多少个元素执行此过程</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        i = j</span><br><span class="line">        <span class="comment"># i是表示从从待排序列中取出第一个，然后进行扫描比较</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[i] &lt; alist[i<span class="number">-1</span>]:</span><br><span class="line">                alist[i], alist[i<span class="number">-1</span>] = alist[i<span class="number">-1</span>], alist[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h2><p><strong><font color="#227BA0">最优时间复杂度: O(n) &lt;数列已按照升序排列，这个时间复杂度仅仅是遍历的时间&gt;</font></strong></p><p><strong><font color="#227BA0">最坏时间复杂度: O(n^2) </font></strong></p><p><strong><font color="#227BA0">稳定性:稳定</font></strong></p><h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a><strong>五、希尔排序</strong></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>它是插入排序的一种，也称为缩小增量排序，是直接插入排序算法的一种更为高效的改进版；但是它是不稳定的。<font color="#6C2397">具体思想</font>就是把数据按照下标的一定增量进行分组，然后对每一个组进行插入排序，随着增量的一步步减少，每一组包含的数据越多，当增量为1时，整个排序完成！</strong></p><h2 id="2、实现-2"><a href="#2、实现-2" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    gap = n // <span class="number">2</span>  <span class="comment"># 确定步长</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(gap,n):</span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i-gap]:</span><br><span class="line">                    alist[i],alist[i-gap] = alist[i-gap],alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong><font color="#6C2397">最优时间复杂度: 无法确定</font></strong></p><p><strong><font color="#6C2397">最坏时间复杂度: O(n) </font></strong></p><p><strong><font color="#6C2397">稳定性: 不稳定</font></strong></p><h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a><strong>六、快速排序</strong></h1><h2 id="1、思想-2"><a href="#1、思想-2" class="headerlink" title="1、思想"></a>1、思想</h2><hr><ul><li><strong>先从给定数列中取出一个基准数据值，记为x</strong></li><li><strong>排序过程中，小于x的数据全放在左边，大于x的数据全放在其右边</strong></li><li><strong>然后再次重复上述步骤即可</strong></li></ul><h2 id="2、实现-3"><a href="#2、实现-3" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(alist,first,last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &gt;= last:</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    mid_value = alist[<span class="number">0</span>]</span><br><span class="line">    low = first</span><br><span class="line">    high = last</span><br><span class="line">    <span class="keyword">while</span>  low &lt; high:</span><br><span class="line">        <span class="comment"># high左移</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line">        <span class="comment"># low右移，在判断里面进行移动low的值以防它移动过度</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid_value:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line">    alist[low] = mid_value</span><br><span class="line">    <span class="comment"># 此时low的位置就是初始的那个值</span></span><br><span class="line">    <span class="comment"># 递归使用函数本身，快排左边</span></span><br><span class="line">    quick_sort(alist,first,low<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 递归快排右边</span></span><br><span class="line">    quick_sort(aliist,low+<span class="number">1</span>,last)</span><br></pre></td></tr></table></figure><ul><li><strong><font color="9E33FF">最优时间复杂度： O(n*logn)</font></strong></li><li><strong><font color="9E33FF">最坏时间复杂度： O(n^2) </font>  # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项</strong></li><li><strong><font color="9E33FF">稳定性：不稳定</font></strong></li></ul><h1 id="七、归并算法"><a href="#七、归并算法" class="headerlink" title="七、归并算法"></a><strong>七、归并算法</strong></h1><h2 id="1、思想-3"><a href="#1、思想-3" class="headerlink" title="1、思想"></a>1、思想</h2><hr><p><strong>&nbsp;&nbsp;分而治之，就是将一组待排序列向下均分、均分、均分······直至每一个小分组中只有一个元素，然后向上走进行合并操作，以致达到排序的目的</strong></p><h2 id="2、实现-4"><a href="#2、实现-4" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">'''归并排序'''</span></span><br><span class="line">    <span class="comment"># 分而治之，先进行分的操作</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = n/<span class="number">2</span></span><br><span class="line">    <span class="comment"># 分的结果为两个新的列表left 和 right;以下是递归操作</span></span><br><span class="line">    left = merge_sort(alist[:mid])</span><br><span class="line">    right = merge_sort(alist[mid+<span class="number">1</span>:])</span><br><span class="line">    left_pointer, right_pointer = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left[left_pointer] &lt; len(left) <span class="keyword">and</span> right[right_pointer] &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[left_pointer] &lt;= right[right_pointer]:</span><br><span class="line">            result.append(left[left_pointe])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line">    result += left[left_pointer:]</span><br><span class="line">    result += right[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment">#-----------------------------------------------------------</span></span><br></pre></td></tr></table></figure><p><strong><font color="8E33FE"> 最优时间复杂度：O(n*logn) </font></strong></p><p><strong><font color="9E33FF">最坏时间复杂度：O(n*logn) </font>  # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项</strong></p><p><strong><font color="9E33FF">稳定性：稳定</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://albert-5.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="https://albert-5.cn/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://albert-5.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://albert-5.cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://albert-5.cn/2019/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://albert-5.cn/2019/03/25/栈和队列/</id>
    <published>2019-03-25T09:54:05.000Z</published>
    <updated>2019-04-29T09:56:46.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一、python递归函数深度限制"><a href="#一、python递归函数深度限制" class="headerlink" title="一、python递归函数深度限制"></a>一、python递归函数深度限制</h4><p>python使用递归函数会受到递归深度的限制，大概是900多点(因为100次的时候就会报错：maximum recursion depth exceeded in comparison)，嘿嘿嘿</p><p>解决方法</p><blockquote><p><strong>导入python中 sys模块，import sys</strong></p><p><strong>然后使用 sys 下的 setrecursionlimit去重新规定它的限制</strong></p></blockquote><p><strong>**ps:但是要注意一点设置Python解释器堆栈的最大深度以限制。此限制可防止无限递归导致C堆栈溢出并导致Python崩溃。</strong></p><p><strong>最高可能的限制取决于平台。当用户需要深度递归的程序和支持更高限制的平台时，用户可能需要设置更高的限制。这应该小心，因为太高的限制可能导致崩溃</strong></p><h4 id="二、栈stack"><a href="#二、栈stack" class="headerlink" title="二、栈stack"></a><strong>二、栈st</strong>ack</h4><h5 id="1、栈的操作"><a href="#1、栈的操作" class="headerlink" title="1、栈的操作"></a>1、栈的操作</h5><p>**·  stack()创建一个空栈</p><p>·  push()添加一个新的元素item到栈顶</p><p>·  pop()弹出栈顶元素</p><p>·  peek()返回栈顶元素</p><p>·  is_empty()判断栈是否为空</p><p>·  size()返回栈的元素个数**</p><h5 id="2、栈的代码实现"><a href="#2、栈的代码实现" class="headerlink" title="2、栈的代码实现"></a>2、栈的代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''栈'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list = []  <span class="comment"># 建立私有容器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">''</span>添加一个新的元素到栈顶<span class="string">''</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line">        <span class="comment"># self.__list.insert(0,item) 在栈顶插入时复杂度为n,相反在尾部时复杂度就为1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''弹出栈顶元素'''</span></span><br><span class="line">        self.__list.pop()</span><br><span class="line">        <span class="comment"># self.__list.pop(0)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">'''返回栈顶元素'''</span></span><br><span class="line">        <span class="keyword">if</span> self.__list:</span><br><span class="line">        <span class="keyword">return</span> self.__list[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断栈是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__list</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''返回栈中元素的个数'''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Stack()</span><br></pre></td></tr></table></figure><h4 id="三、队列queue"><a href="#三、队列queue" class="headerlink" title="三、队列queue"></a>三、队列queue</h4><h5 id="1、只允许在一端进行插入操作，另一端进行删除操作的线性表"><a href="#1、只允许在一端进行插入操作，另一端进行删除操作的线性表" class="headerlink" title="1、只允许在一端进行插入操作，另一端进行删除操作的线性表"></a>1、只允许在一端进行插入操作，另一端进行删除操作的线性表</h5><h5 id="2、队列的实现"><a href="#2、队列的实现" class="headerlink" title="2、队列的实现"></a>2、队列的实现</h5><p>·  queue()创建一个空的队列</p><p>·  enqueue(item)添加一个新的元素item到队列中</p><p>·  dequeue()从队头删除一个元素</p><p>·  is_empty()判断队列是否为空</p><p>·  size()返回队列中的元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''队列'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>：</span></span><br><span class="line">    self.__list = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''往队列中添加一个item元素'''</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line">        <span class="comment"># self.__list.insert(0,item)</span></span><br><span class="line">        <span class="comment"># 无论选择哪个总有一个的复杂度是O(1)，另一个是O(n)，具体选择根据自己功能哪个用的多</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''从队列中删除一个元素'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断一个队列是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''返回队列的大小'''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __init__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Queue()</span><br><span class="line">    s.enqueue(<span class="number">1</span>)</span><br><span class="line">    s.enqueue(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="四、双端队列"><a href="#四、双端队列" class="headerlink" title="四、双端队列"></a>四、双端队列</h4><p>**·  deque创建一个空的双端队列</p><p>·  add_front(item)从队头加入一个item元素</p><p>·  add_rear(item)从队尾加入一个item元素</p><p>·  remove_front()从队头删除一个item元素</p><p>·  remove_rear()从队尾删除一个item元素</p><p>·  is_empty()判断双端队列是否为空</p><p>·  size()返回双端队列的大小**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''双端队列'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>：</span></span><br><span class="line">    self.__list = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_front</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''往双端队列的头部添加一个item元素'''</span></span><br><span class="line">        self.__list.insert(<span class="number">0</span>,item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''从双端队列的头部删除一个元素'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''从双端队列的尾部取出元素'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断一个双端队列是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''返回双端队列的大小'''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br></pre></td></tr></table></figure><h4 id="五、链表"><a href="#五、链表" class="headerlink" title="五、链表"></a>五、链表</h4><h5 id="1、单向链表"><a href="#1、单向链表" class="headerlink" title="1、单向链表"></a>1、单向链表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">     <span class="comment"># 同样可以利用python的二元组进行操作(elem)</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Single_LinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''单链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,node=None)</span>:</span>  <span class="comment"># 就是一个内部的使用，规定一个头结点，而且这个头结点应该是私有的，因为在封装后的SingleLinkList对象中，外部能够调用的就是以下的几个函数，其他的是无法使用的，所以私有化处理了，纯粹是自己的内部函数去使用；</span></span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__head = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表长度'''</span></span><br><span class="line">        <span class="comment"># cur游标，用来移动遍历节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># count 记录数量</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表遍历'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''链表头部添加元素,头插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.__head.next</span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,item)</span>:</span>  <span class="comment"># 这里的item仅仅是数据元素，而不是节点</span></span><br><span class="line">        <span class="string">'''链表尾部添加元素，尾插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty(): <span class="comment"># 判断链表是否为空</span></span><br><span class="line">            self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,pos,item)</span>:</span>  <span class="comment"># 在任意位置添加元素，pos表示需要添加元素的位置，item表示要添加的数据</span></span><br><span class="line">        <span class="string">'''在某个位置插入元素'''</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self.__head <span class="comment"># pre的用法和cur一样</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos<span class="number">-1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                pre = pre.next</span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = pre.next</span><br><span class="line">            pre.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''删除节点'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != item:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 要判断此节点是不是头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    self.__head = cur.next</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点是否存在'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>链表和顺序表的比较</strong></p><table><thead><tr><th>操作</th><th>链表</th><th>顺序表</th></tr></thead><tbody><tr><td><strong>访问元素</strong></td><td>O(1)</td><td>O(1)</td></tr><tr><td><strong>头部插入 or 删除元素</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>尾部插入 or 删除元素</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>在中间插入 or 删除元素</strong></td><td>O(n)</td><td>O(n)</td></tr></tbody></table><h4 id="六、双向链表"><a href="#六、双向链表" class="headerlink" title="六、双向链表"></a><strong>六、双向链表</strong></h4><h5 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h5><p>**·  is_empty()链表是否为空</p><p>·  length()链表长度</p><p>·  travel()遍历整个链表</p><p>·  add(item)链表头部添加信息</p><p>·  append(item)链表尾部添加信息</p><p>· insert(pos, item)在特定位置添加元素</p><p>·  remove(item)删除节点</p><p>· search(item)查找节点是否存在**</p><h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''双链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,node=None)</span>:</span></span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断双链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''双链表长度'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">         <span class="keyword">return</span> count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''遍历双链表'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">       <span class="string">'''头部添加元素'''</span></span><br><span class="line">       node = Node(item)</span><br><span class="line">       node.next = self.__head.next</span><br><span class="line">       self.__head = node</span><br><span class="line">       node.next.prev = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,item)</span>:</span></span><br><span class="line">       <span class="string">'''双链表的尾部添加元素'''</span></span><br><span class="line">       node = Node(item)</span><br><span class="line">       <span class="keyword">if</span> self.is_empty():</span><br><span class="line">           self.__head = node</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cur = self.__head</span><br><span class="line">           <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">               cur = cur.next</span><br><span class="line">           cur.next = node</span><br><span class="line">           node.prev = cur</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,pos,item)</span>:</span></span><br><span class="line">        <span class="string">'''在双向链表的某个位置插入元素'''</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 退出循环之后，cur指向pos位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur</span><br><span class="line">            node.prev = cur.prev</span><br><span class="line">            cur.prev = node</span><br><span class="line">            cur.prev.next = node</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''删除节点'''</span></span><br><span class="line">        <span class="comment"># cur 游标指向头结点的时候，pre指向空，相差一个单位的距离</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem <span class="keyword">is</span> item:</span><br><span class="line">                <span class="comment"># 判断当前游标cur指向是不是在1处</span></span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">is</span> self.__head:</span><br><span class="line">                    self.__head = cur.next</span><br><span class="line">                    <span class="comment"># 判断cur.next是否为空，因为空的元素是没有prev的</span></span><br><span class="line">                    <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.next.prev = <span class="literal">None</span></span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">serch</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        whilt cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem <span class="keyword">is</span> item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="python" scheme="https://albert-5.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/python/"/>
    
    
      <category term="python" scheme="https://albert-5.cn/tags/python/"/>
    
      <category term="数据结构" scheme="https://albert-5.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="https://albert-5.cn/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://albert-5.cn/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="链表" scheme="https://albert-5.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
