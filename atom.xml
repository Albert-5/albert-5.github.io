<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://albert-5.github.io/"/>
  <updated>2019-05-16T08:31:51.397Z</updated>
  <id>https://albert-5.github.io/</id>
  
  <author>
    <name>albert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode</title>
    <link href="https://albert-5.github.io/2019/05/16/Leetcode/"/>
    <id>https://albert-5.github.io/2019/05/16/Leetcode/</id>
    <published>2019-05-16T08:29:30.000Z</published>
    <updated>2019-05-16T08:31:51.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><font color="indigo" font-size="5">领扣–引领新时尚</font></strong></p><h4 id="1、两数之和问题"><a href="#1、两数之和问题" class="headerlink" title="1、两数之和问题"></a>1、两数之和问题</h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>解法1–暴力解法</p><p>思路：</p><blockquote><p>给定一个数组和一个特定的目标值，对每一个数进行遍历，然后利用两层循环遍历的值进行if条件判断，如果相等，则返回下标；否则返回None.</p></blockquote><p>具体实现：</p><blockquote><p>class Solution:<br>def twoSum(self, nums,target):<br>       for i in range(len(nums)):<br>           for j in range(i+1, len(nums)):<br>               if nums[i]+nums[j] == target:<br>                   return [i, j]<br>               else:<br>                   continue</p><p>nums = [2,7,11,15]<br>target = 9<br>solution = Solution()<br>print(solution.twoSum(nums,target))</p></blockquote><p>缺点：过于暴力，两层循环使得时间代价过高。</p><p>时间复杂度：O(n^2^)</p><p>解法2–较优化算法</p><p>思路：</p><blockquote><p>相比于暴力解法，此法优化了双层循环</p><p>一次循环遍历，然后用目标值减去数组中的每一个值，然后判断减去得到的值是否在数组中，进而再判断小标问题；</p></blockquote><p>具体实现：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">&gt;    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)):</span><br><span class="line">&gt;        a = target - nums[i]</span><br><span class="line">&gt;        <span class="keyword">if</span> a <span class="keyword">in</span> nums:</span><br><span class="line">&gt;            b = nums.index(a)</span><br><span class="line">&gt;            <span class="keyword">if</span> b != i:</span><br><span class="line">&gt;                <span class="keyword">return</span> [i, b]</span><br><span class="line">&gt; </span><br><span class="line">&gt; nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">&gt; target = <span class="number">9</span></span><br><span class="line">&gt; solution = Solution()</span><br><span class="line">&gt; print(solution.twoSum(nums, target))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>解法3–优化算法 &lt;来源于网络，怪自己 :sweat:···&gt;</p><p>思路：</p><blockquote><p>优解:创建一个字典，通过循环把 target - nums[x]作为键，x作为值存入字典，边存边检查当前正在处理的nums[x]是否存在于字典中，存在：返回字典中nums[x]的值，和当前正在使用的x的值。</p></blockquote><p>具体实现：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">&gt;    dic = &#123;&#125;</span><br><span class="line">&gt;    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">&gt;         <span class="keyword">if</span> target - nums[x] <span class="keyword">in</span> dic:</span><br><span class="line">&gt;            result = [dic[target - nums[x]], x]</span><br><span class="line">&gt;            <span class="keyword">return</span> result</span><br><span class="line">&gt;         dic[nums[x]] = x</span><br><span class="line">&gt;        </span><br><span class="line">&gt; nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">&gt; target = <span class="number">9</span></span><br><span class="line">&gt; solution = Solution()</span><br><span class="line">&gt; print(solution.twoSum(nums, target))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="2、回文数问题"><a href="#2、回文数问题" class="headerlink" title="2、回文数问题"></a>2、回文数问题</h4><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>解法1–较优化解法</p><p>思路：</p><blockquote><p>将所给数字转化为<strong>字符串</strong>，因为回文数是具有对称性的，所以比较字符串的第一位和最后一位、第一次位和末尾次位 ······<font color="indigo">但是由于一位数以及负数和末尾为0的数的特殊性，应该加以判断。</font></p><p>由于对称性，所以考虑字符长度，奇偶数：通过模2判断只需要判断一般就可以了。</p></blockquote><p>实现：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">&gt;         n = str(x)</span><br><span class="line">&gt;         print(n)</span><br><span class="line">&gt;         m = len(n)</span><br><span class="line">&gt;         count = <span class="number">0</span></span><br><span class="line">&gt;         <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt;         <span class="keyword">elif</span> n[<span class="number">0</span>] == <span class="string">"-"</span> <span class="keyword">or</span> n[m<span class="number">-1</span>] == <span class="string">'0'</span>:</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">&gt;         <span class="keyword">elif</span> m % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">&gt;             <span class="keyword">for</span> i <span class="keyword">in</span> range(int(m/<span class="number">2</span>)):</span><br><span class="line">&gt;                 <span class="keyword">if</span> n[i] == n[m<span class="number">-1</span>-i]:</span><br><span class="line">&gt;                     count += <span class="number">1</span></span><br><span class="line">&gt;                 <span class="keyword">else</span>:</span><br><span class="line">&gt;                     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">&gt;         <span class="keyword">else</span>:</span><br><span class="line">&gt;             <span class="keyword">for</span> i <span class="keyword">in</span> range(int((m+<span class="number">1</span>)/<span class="number">2</span>)):</span><br><span class="line">&gt;                 <span class="keyword">if</span> n[i] == n[m<span class="number">-1</span>-i]:</span><br><span class="line">&gt;                     count += <span class="number">1</span></span><br><span class="line">&gt;                 <span class="keyword">else</span>:</span><br><span class="line">&gt;                     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">&gt;         <span class="keyword">if</span> count == int(m/<span class="number">2</span>) <span class="keyword">or</span> count == int((m+<span class="number">1</span>)/<span class="number">2</span>):</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; X = <span class="number">0</span></span><br><span class="line">&gt; solution = Solution()</span><br><span class="line">&gt; print(solution.isPalindrome(X))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>时间复杂度为 O(n)</p><p>执行代码，运行时间108 ms</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://albert-5.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://albert-5.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="两数之和" scheme="https://albert-5.github.io/tags/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
      <category term="回文数" scheme="https://albert-5.github.io/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>sublime配置有关问题</title>
    <link href="https://albert-5.github.io/2019/05/06/sublime%E9%85%8D%E7%BD%AE%E6%9C%89%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://albert-5.github.io/2019/05/06/sublime配置有关问题/</id>
    <published>2019-05-06T07:42:54.000Z</published>
    <updated>2019-05-06T07:46:34.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Answer-amp-amp-Question"><a href="#Answer-amp-amp-Question" class="headerlink" title="Answer &amp;&amp; Question"></a>Answer &amp;&amp; Question</h2><h3 id="安装Package-Control"><a href="#安装Package-Control" class="headerlink" title="安装Package Control"></a>安装Package Control</h3><p><strong>安装Package Control有两种方式，第一种方式为：在控制台中输入安装命令。调出控制的方式为：Ctrl+`。Sublime Text2和Sublime Text 3的命令如下：</strong></p><p><strong>sublime text 2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2,os,hashlib; h = <span class="string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ipp) <span class="keyword">else</span> <span class="literal">None</span>; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by) <span class="keyword">if</span> dh == h <span class="keyword">else</span> <span class="literal">None</span>; print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h) <span class="keyword">if</span> dh != h <span class="keyword">else</span> <span class="string">'Please restart Sublime Text to finish installation'</span>)</span><br></pre></td></tr></table></figure><p><strong>sublime text 3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure><p><strong>这一种方法我试了，好像没有卵用，打开console时会出现错误—由于连接方在一段时间后没有正确答复或者连接的主机没有反应，连接尝试失败</strong></p><p>So, 失败告终，唯能另寻别发</p><hr><hr><p><strong>后来在网上找了大量文章，看了好多解决方法，但大多无用，因为那个官网是无法访问的，好像是因为ip6什么的问题，但是除了······*<a href="需要的可以联系我981287080@qq.com">^注释1</a>这样可以下载得到package control压缩包</strong></p><p><strong>万事大吉？？？想的可真多啊 ^-^</strong></p><hr><hr><p>下载之后在指定的preferences/browser packages进行拖放下载好且解压好的文件，之后看是否出现<strong>package setting</strong>，如果出现，<strong>Ctrl+shift+P</strong>，输入<strong>install package</strong>，你就会看到这个包</p><p><strong>也就说明 You are ok</strong></p><p>但是<strong>不可避免出现 there are no packagesa avaliable for installation</strong>的错误。</p><p>怎么办？？？？</p><p>可愁死我了·······</p><p>找了资料发现是这个原因 <strong>在利用sublime进行插件下载时，sublime会调用channel_v3.json文件，点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default，可以看到该文件是放置在网络中进行读取的，而由于GFW的原因，导致无法读取该文件（但是竟然可以直接访问？？），这也就是导致插件无法下载的原因</strong></p><p>所以只需要修改这个<strong>json</strong>文件即可</p><p>方法也有很多，这是我在<a href="https://www.zhihu.com" target="_blank" rel="noopener">知乎</a>上看到的<a href="https://www.zhihu.com/question/26373122/answer/156739767" target="_blank" rel="noopener">https://www.zhihu.com/question/26373122/answer/156739767</a></p><p><strong>但是我没有成功，嘤嘤嘤</strong>，主要是因为json文件没法下载</p><p>后来找到了,<a href="https://raw.githubusercontent.com/Albert-5/Stark-Lab/master/channel_v3.json" target="_blank" rel="noopener">给你</a></p><p>添加到本地文件夹，然后在<strong>点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default</strong>看到一个<strong>channels</strong>，后面的路径修改下就可以了</p><p>别慌！！</p><p>记得试一下哦，老方法，</p><p><strong>Ctrl+shift+P</strong>，输入<strong>install package</strong>，你就可以开始玩耍啦~~</p><p>学习之中遇到的问题就记录下来了，小白上路，若有问题可联系me<a href="Email:981287080@qq.com" target="_blank" rel="noopener">^contact me</a>,欢迎指正。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="sublime" scheme="https://albert-5.github.io/categories/sublime/"/>
    
    
      <category term="sublime" scheme="https://albert-5.github.io/tags/sublime/"/>
    
      <category term="python" scheme="https://albert-5.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>摄影理论篇</title>
    <link href="https://albert-5.github.io/2019/05/03/%E6%91%84%E5%BD%B1/"/>
    <id>https://albert-5.github.io/2019/05/03/摄影/</id>
    <published>2019-05-03T03:00:03.000Z</published>
    <updated>2019-05-03T03:02:19.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h4 id="一、人像摄影"><a href="#一、人像摄影" class="headerlink" title="一、人像摄影"></a>一、人像摄影</h4><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><p>所谓人像摄影，是指通过摄影的形式，在照 片上用鲜明突出的形象描绘和表现被摄者相 貌和神态的作品，它是被摄者的影像写真。</p><p>• 一幅优秀的人像摄影作品，是许多成功因 素的总和：神情、姿态、构图、照明、曝 光、制作均要达到较高的境界，它们是一 个总体的各组成部分。 </p><p>• 不管是在现场中抓拍的还是在照相室里摆 拍的，不管是否带有情节，只要是以表现 被摄者具体的外貌和精神状态为主的照片， 都属于人像摄影的范畴。</p><p>• 人像摄影的景别，主要有以下几种： </p><blockquote><p>（1）特写 以表现被摄者的面部特征为 主要目的 </p><p>（2）近景 它以表现人物的面部相貌为主 背景环境在画面中只占极少部分 </p><p>（3）半身 以脸部面貌为主要表现对象以外 还常常包括手的动作。 </p><p>（4）全身 使人物的形象与背景环境的特点 互相结合，都能得到适当的表现</p></blockquote><p>• 拍摄方向大体上分作: </p><blockquote><p>• 正面人像 </p><p>• 七分面人像 </p><p>• 三分面人像 </p><p>• 侧面人像</p></blockquote><p>• 调子影响视觉和情感。人像摄影可以分作高调、低调、一股影调、软调、硬调五种 影调。</p><blockquote><p>高调：画面的影调构成以亮调子为主，尽量避免或者少用暗调子。</p><p>人像照片的背景要明亮、干净、均匀，但最好又保留一点淡淡的层次，以便衬托出被摄者更亮的部位。</p></blockquote><p>• 夜景人像</p><p>1）直接使用相机的夜景人像模式<br>2）使用AV档，曝光组合主要以夜景的背景 为参考，第二张开启闪光灯，照亮人像， 难点在于前后用光均衡。</p><h5 id="2、技巧"><a href="#2、技巧" class="headerlink" title="2、技巧"></a>2、技巧</h5><p>人像焦段的选择</p><p>• 1)镜头焦段选择：28-180 毫米皆可以，但是 50-135毫米最常用。尤其推荐85mm定焦镜 头。<br>• 2）光圈控制，适度虚化背景，突出人物主 体。F2.0-F5.6常用</p><blockquote><p>拍摄人像小诀窍 </p><p>• 1）相机的测光模式为点测，点测人像的脸 部，曝光增加0.5-1档，使得皮肤美白； </p><p>• 2）相机有人像和美肌美肤模式请设置 </p><p>• 3）化妆，服装，饰物非常重要； </p><p>• 4）反光板或者外置闪光灯补光要常用，减 弱脸部阴暗，另外使得眼睛有眼神光；</p><p>• 5）多和模特交流，减少她的紧张； </p><p>• 6）尝试多种拍摄视角和运光方式，身体可 以尝试多种POSE；</p><p>• 7）事先应该确定风格。</p></blockquote><h4 id="二、新闻摄影"><a href="#二、新闻摄影" class="headerlink" title="二、新闻摄影"></a>二、新闻摄影</h4><h5 id="1、要求"><a href="#1、要求" class="headerlink" title="1、要求"></a>1、要求</h5><p> 1新闻摄影 : “新” :首先是个新字。应该是 新鲜事、新闻，别人不知道的、没见过的。<br> 2纪实:反映真实的现场，让未能身临其境者 如同亲历。<br> 3具备这两点后，新闻还要有社会价值。</p><h5 id="2、新闻摄影5W"><a href="#2、新闻摄影5W" class="headerlink" title="2、新闻摄影5W"></a>2、新闻摄影5W</h5><blockquote><p> 何时（when）； </p><p> 何地(where)；</p><p> 何人(who)； </p><p> 何事(what)； </p><p> 为何(why)。</p></blockquote><p><strong>瞬间成为永恒，成为历史的见证</strong></p><p><strong>不要细细追求技术完美，抓住瞬间才是关键</strong></p><h5 id="3、会场类相片"><a href="#3、会场类相片" class="headerlink" title="3、会场类相片"></a>3、会场类相片</h5><blockquote><p>相机参数： 1.档位选择：首先考虑使用A档 若光线较差，使用A档则会出现曝光时间过长，照片模 糊，此时考虑换成M档，将快门速度设置在1/15至1/60 之间</p><p>2.光圈：合理，F2.8-F5.6拍摄人物，F8拍摄全</p><p>3.ISO感光度：灯光较亮—100-800 灯光一般—800-1600 灯光较暗—1600以上 </p><p>4.白平衡：自动白平衡 日光灯 荧光灯</p><p><strong>拍摄曝光和器材要求</strong></p><p>会议拍摄曝光和器材要点：<br>1）大功率外置闪光灯必备，最 好套好小型柔光罩；<br>2）镜头折合后焦距24-105mm；<br>3）充分利用会场内的现场光；<br>4）ISO设置到 800-1600；<br>5）控制光圈，使得闪光灯和现 场光平衡。</p><p>1.正面全景 </p><p>2.近景特写 </p><p>3.角落全景</p><p>4.台上全景 </p><p>5.颁奖合</p></blockquote><h4 id="三、建筑、红外、LOMO、针孔摄影、延时摄影、超现实摄影"><a href="#三、建筑、红外、LOMO、针孔摄影、延时摄影、超现实摄影" class="headerlink" title="三、建筑、红外、LOMO、针孔摄影、延时摄影、超现实摄影"></a>三、建筑、红外、LOMO、针孔摄影、延时摄影、超现实摄影</h4><h5 id="1、建筑摄影"><a href="#1、建筑摄影" class="headerlink" title="1、建筑摄影"></a>1、建筑摄影</h5><h6 id="1、要点"><a href="#1、要点" class="headerlink" title="1、要点"></a>1、要点</h6><p>• 建筑的形体（体现建筑空间的深度，感受到三维空间的真实世界，其表现在<strong>运用视觉透视和利用阴影来提高建筑的空间感</strong>）、轮廓（<strong>当建筑处在背光面时，光线从建筑的背面射来，在强光的烘托下，轮廓剪影成了建筑的主要视觉要素，而空间、质感、色彩等等其它要素统统都被隐没在阴影之中。</strong>）、线条、尺度比例、质感和色 彩是建筑摄影中视觉要素的主要成分。<br>• 在大多数情况下，上述要素并不是以相同 的地位在画面上同时出现，特别是当摄影 师需要突出表现建筑的某一特征时更是如 此。在画面中需要重点突出那些视觉要素 取决于照片的用途，也取决于摄影师的创 作意图和创作风格。</p><p>• 点 线 面 立体空间是建筑摄影最主要观察的</p><h6 id="2、失真方法"><a href="#2、失真方法" class="headerlink" title="2、失真方法"></a>2、失真方法</h6><p>普通135相机和镜头，站在地面拍摄，产生透视失真，图像有 汇聚效应，头小脚大。<strong>但是</strong>，大画幅或者技术相机通过，前镜头板的上升，完美解决该问题。</p><h6 id="3、控制建筑透视失真方法"><a href="#3、控制建筑透视失真方法" class="headerlink" title="3、控制建筑透视失真方法"></a>3、控制建筑透视失真方法</h6><blockquote><p>• 35mm相机及其透视调整镜头 </p><p>• 目前尼康、佳能、徕卡、美能达等相机厂 均生产透视调整镜头，如佳能相机的TS-E 24mm、45mm和90mm透视调整镜头，徕卡 R系列相机的28mm透视调整镜头，美能达 相机的35mm透视调整镜头，尼康相机的 28mm、35mm 和 85mm透视调整镜头。</p></blockquote><p><strong>建筑摄影顾名思 义，其主要记录 和表现对象为各 种建筑以及由于 建筑物的存在而 产生的空间关系 和状态。</strong></p><h6 id="4、透视"><a href="#4、透视" class="headerlink" title="4、透视"></a>4、透视</h6><p>最初研究透视是 采取通过一块透明的平面去看景物的方法 ，将所见景物准确描画在这块平面上，即 成该景物的透视图。后遂将在平面画幅上 根据一定原理，用线条来显示物体的空间 位置、轮廓和投影的科学称为透视学</p><p>使用<strong>中等焦距镜头</strong>在一定距离上拍摄建筑标志性雕塑可以避免近距离拍摄是因透视加剧而 产生的比例失真，这时建筑、雕塑、人的比例关系更为客观</p><h6 id="5、建筑摄影的6个使用拍摄建议"><a href="#5、建筑摄影的6个使用拍摄建议" class="headerlink" title="5、建筑摄影的6个使用拍摄建议"></a>5、建筑摄影的6个使用拍摄建议</h6><blockquote><p>1、利用反射或倒影增加美</p><p>2、利用好几何线条</p><p>3、利用人工光源衬托</p><p>4、寻找兴趣点</p><p>5、俯视营造纵深感</p><p>6、HDR、移轴效果、全景拼接、鱼眼扭曲…… </p></blockquote><p><strong>• 建筑摄影八要素：角度、光线、线条、云 彩、框架的运用、影子、景观、人物； • 视觉要素：形体、轮廓、线条、尺度比例 、质感、色彩……</strong> </p><h5 id="2、LOMO摄影"><a href="#2、LOMO摄影" class="headerlink" title="2、LOMO摄影"></a>2、LOMO摄影</h5><blockquote><p>Lomo有了新含义，Lomo是Let Our lives be Magic and Open</p></blockquote><blockquote><p>lomo是缩写形式，原英文是Let our life be magic and open（意即让我们的生活开放、 有魔力）。在相机里指简单、随意的风格</p></blockquote><blockquote><p>关于<strong>LOMO的十大原则</strong></p><ul><li>1.Take your Lomo every-where you go .走到哪儿,就把Lomo带到哪儿。</li><li>2.Use it anytime-day and night .Lomo不分昼夜。</li><li>3.Lomography is not an interference in your life, but a part of it.不用担心Lomo打扰 你的生活,它就是生活的一部分。</li><li>4.Shoot from the hip. 想拍哪儿就拍哪儿。</li><li>5.Approach the objects of your lomographic desireas close as possible.近点儿,再近 点儿。</li><li>6.Don’t think.什么都不用想。</li><li>7.Be fast.还要快。</li><li>8.You don’t have to know beforehand what you’ve captured on film. 不必了解你要拍 什么。</li><li>9.You don’t have to know beforehand what you’ve cap-tured on film…and afterward seither.更不必了解你拍到了什么。</li><li>10.Don’t worry about the rules.把以上的9条都忘掉。</li></ul></blockquote><h5 id="3、红外摄影"><a href="#3、红外摄影" class="headerlink" title="3、红外摄影"></a>3、红外摄影</h5><p>红外摄影是一种较为另类的拍摄方式，利 用红外感光设备与红外滤镜配合，有别于 传统的黑白彩色照片，拍出的画面给人以 强烈的震撼让人爱不释手；同时红外线相 对可见光对一些材料及衣料具有穿透能力 （薄化纤、烟雾、水气…），能拍出神奇的 透视效果</p><p><strong>红外摄影技术的获得</strong></p><blockquote><p>• 1）将价格很低的数码相机CMOS或者CCD传 感器前的低通滤镜拆除，镜头前加红外滤 镜。改造后只能用于红外摄影。</p><blockquote><p>1.改装F828作为红外相机是极为正确 1.28-200mm简直是红外版的一镜走天下，何况还有2.0-2.8的大光圈！ </p><p>2.EVF让你时刻都能观察不一样的红外世界（单反相机怎么改也不行，光学取 景器就是光学取景器），而且F828除了EVF外还有个液晶屏也能取景（废话）， EVF和液晶屏能随机背一起进行上下旋转，极大扩展了构图的可能性！ </p><p>3.不像单反相机是对焦和感光元件相互分离的设计，F828的感光元件即对焦 元件，因此改成红外机后没有跑焦问题！<br>4.镜头前是58mm螺纹，不需拆机即可随意更换各种波段的红外滤镜！（改红 外的单反这条最悲剧）<br>5.在液晶屏中实时电子测光，红外线下曝光准确，所拍即所见！</p></blockquote><p>• 2）不破坏现有相机的功能，镜头前直接加 红外滤镜。</p><blockquote><p>• 1.    喜欢浓烈色彩的, 可以选择630nm 或者更低波长的590滤镜, 自定义 白平衡后, 原片一般天空呈亮红偏棕色,或者说是琥珀色, 植物树叶呈蓝 色. 红蓝通道调换后(后文有说明)天空蓝色饱和度高, 树叶黄色或者金 黄色.<br>• 2.    喜欢适中的, 可以选择680, 原片天空呈棕红色, 树叶浅蓝, 通道调换 后天空比较接近正常天空的蓝色, 树叶呈浅黄色.<br>• 3.    喜欢较为纯正红外但又希望带有色彩的, 可以选择720滤镜, 原片天 空呈暗棕红色, 饱和度较低, 树叶白, 通道调换后天空暗浅蓝色, 树叶白.  760滤镜理论上来说有是有颜色的,实际颜色很浅, 几乎是黑白的.<br>• 4.    喜欢纯红外的可以选择850nm滤镜, 无色彩, 天气好时, 天空深暗, 可以得到反差较高的图片, 对于雾霾有更好的穿透力.</p></blockquote></blockquote><h5 id="4、针孔摄影"><a href="#4、针孔摄影" class="headerlink" title="4、针孔摄影"></a>4、针孔摄影</h5><p>• 1）利用小孔成像的原理，抛弃我们已经使 用习惯的光学镜头；<br>• 2）可以得到四周有暗角的、中心稍微清晰 的图像；<br>• 3）一般来说，针孔的透视关系和广角镜头 接近；</p><p><strong>特点</strong></p><blockquote><p>• 模糊、变形、色彩诡异的影像<br>• 拍摄风景也有朦胧美感<br>• 具有超现实主义的图像风格</p><p>针孔摄影实现的方法<br>• 1）购买专门的针孔相机，一般使用胶卷<br>• 2）利用数码单反改造</p></blockquote><h5 id="5、延时摄影"><a href="#5、延时摄影" class="headerlink" title="5、延时摄影"></a>5、延时摄影</h5><p>延时摄影是以一种较低的帧率拍下图像或者视频，然后用正常或者较快的速率播放画面的摄影技术</p><blockquote><p>方法<br>• 1）相机没有内置延时摄影的，按照间隔时 间逐张拍摄，可用电子定时快门自动触发 ，后期软件合成；<br>• 2）直接使用相机内置延时摄影APP，例如 sony相机，设置好参数，主要是间隔时间和 总时长。</p><p>拍摄时间间隔参考<br>• 1)在拍摄城市白天的车流和行人时，间隔时 间设置为 1秒，拍摄间隔小于1秒</p><p>• 2)在拍摄城市夜晚的车流时，间隔时间设置 为2秒到5秒之间，机身设置快门速度为间 隔时间减1秒。</p><p>• 3)在拍摄天空云层运动时，依云层运动速度 ，设置间隔时间为3秒到10秒不等，云层运 动速度越慢，间隔时间最越长。</p></blockquote><p>延时摄影的分类<br>• 1）固定场景延时摄影，相机固定不动，拍 摄内容部分移动；<br>• 2）移轴延时摄影，相机适当缓慢匀速移动 ，同时拍摄内容部分运动，比1显得丰富有 趣。</p><h4 id="四、纪实摄影"><a href="#四、纪实摄影" class="headerlink" title="四、纪实摄影"></a>四、纪实摄影</h4><p>摄影从诞生之日开始就赋予了“真实记录” 的使命</p><p>现代公认的摄影术的诞生是1893年，法国人画家 达盖尔银版摄影技术正式问世</p><p><strong>把真实的瞬间保留下来，是摄影对历史记录的伟大贡献</strong></p><p><strong>摄影的最主要的美学特征也 是他的纪实性。</strong></p><blockquote><p>艺术摄影：所谓艺术摄影就是最大限度的 使用视觉形式和各种摄影手段，表达摄影 师的艺术思想和哲学理念。他不受真实性 的影响，不受摄影手段的限制，也不受时 间和空间的制约。</p><ul><li>艺术摄影和纪实摄影是否真实这点上区别 很大</li></ul><p>纪实性摄影：所谓纪实性摄影就是对任何真实事件、场景、物体的现实现<br>场的记录。</p><p><strong>纪实摄影归类为两个方面:<br>1）关于自然和物;<br>2）关于社会与人。</strong></p><p><strong>决定性瞬间是纪实摄影的根本</strong></p><p>环境的决定性瞬间<br> 前景的决定性瞬间，<br> 背景的决定性瞬间，<br> 光影的决定性瞬间所组成。</p><p>人物的决定性瞬间<br> 神态的决定性瞬间，<br> 交流决定性瞬间，<br> 运动决定性瞬间所组成。</p></blockquote><p>纪实摄影的拍摄方法<br>纪实摄影不是艺术，画面的美和光影 的斑斓不是他的追求目标。 他的意义在于 是否真实的记录了历史，纪实摄影作品的好坏有 它自己的标准</p><p>  照片所承载的信息要准确。就是使读者一看就明 白，照片说的是什么意思。表达的是什么观点和 立场。</p><p> <strong>纪实摄影的拍摄原则就是；真实的记录，不对正在发生的</strong><br><strong>事件做任何干涉和影响。使事件按照自己的发展规律发展，</strong><br><strong>不论事件是好是坏。</strong></p><p><strong>构图原则</strong></p><blockquote><p>1）照片所表现的事件真实而有现场感</p><p>短焦距镜头的使用，使得能较好的 保证现场感的体现</p><p>利用标准镜头的透视关系和视角最接近 人类的眼睛，所拍摄的作品符合人们的习 惯</p><p><strong>28-50mm</strong>之间的焦距，比较符合纪实 摄影的要求</p><p>2）构图的形式要适合视觉的习惯</p><p>3）视觉中心构图，就是把主体安放在视觉中 心的位置上，利于读者注意画面主体，明确主 体，清楚事件的主体是在什么环境下运作的。</p></blockquote><p><strong>纪实摄影的拍摄方法</strong></p><p>1）守株待兔法：</p><p> 2）声东击西法</p><p> 3）掩护法：</p><p>4）突然袭击法</p><p> 5）逼迫法：</p><p>6）盲拍法</p><p>7）最合理的做法是，和被拍摄对 象沟通聊天，乃至和他一起生活 很长时间，深入了解他并记录他</p><p><strong>适当 提高ISO，ISO400-1600，ISO自动最 合理了。光圈适当缩小，F2.8、 F4  快门 保持高速。</strong></p><p><strong>拍摄经验</strong><br> 1）置于AV光圈优先档； </p><p> 2）光圈 F2.0-F4.0（35mm-50mm镜头）； </p><p> 3）矩阵测光，80%的照片能够合适曝光。只要 不过曝光，后期可以处理； </p><p> 4）ISO随时设置，注意快门是否低于安全快门 速度（镜头焦距的倒数），尽量不低于1/125S. 如果图简单，ISO设置成AUTO </p><p> 5）触摸屏相机极大的优势，对焦点所摸所得。 </p><p> 6）看准时机，连拍多张。</p><blockquote><p>纪实摄影三个关键点<br> 1）寻求题材：关注普通人的生活，但是关 注的题材带有社会的共性。对社会现象记 录和深度发掘；<br> 2）观察：带着探究本质的精神去观察现象<br> 3）思考：深入题材，独特的现象记录，思 考所记录的表现和题材背后的内在本质联 系·。</p><p>纪实摄影前期选题思考 </p><p> 1）人文纪实的最大的难题不是如何拍，而是拍什 么？</p><p> 2）宏观观察社会，微观记录。从社会具体现象来 表达社会特征； </p><p> 3)走出猎奇误区，不要觉得拍摄一些旅游中不常见 的少数民族生活就肯定是好作品，拍摄你最熟悉的 生活； </p><p> 4）唯美误区，形式至上的误区； </p><p> 5）影赛的误区，那是极大的误导； </p><p> 6）突出时代，远离抽象，眼下习以为常的现象十 年后说不定觉得好有趣味好有意义；</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="摄影" scheme="https://albert-5.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="人像摄影" scheme="https://albert-5.github.io/tags/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/"/>
    
      <category term="LOMO摄影" scheme="https://albert-5.github.io/tags/LOMO%E6%91%84%E5%BD%B1/"/>
    
      <category term="红外摄影" scheme="https://albert-5.github.io/tags/%E7%BA%A2%E5%A4%96%E6%91%84%E5%BD%B1/"/>
    
      <category term="延时摄影" scheme="https://albert-5.github.io/tags/%E5%BB%B6%E6%97%B6%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>toefl &amp; ielts</title>
    <link href="https://albert-5.github.io/2019/04/28/toefl-ielts/"/>
    <id>https://albert-5.github.io/2019/04/28/toefl-ielts/</id>
    <published>2019-04-28T03:50:51.000Z</published>
    <updated>2019-04-29T08:04:49.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="TOEFL"><a href="#TOEFL" class="headerlink" title="TOEFL"></a>TOEFL</h2><p><strong>托福是美国教育考试中心开发出来的给非英语国家学生的英语水平测试</strong></p><h3 id="1、认可国"><a href="#1、认可国" class="headerlink" title="1、认可国"></a>1、认可国</h3><blockquote><p><strong>北美国家（特别是美国）包括日本对托福成绩的接受度较高；</strong></p><p><strong>英联邦国家（英国、荷兰、加拿大、澳大利亚、新西兰、瑞士等）更接受甚至只接受托福成绩；</strong></p></blockquote><h3 id="2、考试形式"><a href="#2、考试形式" class="headerlink" title="2、考试形式"></a>2、考试形式</h3><p><strong>雅思和托福的考试内容也不相同，虽然都是对“听说读写”四种英语能力的测试，但是雅思更加注重生活应用，词汇量没有托福要求的那么多；而托福更加注重学术方面，对专业性的要求更高一点</strong></p><blockquote><p><strong>托福是纯机考，也就是说不管是听力、阅读还是写作，甚至口语都是对着一台电脑，以“人机”的方式进行考核的</strong>。</p></blockquote><h3 id="3、分数分配"><a href="#3、分数分配" class="headerlink" title="3、分数分配"></a>3、分数分配</h3><p><strong>托福是四项单项各30分，总计120分，最后几项分数加起来为总成绩；考试时间大概在4个小时左右，可能会有加试的情况；</strong></p><p><strong>其中，托福成绩在100分以上是不错的分数</strong></p><blockquote><p><strong>有限期为两年</strong></p></blockquote><h3 id="4、考试费用"><a href="#4、考试费用" class="headerlink" title="4、考试费用"></a>4、考试费用</h3><table><thead><tr><th>项目</th><th>金额</th></tr></thead><tbody><tr><td><strong>托福网考考试费</strong></td><td><strong>1985</strong></td></tr><tr><td><strong>逾期报名附加费</strong></td><td><strong>310</strong></td></tr><tr><td><strong>转考费</strong></td><td><strong>620</strong></td></tr><tr><td><strong>恢复已取消的成绩</strong></td><td><strong>154</strong></td></tr><tr><td><strong>成绩赠送费（每份）</strong></td><td><strong>146</strong></td></tr><tr><td><strong>口语或写作单项复议</strong></td><td><strong>615</strong></td></tr><tr><td><strong>口语和写作双项复议</strong></td><td><strong>1229</strong></td></tr><tr><td><strong>托福复习套餐Prem(不包含考试费)</strong></td><td><strong>1086</strong></td></tr><tr><td><strong>托福复习套餐prep</strong></td><td><strong>395</strong></td></tr><tr><td><strong>折扣报名费</strong></td><td><strong>1716</strong></td></tr><tr><td><strong>考费差额 1</strong></td><td><strong>44</strong></td></tr><tr><td><strong>考费差额 2</strong></td><td><strong>224</strong></td></tr><tr><td><strong>考费差额 3</strong></td><td><strong>1104.5</strong></td></tr><tr><td></td></tr></tbody></table><h2 id="IELTS"><a href="#IELTS" class="headerlink" title="IELTS"></a>IELTS</h2><h3 id="1、认可国-1"><a href="#1、认可国-1" class="headerlink" title="1、认可国"></a>1、认可国</h3><p><strong>雅思是英国大使馆文化教育处来出题的</strong></p><blockquote><p><strong>相对的英国目前大部分高校只认可雅思成绩</strong></p></blockquote><h3 id="2、考试形式-1"><a href="#2、考试形式-1" class="headerlink" title="2、考试形式"></a>2、考试形式</h3><blockquote><p><strong>雅思</strong>则是笔试 +面试的形式，口语环节是面对面直接和考官交流的，分数的弹性相对更大一点。对于喜欢交流的人而言考雅思更能会更加有利。</p></blockquote><h3 id="3、分数分配-1"><a href="#3、分数分配-1" class="headerlink" title="3、分数分配"></a>3、分数分配</h3><p><strong>雅思的四项单项都是九分满分制，最后以四项平均分定为最终分数，一般情况下，雅思在7分以上是不错的成绩</strong></p><blockquote><p>有效期为<strong>两年</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="English" scheme="https://albert-5.github.io/categories/English/"/>
    
    
      <category term="toefl" scheme="https://albert-5.github.io/tags/toefl/"/>
    
      <category term="ielts" scheme="https://albert-5.github.io/tags/ielts/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://albert-5.github.io/2019/04/22/hello-world/"/>
    <id>https://albert-5.github.io/2019/04/22/hello-world/</id>
    <published>2019-04-22T15:42:22.451Z</published>
    <updated>2019-04-29T08:18:51.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://zymin.cn/arcticle/hexo-vps.html">Hexo与阿里云虚拟主机搭建博客</a></li><li><a href="https://zymin.cn/arcticle/hexo+ejs+material.html">hexo+ejs+material x 添加统计代码</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="hexo" scheme="https://albert-5.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://albert-5.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>sort_algorithm</title>
    <link href="https://albert-5.github.io/2019/03/28/sort-algorithm/"/>
    <id>https://albert-5.github.io/2019/03/28/sort-algorithm/</id>
    <published>2019-03-28T09:47:54.000Z</published>
    <updated>2019-04-29T09:49:32.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a><strong>一、概念</strong></h1><p><strong>排序算法是一种能将一串数据按照特定顺序进行排列的一种算法</strong></p><p><strong><font color="#660000">稳定性:</font></strong> <font face="宋体">稳定排序算法会让原本有相等数值的记录维持相对顺序，也就说当有两个相等的数据A，B时，且原本A在B的前面，则在排序后A仍然是在B的前面，这就是稳定性的概念；</font></p><h1 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a><strong>二、冒泡排序</strong></h1><h2 id="1、啥子叫冒泡排序"><a href="#1、啥子叫冒泡排序" class="headerlink" title="1、啥子叫冒泡排序"></a>1、啥子叫冒泡排序</h2><blockquote><p>它是一种较为简单的排序算法，具体过程就是遍历所要排序的数列，每一次比较两个数，如果他们顺序错误则交换顺序，直至所有的数据交换完毕，也就是完成了数列的排序；由于在交换过程中，最小的元素会处于顶端的位置，所以叫做<font color="#32CD32"><strong>冒泡排序</strong></font> 。</p></blockquote><h2 id="2、过程分析"><a href="#2、过程分析" class="headerlink" title="2、过程分析"></a>2、过程分析</h2><blockquote><font color="#008B00" face="黑体">在实现冒泡排序的过程中，每次循环之后，数列中最大的元素移动到了最末端，然后在进行下一次的循环遍历，选出次大的元素，继续循环，直至排完序，则最小的处在顶端的位置</font></blockquote><h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>，len(alist)<span class="number">-1</span>-j): <span class="comment"># 操作下标而不是直接作用于元素上</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 优化情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>):</span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 记录交换的次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(alist)<span class="number">-1</span>-j):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count <span class="keyword">is</span> <span class="number">0</span>:  <span class="comment"># 如果count为0，则说明没有进行交换</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">    bubble_sort(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="#CD2626">说明：</font></strong> </p><ul><li>最优时间复杂度为<font color="#dd00dd">O(n)</font> &lt;<strong><font size="2">遍历一遍发现全都排好了</font></strong>&gt;</li><li>最坏时间复杂度为<font color="#dd00dd">O(n^2)</font></li><li>稳定</li></ul></blockquote><h1 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a><strong>三、选择排序</strong></h1><h2 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>一组数据相当于分成了两个部分，后一部分是待排数列，初始默认第一个元素是最小值，然后从这些待排的数列中进行遍历找到最小值并记录下标位置，然后与记录的初始最小值比较，如果找到的小于初始值则进行交换，然后继续遍历；也就是说,<font color="#CD2626">整个过程就是在找最小值。</font></strong></p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">'''选择排序'''</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br></pre></td></tr></table></figure><p><strong><font color="#267C19">时间复杂度：O(n^2)</font></strong></p><p><strong><font color="#267C19">稳定性：简单的考虑这种情况，在一个乱序的列表中[11,23,12,23,6],排序时第一个23较大，则在排序时会由于交换而移动到最后面，则在排列第二个23时，因为它不比第一个23大，所以不变化，由此可见，二者交换了顺序，稳定性就是不稳定</font></strong></p><h1 id="四、插入排序"><a href="#四、插入排序" class="headerlink" title="四、插入排序"></a><strong>四、插入排序</strong></h1><h2 id="1、思想-1"><a href="#1、思想-1" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动</strong></p><h2 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">'''插入排序'''</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># j表示循环次数，也即是有多少个元素执行此过程</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        i = j</span><br><span class="line">        <span class="comment"># i是表示从从待排序列中取出第一个，然后进行扫描比较</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[i] &lt; alist[i<span class="number">-1</span>]:</span><br><span class="line">                alist[i], alist[i<span class="number">-1</span>] = alist[i<span class="number">-1</span>], alist[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h2><p><strong><font color="#227BA0">最优时间复杂度: O(n) &lt;数列已按照升序排列，这个时间复杂度仅仅是遍历的时间&gt;</font></strong></p><p><strong><font color="#227BA0">最坏时间复杂度: O(n^2) </font></strong></p><p><strong><font color="#227BA0">稳定性:稳定</font></strong></p><h1 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a><strong>五、希尔排序</strong></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>它是插入排序的一种，也称为缩小增量排序，是直接插入排序算法的一种更为高效的改进版；但是它是不稳定的。<font color="#6C2397">具体思想</font>就是把数据按照下标的一定增量进行分组，然后对每一个组进行插入排序，随着增量的一步步减少，每一组包含的数据越多，当增量为1时，整个排序完成！</strong></p><h2 id="2、实现-2"><a href="#2、实现-2" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    gap = n // <span class="number">2</span>  <span class="comment"># 确定步长</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(gap,n):</span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i-gap]:</span><br><span class="line">                    alist[i],alist[i-gap] = alist[i-gap],alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong><font color="#6C2397">最优时间复杂度: 无法确定</font></strong></p><p><strong><font color="#6C2397">最坏时间复杂度: O(n) </font></strong></p><p><strong><font color="#6C2397">稳定性: 不稳定</font></strong></p><h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a><strong>六、快速排序</strong></h1><h2 id="1、思想-2"><a href="#1、思想-2" class="headerlink" title="1、思想"></a>1、思想</h2><hr><ul><li><strong>先从给定数列中取出一个基准数据值，记为x</strong></li><li><strong>排序过程中，小于x的数据全放在左边，大于x的数据全放在其右边</strong></li><li><strong>然后再次重复上述步骤即可</strong></li></ul><h2 id="2、实现-3"><a href="#2、实现-3" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(alist,first,last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &gt;= last:</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    mid_value = alist[<span class="number">0</span>]</span><br><span class="line">    low = first</span><br><span class="line">    high = last</span><br><span class="line">    <span class="keyword">while</span>  low &lt; high:</span><br><span class="line">        <span class="comment"># high左移</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid_value:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line">        <span class="comment"># low右移，在判断里面进行移动low的值以防它移动过度</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid_value:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line">    alist[low] = mid_value</span><br><span class="line">    <span class="comment"># 此时low的位置就是初始的那个值</span></span><br><span class="line">    <span class="comment"># 递归使用函数本身，快排左边</span></span><br><span class="line">    quick_sort(alist,first,low<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 递归快排右边</span></span><br><span class="line">    quick_sort(aliist,low+<span class="number">1</span>,last)</span><br></pre></td></tr></table></figure><ul><li><strong><font color="9E33FF">最优时间复杂度： O(n*logn)</font></strong></li><li><strong><font color="9E33FF">最坏时间复杂度： O(n^2) </font>  # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项</strong></li><li><strong><font color="9E33FF">稳定性：不稳定</font></strong></li></ul><h1 id="七、归并算法"><a href="#七、归并算法" class="headerlink" title="七、归并算法"></a><strong>七、归并算法</strong></h1><h2 id="1、思想-3"><a href="#1、思想-3" class="headerlink" title="1、思想"></a>1、思想</h2><hr><p><strong>&nbsp;&nbsp;分而治之，就是将一组待排序列向下均分、均分、均分······直至每一个小分组中只有一个元素，然后向上走进行合并操作，以致达到排序的目的</strong></p><h2 id="2、实现-4"><a href="#2、实现-4" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">'''归并排序'''</span></span><br><span class="line">    <span class="comment"># 分而治之，先进行分的操作</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = n/<span class="number">2</span></span><br><span class="line">    <span class="comment"># 分的结果为两个新的列表left 和 right;以下是递归操作</span></span><br><span class="line">    left = merge_sort(alist[:mid])</span><br><span class="line">    right = merge_sort(alist[mid+<span class="number">1</span>:])</span><br><span class="line">    left_pointer, right_pointer = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left[left_pointer] &lt; len(left) <span class="keyword">and</span> right[right_pointer] &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[left_pointer] &lt;= right[right_pointer]:</span><br><span class="line">            result.append(left[left_pointe])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line">    result += left[left_pointer:]</span><br><span class="line">    result += right[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment">#-----------------------------------------------------------</span></span><br></pre></td></tr></table></figure><p><strong><font color="8E33FE"> 最优时间复杂度：O(n*logn) </font></strong></p><p><strong><font color="9E33FF">最坏时间复杂度：O(n*logn) </font>  # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项</strong></p><p><strong><font color="9E33FF">稳定性：稳定</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="https://albert-5.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="插入排序" scheme="https://albert-5.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://albert-5.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://albert-5.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://albert-5.github.io/2019/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://albert-5.github.io/2019/03/25/栈和队列/</id>
    <published>2019-03-25T09:54:05.000Z</published>
    <updated>2019-04-29T09:56:46.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一、python递归函数深度限制"><a href="#一、python递归函数深度限制" class="headerlink" title="一、python递归函数深度限制"></a>一、python递归函数深度限制</h4><p>python使用递归函数会受到递归深度的限制，大概是900多点(因为100次的时候就会报错：maximum recursion depth exceeded in comparison)，嘿嘿嘿</p><p>解决方法</p><blockquote><p><strong>导入python中 sys模块，import sys</strong></p><p><strong>然后使用 sys 下的 setrecursionlimit去重新规定它的限制</strong></p></blockquote><p><strong>**ps:但是要注意一点设置Python解释器堆栈的最大深度以限制。此限制可防止无限递归导致C堆栈溢出并导致Python崩溃。</strong></p><p><strong>最高可能的限制取决于平台。当用户需要深度递归的程序和支持更高限制的平台时，用户可能需要设置更高的限制。这应该小心，因为太高的限制可能导致崩溃</strong></p><h4 id="二、栈stack"><a href="#二、栈stack" class="headerlink" title="二、栈stack"></a><strong>二、栈st</strong>ack</h4><h5 id="1、栈的操作"><a href="#1、栈的操作" class="headerlink" title="1、栈的操作"></a>1、栈的操作</h5><p>**·  stack()创建一个空栈</p><p>·  push()添加一个新的元素item到栈顶</p><p>·  pop()弹出栈顶元素</p><p>·  peek()返回栈顶元素</p><p>·  is_empty()判断栈是否为空</p><p>·  size()返回栈的元素个数**</p><h5 id="2、栈的代码实现"><a href="#2、栈的代码实现" class="headerlink" title="2、栈的代码实现"></a>2、栈的代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''栈'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list = []  <span class="comment"># 建立私有容器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">''</span>添加一个新的元素到栈顶<span class="string">''</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line">        <span class="comment"># self.__list.insert(0,item) 在栈顶插入时复杂度为n,相反在尾部时复杂度就为1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''弹出栈顶元素'''</span></span><br><span class="line">        self.__list.pop()</span><br><span class="line">        <span class="comment"># self.__list.pop(0)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">'''返回栈顶元素'''</span></span><br><span class="line">        <span class="keyword">if</span> self.__list:</span><br><span class="line">        <span class="keyword">return</span> self.__list[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断栈是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.__list</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''返回栈中元素的个数'''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Stack()</span><br></pre></td></tr></table></figure><h4 id="三、队列queue"><a href="#三、队列queue" class="headerlink" title="三、队列queue"></a>三、队列queue</h4><h5 id="1、只允许在一端进行插入操作，另一端进行删除操作的线性表"><a href="#1、只允许在一端进行插入操作，另一端进行删除操作的线性表" class="headerlink" title="1、只允许在一端进行插入操作，另一端进行删除操作的线性表"></a>1、只允许在一端进行插入操作，另一端进行删除操作的线性表</h5><h5 id="2、队列的实现"><a href="#2、队列的实现" class="headerlink" title="2、队列的实现"></a>2、队列的实现</h5><p>·  queue()创建一个空的队列</p><p>·  enqueue(item)添加一个新的元素item到队列中</p><p>·  dequeue()从队头删除一个元素</p><p>·  is_empty()判断队列是否为空</p><p>·  size()返回队列中的元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''队列'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>：</span></span><br><span class="line">    self.__list = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''往队列中添加一个item元素'''</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line">        <span class="comment"># self.__list.insert(0,item)</span></span><br><span class="line">        <span class="comment"># 无论选择哪个总有一个的复杂度是O(1)，另一个是O(n)，具体选择根据自己功能哪个用的多</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''从队列中删除一个元素'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断一个队列是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''返回队列的大小'''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __init__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Queue()</span><br><span class="line">    s.enqueue(<span class="number">1</span>)</span><br><span class="line">    s.enqueue(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="四、双端队列"><a href="#四、双端队列" class="headerlink" title="四、双端队列"></a>四、双端队列</h4><p>**·  deque创建一个空的双端队列</p><p>·  add_front(item)从队头加入一个item元素</p><p>·  add_rear(item)从队尾加入一个item元素</p><p>·  remove_front()从队头删除一个item元素</p><p>·  remove_rear()从队尾删除一个item元素</p><p>·  is_empty()判断双端队列是否为空</p><p>·  size()返回双端队列的大小**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''双端队列'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>：</span></span><br><span class="line">    self.__list = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_front</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''往双端队列的头部添加一个item元素'''</span></span><br><span class="line">        self.__list.insert(<span class="number">0</span>,item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''从双端队列的头部删除一个元素'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''从双端队列的尾部取出元素'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断一个双端队列是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''返回双端队列的大小'''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br></pre></td></tr></table></figure><h4 id="五、链表"><a href="#五、链表" class="headerlink" title="五、链表"></a>五、链表</h4><h5 id="1、单向链表"><a href="#1、单向链表" class="headerlink" title="1、单向链表"></a>1、单向链表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">     <span class="comment"># 同样可以利用python的二元组进行操作(elem)</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Single_LinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''单链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,node=None)</span>:</span>  <span class="comment"># 就是一个内部的使用，规定一个头结点，而且这个头结点应该是私有的，因为在封装后的SingleLinkList对象中，外部能够调用的就是以下的几个函数，其他的是无法使用的，所以私有化处理了，纯粹是自己的内部函数去使用；</span></span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__head = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表长度'''</span></span><br><span class="line">        <span class="comment"># cur游标，用来移动遍历节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># count 记录数量</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表遍历'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''链表头部添加元素,头插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.__head.next</span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,item)</span>:</span>  <span class="comment"># 这里的item仅仅是数据元素，而不是节点</span></span><br><span class="line">        <span class="string">'''链表尾部添加元素，尾插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty(): <span class="comment"># 判断链表是否为空</span></span><br><span class="line">            self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,pos,item)</span>:</span>  <span class="comment"># 在任意位置添加元素，pos表示需要添加元素的位置，item表示要添加的数据</span></span><br><span class="line">        <span class="string">'''在某个位置插入元素'''</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self.__head <span class="comment"># pre的用法和cur一样</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos<span class="number">-1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                pre = pre.next</span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = pre.next</span><br><span class="line">            pre.next = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''删除节点'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != item:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 要判断此节点是不是头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    self.__head = cur.next</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点是否存在'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>链表和顺序表的比较</strong></p><table><thead><tr><th>操作</th><th>链表</th><th>顺序表</th></tr></thead><tbody><tr><td><strong>访问元素</strong></td><td>O(1)</td><td>O(1)</td></tr><tr><td><strong>头部插入 or 删除元素</strong></td><td>O(1)</td><td>O(n)</td></tr><tr><td><strong>尾部插入 or 删除元素</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>在中间插入 or 删除元素</strong></td><td>O(n)</td><td>O(n)</td></tr></tbody></table><h4 id="六、双向链表"><a href="#六、双向链表" class="headerlink" title="六、双向链表"></a><strong>六、双向链表</strong></h4><h5 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h5><p>**·  is_empty()链表是否为空</p><p>·  length()链表长度</p><p>·  travel()遍历整个链表</p><p>·  add(item)链表头部添加信息</p><p>·  append(item)链表尾部添加信息</p><p>· insert(pos, item)在特定位置添加元素</p><p>·  remove(item)删除节点</p><p>· search(item)查找节点是否存在**</p><h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''双链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,node=None)</span>:</span></span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断双链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''双链表长度'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">         <span class="keyword">return</span> count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''遍历双链表'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">       <span class="string">'''头部添加元素'''</span></span><br><span class="line">       node = Node(item)</span><br><span class="line">       node.next = self.__head.next</span><br><span class="line">       self.__head = node</span><br><span class="line">       node.next.prev = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,item)</span>:</span></span><br><span class="line">       <span class="string">'''双链表的尾部添加元素'''</span></span><br><span class="line">       node = Node(item)</span><br><span class="line">       <span class="keyword">if</span> self.is_empty():</span><br><span class="line">           self.__head = node</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cur = self.__head</span><br><span class="line">           <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">               cur = cur.next</span><br><span class="line">           cur.next = node</span><br><span class="line">           node.prev = cur</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,pos,item)</span>:</span></span><br><span class="line">        <span class="string">'''在双向链表的某个位置插入元素'''</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 退出循环之后，cur指向pos位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur</span><br><span class="line">            node.prev = cur.prev</span><br><span class="line">            cur.prev = node</span><br><span class="line">            cur.prev.next = node</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''删除节点'''</span></span><br><span class="line">        <span class="comment"># cur 游标指向头结点的时候，pre指向空，相差一个单位的距离</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem <span class="keyword">is</span> item:</span><br><span class="line">                <span class="comment"># 判断当前游标cur指向是不是在1处</span></span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">is</span> self.__head:</span><br><span class="line">                    self.__head = cur.next</span><br><span class="line">                    <span class="comment"># 判断cur.next是否为空，因为空的元素是没有prev的</span></span><br><span class="line">                    <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.next.prev = <span class="literal">None</span></span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="keyword">if</span> cur.next:</span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">serch</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点'''</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        whilt cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem <span class="keyword">is</span> item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="python" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/python/"/>
    
    
      <category term="python" scheme="https://albert-5.github.io/tags/python/"/>
    
      <category term="数据结构" scheme="https://albert-5.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="https://albert-5.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://albert-5.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="链表" scheme="https://albert-5.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="https://albert-5.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://albert-5.github.io/2019/03/20/查找算法/</id>
    <published>2019-03-20T09:56:30.000Z</published>
    <updated>2019-04-29T09:58:07.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a><strong>一、二分查找</strong></h1><h2 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>二分查找又被称为折半查找，优点就是比较次数少，查找速度快，平均性能好，但其缺点是要求待查表为<font color="6D29AA">有序表</font></strong>，<strong>假设表中的元素是按照升序排列的，将表中间位置记录的关键字与查找的关键字作比较，如果两者相等，则查找成功；否者就利用中间位置记录分为前、后两个子表，如果中间位置的关键字大于查找关键字，则进一步查找前一个子表，否者就查找后一个子表，然后重复即可</strong></p><h2 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(alist,item)</span>:</span></span><br><span class="line">    <span class="string">'''二分查找'''</span></span><br><span class="line">    n =  len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        mid = n/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[mid] == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> item &lt; alist[mid]:</span><br><span class="line">            binary_search(alist[:mid],item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            binary_search(alist[mid+<span class="number">1</span>:],item)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="3、时间复杂度问题"><a href="#3、时间复杂度问题" class="headerlink" title="3、时间复杂度问题"></a>3、时间复杂度问题</h2><ul><li>关于时间复杂度的问题，首先讨论最坏的情况，就是进行到最后一步才找到元素item，在这种情况下因为是二分查找法，每次都是对半的，所以一共有<font color="#08298A">O(log n)</font></li><li><font color="#08298A">最优时间复杂度：O(1)</font> </li></ul><h1 id="二、树"><a href="#二、树" class="headerlink" title="二、树"></a><strong>二、树</strong></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><blockquote><p><strong><font face="隶书">它是另外一种数据结构，但元素之间的关系并不是线性结构，而是一种更为复杂的结构；但是它有以下特征： 1、如果他的结构不为空，则其中就存在着唯一的起始节点，称之为树根root；2、每个节点有零个或多个子节点；3、没有父节点的节点成为根节点；4、每一个非根节点有且只有一个父节点；5、除了根节点之外，每个子节点可以分为多个不相交的子树······</font></strong></p></blockquote><h2 id="2、常用术语名称"><a href="#2、常用术语名称" class="headerlink" title="2、常用术语名称"></a>2、常用术语名称</h2><ul><li><strong>节点的度：</strong>一个节点含有的子树的个数称为该节点的度</li><li><strong>树的度：</strong>一棵树中，最大的节点的度</li><li><strong>叶子节点或终节点：</strong>度为零的节点</li><li><strong>父节点：</strong>若一个节点含有子节点，则这个节点就称为该子节点的父节点</li><li><strong>节点的层次：</strong>从根节点开始定义起，根为第一层，根的子节点为第二层，以此类推······</li><li><strong>树的高度或深度：</strong>树中节点的最大层次</li></ul><h2 id="3、树的分类"><a href="#3、树的分类" class="headerlink" title="3、树的分类"></a>3、树的分类</h2><ul><li><p><strong>无序树：</strong>树中任意节点的子节点之间没有顺序关系，也叫做自由树</p></li><li><p><strong>有序树：</strong>树中任意节点的子节点之间有顺序关系</p><ul><li><p><strong>二叉树：</strong>每个节点最多含有两个子树的树</p><ul><li><p><strong>完全二叉树：</strong>对于一颗二叉树，假设其深度为d，除了第d层外，其他各层的节点数目均已经达到最大值，且第d层所有节点从左向右连续的紧密排列；<strong>==满二叉树==</strong>的定义是所有叶节点都在最底层的完全二叉树; </p></li><li><p><strong>平衡二叉树&lt;AVL树&gt;：</strong>当且仅当任何节点的两棵子树得到高度差不超过2的二叉树</p></li><li><p><strong>排序二叉树（二叉查找树，binary search tree）：</strong>也称为二叉搜索树、有序二叉树</p></li></ul></li></ul></li></ul><pre><code>![20190330](C:/Users/DELL/Desktop/markdown%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/20190330.jpg)​      </code></pre><ul><li><p><strong>霍夫曼树：</strong>用于信息编码，待权路径最短的二叉树称为哈夫曼树或者是最优二叉树</p></li><li><p><strong>B树：</strong>一种对读写操作进行优化的自平衡的二叉查找树，能够爆出数据有序，拥有多余两个子树；</p></li></ul><hr><p><strong>树的应用场景</strong></p><blockquote><p>1、xml、html等标签的关系</p><p>2、路由协议运用了树的算法</p><p>3、mysql数据库索引</p><p>4、文件系统的目录结构</p><p>5、AI算法，机器学习中的 decision tree等</p></blockquote><h1 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a><strong>三、二叉树</strong></h1><h2 id="1、性质"><a href="#1、性质" class="headerlink" title="1、性质"></a>1、性质</h2><ul><li>在二叉树的第i层最多有2 ^i-1^ 个节点</li><li>深度为k的二叉树最多有(2 ^k^ -1)个节点</li><li>对于任意一颗二叉树，如果叶子节点数为N ~0~ ，而度数为2的节点的总数为N ~2~ ，则有N ~0~ = N ~2~ + 1；</li></ul><h2 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''构造节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''构造左右孩子'''</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 取出当前节点</span></span><br><span class="line">            cur_node = queue.pop()</span><br><span class="line">            <span class="comment"># 判断当前节点的左右子树是否为空</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.right)</span><br></pre></td></tr></table></figure><h1 id="四、广度遍历"><a href="#四、广度遍历" class="headerlink" title="四、广度遍历"></a><strong>四、广度遍历</strong></h1><h2 id="1、思想-1"><a href="#1、思想-1" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>这种遍历方法就是按照路径长度由远及近地访问节点，也即是说按照二叉树的层次遍历访问层中的每一个节点；==这种遍历无法使用递归==；在这种宽度优先遍历中，只规定了逐层访问，并没有规同一层的节点访问顺序，但从算法的角度上，必须规定一个顺序，常见的是在每一层里都从左往右逐个访问；==实现这一算法是用队列作为缓存;==</strong></p><h2 id="2、实现-2"><a href="#2、实现-2" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''构造节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''构造左右孩子'''</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 取出当前节点</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 判断当前节点的左右子树是否为空</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breath_travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''广度优先遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem)</span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append.rchild(cur_node.rchild)</span><br></pre></td></tr></table></figure><h1 id="五、深度优先遍历"><a href="#五、深度优先遍历" class="headerlink" title="五、深度优先遍历"></a><strong>五、深度优先遍历</strong></h1><h2 id="1、思想-2"><a href="#1、思想-2" class="headerlink" title="1、思想"></a>1、思想</h2><p><strong>深度优先遍历不同于广度优先遍历，其遍历有三种不同的方式:</strong></p><p><strong><font color="#5345AB">先序遍历[^脚注1]</font>，<font color="#7F1BC2">中序遍历[^脚注2]</font>，<font color="#9C20D7">后序遍历[^脚注3]</font></strong></p><h2 id="2、实现-3"><a href="#2、实现-3" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''构造节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''构造左右孩子'''</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span></span><br><span class="line">        self.rchild = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 取出当前节点</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 判断当前节点的左右子树是否为空</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breath_travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''广度优先遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem)</span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append.rchild(cur_node.rchild)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="string">'''先序遍历'''</span></span><br><span class="line">        <span class="comment"># 判断节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(node.elem)  <span class="comment"># 打印根节点</span></span><br><span class="line">        self.preorder(node.lchild)  <span class="comment"># 递归打印左子树</span></span><br><span class="line">        self.preorder(node.rchild)  <span class="comment"># 递归打印右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="string">'''中序遍历'''</span></span><br><span class="line">        <span class="comment"># 判断节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.lchild)  <span class="comment"># 递归打印左子树</span></span><br><span class="line">        print(node.elem)  <span class="comment"># 打印根节点</span></span><br><span class="line">        self.inorder(node.rchild)  <span class="comment"># 递归打印右子树     </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="string">'''后序遍历'''</span></span><br><span class="line">        <span class="comment"># 判断节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(node.lchild)  <span class="comment"># 递归打印左子树</span></span><br><span class="line">        self.postorder(node.rchild)  <span class="comment"># 递归打印右子树</span></span><br><span class="line">        print(node.elem)  <span class="comment"># 打印根节点</span></span><br></pre></td></tr></table></figure><h1 id="六、哈夫曼树"><a href="#六、哈夫曼树" class="headerlink" title="六、哈夫曼树"></a><strong>六、哈夫曼树</strong></h1><h2 id="1、思想-3"><a href="#1、思想-3" class="headerlink" title="1、思想"></a>1、思想</h2><blockquote><p>设有实数集<br>$$<br>W = {w_0,w_1,w_2,\cdots,w_{m-1}}<br>$$<br>T是一颗扩充二叉树，其 m 个外部节点分别为以 w ~i~ 为权，而且T的带权外部路径长度 <strong>WPL</strong>在所有这样的扩充二叉树中达到最小，则称 T 为数据集 W 的 <strong><font color="#7F1BC2">最优二叉树</font></strong>或者是<strong><font color="#7F1BC2">哈夫曼树</font></strong></p><font face="宋体" color="#7F1BC2"><a href="https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91" target="_blank" rel="noopener">Click Here and Learn More</a></font></blockquote><h2 id="2、实现-4"><a href="#2、实现-4" class="headerlink" title="2、实现"></a>2、实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTNode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item,leftchild=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 rightchild=None)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.leftchild = leftchild</span><br><span class="line">        self.rightchild = rightchild</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTNode</span><span class="params">(BinTNode)</span>:</span>  <span class="comment"># 这里继承了BinTNode类，定义了一个专门为构建哈夫曼树的节点类，特点就是增加了一个小于的比较操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self,othernodes)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.elem &lt; othernode.elem</span><br><span class="line">    <span class="comment"># 这里定义了一个专门为哈夫曼算法服务的优先队列类，其中增加了一个检查队列中元素个数的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanPrioQ</span><span class="params">(PrioQueue)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._elems)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HuffmanTree</span><span class="params">(weights)</span>:</span></span><br><span class="line">    tree = HuffmanPrioQ()</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">        tree.enqueue(HTNode(w))</span><br><span class="line">    <span class="keyword">while</span> tree.number() &gt; <span class="number">1</span>:</span><br><span class="line">        t1 = tree.dequeue()</span><br><span class="line">        t2 = tree.dequeue()</span><br><span class="line">        x = t1.elem + t2.elem</span><br><span class="line">        tree.enqueue(HTNode(x,t1,t2))</span><br><span class="line">    <span class="keyword">return</span> tree.dequeue</span><br></pre></td></tr></table></figure><p><strong>算法复杂度：</strong></p><p>第一个循环构造了m颗二叉树，并把他们加入大序列中，按照上面的写法则时间复杂度为<strong>O(m log m)</strong>，因为加入一个元素需要O(log m)次筛选</p><p>第二个循环需要m-1次，每次减少一颗树。其中构造一颗新树的时间与m是无关的，是O(1)复杂度的操作。每次迭代需要把一颗新的树加入到优先队列，需要O(log m)复杂度的时间，整个循环就是O(m log m)时间；</p><h2 id="3、树、森林、二叉树的关系"><a href="#3、树、森林、二叉树的关系" class="headerlink" title="3、树、森林、二叉树的关系"></a>3、树、森林、二叉树的关系</h2><p><strong>实际上是一种一一对应的关系，可以把任何一个（有序）树林映射到一颗二叉树上，而其逆映射把这颗二叉树映射回原来的树林，映射关系如下：</strong></p><ul><li>顺序连接同一节点的各个子节点（它们原来在原树林里的兄弟节点），作为这些节点的右分支的边（也就是说，将树/森林中下一兄弟最为二叉树的右分支）</li><li>保留每个节点到其第一个子节点的连接作为该节点的左分支，并删去这个节点到它节点的其他子节点的连接（即是说原森林里第一个子节点作为二叉树里的左分支）</li></ul><p>[^脚注1]: 先序遍历方式：根 —&gt;左—&gt;右<br>[^脚注2]: 中序遍历方式：左 —&gt;根—&gt;右</p><p>[^脚注3]: 后序遍历方式：左 —&gt;右—&gt;根</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="https://albert-5.github.io/categories/%E7%AE%97%E6%B3%95/python/"/>
    
    
      <category term="python" scheme="https://albert-5.github.io/tags/python/"/>
    
      <category term="查找算法" scheme="https://albert-5.github.io/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
      <category term="数和森林" scheme="https://albert-5.github.io/tags/%E6%95%B0%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    
  </entry>
  
  <entry>
    <title>AnyConnect</title>
    <link href="https://albert-5.github.io/2019/02/28/AnyConnect/"/>
    <id>https://albert-5.github.io/2019/02/28/AnyConnect/</id>
    <published>2019-02-28T09:43:44.000Z</published>
    <updated>2019-04-29T09:45:40.881Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="最近发现使用Cisco-AnyConnect在Win8-1上系统上连接VPN时，会出现anyconnect-was-not-able-to-establish-a-connection-to-the-specified-secure-gateway问题导致无法成功连接VPN，错误提示如下所示"><a href="#最近发现使用Cisco-AnyConnect在Win8-1上系统上连接VPN时，会出现anyconnect-was-not-able-to-establish-a-connection-to-the-specified-secure-gateway问题导致无法成功连接VPN，错误提示如下所示" class="headerlink" title="最近发现使用Cisco AnyConnect在Win8.1上系统上连接VPN时，会出现anyconnect was not able to establish a connection to the specified secure gateway问题导致无法成功连接VPN，错误提示如下所示"></a><strong>最近发现使用Cisco AnyConnect在Win8.1上系统上连接VPN时，会出现anyconnect was not able to establish a connection to the specified secure gateway问题导致无法成功连接VPN，错误提示如下所示</strong></h4><blockquote><p><strong>problem:</strong></p><p><strong>AnyConnect was not able to establish a connection to the specified secure gateway. Please try connecting again.</strong></p></blockquote><hr><p>其实解决方法也是很简单的，只需要：</p><blockquote><p><strong>此电脑</strong>鼠标右击 -&gt;<strong>管理</strong> -&gt;<strong>服务于应用程序</strong> -&gt; <strong>服务</strong></p><p><strong>-&gt; 禁用 Internet Connection Sharing即可</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="疑难杂症" scheme="https://albert-5.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="Windows 10" scheme="https://albert-5.github.io/tags/Windows-10/"/>
    
      <category term="VPN" scheme="https://albert-5.github.io/tags/VPN/"/>
    
      <category term="anyconnect" scheme="https://albert-5.github.io/tags/anyconnect/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://albert-5.github.io/2019/01/14/CSS/"/>
    <id>https://albert-5.github.io/2019/01/14/CSS/</id>
    <published>2019-01-14T09:34:51.000Z</published>
    <updated>2019-04-29T09:39:54.859Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、CSS概述"><a href="#一、CSS概述" class="headerlink" title="一、CSS概述"></a>一、CSS概述</h2><p><strong>内容的样式</strong></p><p>英文全称: <strong>Cascating Style Sheets</strong><a href="层叠样式表">^注释1</a></p><h2 id="二、CSS语法"><a href="#二、CSS语法" class="headerlink" title="二、CSS语法"></a>二、CSS语法</h2><p><strong>基本语法格式</strong></p><blockquote><p>p{<br>font-size:#;——&gt;字体大小<br>color:blue; ——–&gt;字体颜色</p><p>font-weight:bold;——&gt;加粗<br>}</p><p><strong>注意：</strong></p><p>1、最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</p><p>2、为了使用样式更加容易阅读，可以将每条代码写在一个新行里。</p></blockquote><h3 id="1、css添加方法"><a href="#1、css添加方法" class="headerlink" title="1、css添加方法"></a>1、css添加方法</h3><h4 id="a：-行内添加"><a href="#a：-行内添加" class="headerlink" title="a： 行内添加"></a>a： 行内添加</h4><blockquote><p>&lt;!DOCTYPE HTML&gt;</p><p><html><br>   <head><meta name="generator" content="Hexo 3.8.0"><br>       </head><body><br>           <p style="color:#"><br>           学习笔记CSS篇<br>           </p><br>       </body><br>   <br></html><br>&lt;/!doctype&gt;</p></blockquote><h4 id="b-内嵌样式"><a href="#b-内嵌样式" class="headerlink" title="b: 内嵌样式"></a>b: 内嵌样式</h4><blockquote><p>&lt;!DOCTYPE HTML&gt;</p><p><html><br>   <head><meta name="generator" content="Hexo 3.8.0"><br>       <style type="text/css"><br>           p{<br>               color:black;/<em>设置字体颜色</em>/<br>           }<br>       </style><br>       </head><body><br>           <p><br>           学习笔记CSS篇,内嵌样式的添加<br>           </p><br>       </body><br>   <br></html><br>&lt;/!doctype&gt;</p></blockquote><p><strong><style type="text/css"></strong></p><p>p{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color:#;</span><br></pre></td></tr></table></figure><p>}</p><p><strong></style></strong></p><h4 id="c-单独文件"><a href="#c-单独文件" class="headerlink" title="c: 单独文件"></a>c: 单独文件</h4><p><strong>外部样式表文件 style.css</strong></p><p><strong>p{color：#;}</strong></p><p><strong>网页文件 12.html</strong></p><blockquote><head><meta name="generator" content="Hexo 3.8.0"><br>    <link rel="stylesheet" href="css/style.css"><br></head><p><strong>使用 href 链接到 css文件</strong></p></blockquote><p><strong>单独样式的优点</strong></p><p>页面结构HTML代码与样式CSS代码的完全分离，便于维护</p><p>如果需要改变网站的风格，只需要修改公共CSS文件即可</p><p>可以在同一个HTML文件中引用多个外部样式表</p><h3 id="2、-添加方式的优先级"><a href="#2、-添加方式的优先级" class="headerlink" title="2、 添加方式的优先级"></a>2、 添加方式的优先级</h3><p><strong>_ 多重样式可以层叠，可以覆盖</strong></p><p><strong>_ 样式的<em>优先级</em>按照“就近原则”</strong></p><p><strong>_ 行内样式 &gt; 内嵌样式 &gt; 链接样式 &gt; 浏览器默认样式</strong></p><h2 id="三、CSS选择器"><a href="#三、CSS选择器" class="headerlink" title="三、CSS选择器"></a>三、CSS选择器</h2><h4 id="1、标签选择器"><a href="#1、标签选择器" class="headerlink" title="1、标签选择器"></a>1、标签选择器</h4><p>采用内嵌式时，以<strong>body、h1、p等</strong>直接作为标签名</p><blockquote><style type="text/css">body{background-color:##;     text-align:#;     font-size:#;}h1{   font:"黑体"；font-size:#;    }p{   color:#; font-size:"#";  }hr{width:220px;}</style><body><br><br><h1><br>标题<br></h1><br><br><hr><br><br><p>正文的段落</p>版权所有<br><br><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"position":"right","width":150,"height":300,"jsonPath":"/live2dw/assets/assets/shizuku.model.json"},"mobile":{"show":true}});</script></body></blockquote><h4 id="2、类别选择器"><a href="#2、类别选择器" class="headerlink" title="2、类别选择器"></a>2、类别选择器</h4><blockquote><p><code>printf()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">&gt; p&#123; font-size:12px;&#125;</span><br><span class="line">&gt; .one&#123; font-size:13px;&#125;</span><br><span class="line">&gt; .two&#123; font-size:14px;&#125;</span><br><span class="line">&gt; &lt;/style&gt;</span><br><span class="line">&gt; &lt;body&gt;</span><br><span class="line">&gt; &lt;p class=&quot;one&quot;&gt;类型1&lt;/p&gt;</span><br><span class="line">&gt; &lt;p class=&quot;two&quot;&gt;类型2&lt;/p&gt;</span><br><span class="line">&gt; &lt;p class=&quot;three&quot;&gt;类型3&lt;/p&gt;</span><br><span class="line">&gt; &lt;p class=&quot;four&quot;&gt;类型4&lt;/p&gt;</span><br><span class="line">&gt; &lt;p class=&quot;five&quot;&gt;类型5&lt;/p&gt;</span><br><span class="line">&gt; &lt;p&gt;普通的段落文字&lt;/p&gt;</span><br><span class="line">&gt; &lt;/body&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3、ID选择器"><a href="#3、ID选择器" class="headerlink" title="3、ID选择器"></a>3、ID选择器</h4><p><code>printf()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    #one&#123;font-size:12px;&#125;</span></span><br><span class="line"><span class="undefined">    #two&#123;font-size:24px;&#125; </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>文字1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>文字2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4、嵌套声明"><a href="#4、嵌套声明" class="headerlink" title="4、嵌套声明"></a>4、嵌套声明</h4><p><code>printf()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    p span&#123;</span></span><br><span class="line"><span class="undefined">        color:#;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>学习<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5、文本样式格式"><a href="#5、文本样式格式" class="headerlink" title="5、文本样式格式"></a>5、文本样式格式</h4><table><thead><tr><th>属性</th><th>描 述</th><th style="text-align:left">取值</th></tr></thead><tbody><tr><td><strong>color</strong></td><td><strong>文本颜色</strong></td><td style="text-align:left">red #f00</td></tr><tr><td><strong>letter-spacing</strong></td><td><strong>字符间距</strong></td><td style="text-align:left">2px、3px</td></tr><tr><td><strong>line-height</strong></td><td><strong>行高</strong></td><td style="text-align:left">14px  1.5em  120%</td></tr><tr><td><strong>text-align</strong></td><td><strong>对齐</strong></td><td style="text-align:left"><strong>center  left  right  justify</strong></td></tr><tr><td><strong>text-decoration</strong></td><td><strong>装饰线</strong></td><td style="text-align:left"><strong>none  overline  underline  line-though</strong></td></tr><tr><td><strong>text-indent</strong></td><td><strong>首行缩进</strong></td><td style="text-align:left"><strong>2em</strong></td></tr></tbody></table><h4 id="6、背景设置"><a href="#6、背景设置" class="headerlink" title="6、背景设置"></a>6、背景设置</h4><h5 id="1、背景属性"><a href="#1、背景属性" class="headerlink" title="1、背景属性"></a>1、背景属性</h5><p>空元素需要先定义元素的高度和宽度</p><p><strong>background-color</strong></p><p><strong>background-image–背景图片</strong>    url(“logo.jpg”)</p><p><strong>background-repecat–背景图片的填充方式</strong>   repeat    repeat-x(横向填充)   repeat-y(纵向填充)    no-repeat(填充一次)</p><p><strong>bacground</strong></p><h5 id="2、CSS超链接"><a href="#2、CSS超链接" class="headerlink" title="2、CSS超链接"></a>2、CSS超链接</h5><p>超链接的四种状态</p><blockquote><p><strong>a:link </strong> 普通的、未被访问的链接</p><p><strong>a:visited</strong>  用户已经访问的链接</p><p><strong>a:hover</strong>  鼠标指针位于链接的上方悬停</p><p><strong>a:active</strong>   链接被点击的时刻</p></blockquote><p>:伪类选择器</p><p><strong>顺序</strong></p><p><strong>a:hover</strong>  必须位于a:link 和a:visited之后</p><p><strong>a:active</strong>  必须位于a:hover之后</p><h5 id="3、列表样式"><a href="#3、列表样式" class="headerlink" title="3、列表样式"></a>3、列表样式</h5><blockquote><p>life-style     <strong>所有用于列表的属性设置于一个声明之中</strong></p><p>list-style-image  <strong>为列表项标志设置图像</strong></p><p>list-style-position  <strong>标志的位置</strong></p><p>list-style-type   <strong>标志的类型</strong></p></blockquote><p>无序列表<strong>ul</strong>和有序列表<strong>ol</strong></p><h5 id="4、表格的样式"><a href="#4、表格的样式" class="headerlink" title="4、表格的样式"></a>4、表格的样式</h5><p><strong>表格大小 属性  width(宽),height(高)</strong></p><p><code>printf()</code></p><p>table{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">width:500px;</span><br><span class="line"></span><br><span class="line">height:200px;</span><br></pre></td></tr></table></figure><p>}</p><p><strong>表格边框属性boder</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table,td,th&#123;</span><br><span class="line">boder:1px solidn#eee</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>td标签—单元格的样式</strong></p><p><strong>th标签—表头的样式</strong></p><p>另一个属性 boder-collapse —<strong>内外边框重叠问题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table&#123;</span><br><span class="line">boder-collapse:collapse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、CSS表格–奇偶选择器-nth-child-odd-even"><a href="#5、CSS表格–奇偶选择器-nth-child-odd-even" class="headerlink" title="5、CSS表格–奇偶选择器  :nth-child(odd|even)"></a>5、CSS表格–奇偶选择器  :nth-child(odd|even)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tr:nth-child(odd)</span><br><span class="line">background-color:#EAF2D3;</span><br></pre></td></tr></table></figure><hr><h2 id="四、CSS布局和定位问题"><a href="#四、CSS布局和定位问题" class="headerlink" title="四、CSS布局和定位问题"></a>四、CSS布局和定位问题</h2><h4 id="1、盒子模型"><a href="#1、盒子模型" class="headerlink" title="1、盒子模型"></a>1、盒子模型</h4><p>概念</p><p>页面上的区域、图片、导航、列表、段落都可以是盒子</p><p><strong>除了content之外其他的都是属性的名字</strong></p><blockquote><html><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&gt;    #box&#123;</span></span><br><span class="line"><span class="undefined">&gt;        width:100px;</span></span><br><span class="line"><span class="undefined">&gt;        height:100px;</span></span><br><span class="line"><span class="undefined">&gt;        border:1px solid;</span></span><br><span class="line"><span class="undefined">&gt;        padding:20px;</span></span><br><span class="line"><span class="undefined">&gt;        margin:10px;</span></span><br><span class="line"><span class="undefined">&gt;    &#125;</span></span><br><span class="line"><span class="undefined">&gt; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">&gt; 你猜啊</span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></html></blockquote><blockquote><p></p></blockquote><h4 id="2、盒子属性"><a href="#2、盒子属性" class="headerlink" title="2、盒子属性"></a>2、盒子属性</h4><blockquote><p><strong>border-width: px  thin  medium  thick</strong></p><p><strong>border-style:dashaed<a href="虚线">^注释2</a>  dotted<a href="由点组成的线">^注释3</a>  solid<a href="普通实线">^注释4</a>   double<a href="双实线">^注释5</a></strong></p><p><strong>border-color: 颜色</strong></p><p><strong>border:width  style  color</strong></p></blockquote><h2 id="五、CSS定位机制"><a href="#五、CSS定位机制" class="headerlink" title="五、CSS定位机制"></a>五、CSS定位机制</h2><p><strong>概述：就是盒子的位置</strong></p><blockquote><p><strong>三种定位机制</strong></p><p><strong>1、文档流 flow定位</strong>：默认的方式</p><p><strong>2、浮动 float定位</strong>：设置float属性</p><p><strong>3、层定位 layer</strong>：设置position属性</p></blockquote><h4 id="1、文档流定位"><a href="#1、文档流定位" class="headerlink" title="1、文档流定位"></a>1、文档流定位</h4><h5 id="1、元素分类"><a href="#1、元素分类" class="headerlink" title="1、元素分类"></a>1、元素分类</h5><blockquote><p><strong>block类型</strong>：<strong>每个此类型的元素都要独占一行</strong></p><p>常见的<strong>block</strong>元素有：<div> <p> </p><h1>···<h6> <ol> <ul> <table> <form></form></table></ul></ol></h6></h1></div></p><p><strong>inline类型 : 每个元素不单独占一行，且width  height不可设置</strong></p><p>常见的<strong>inline</strong>元素有：<span>  <a>      </a></span></p><p><strong>–显示为inline元素  display:inline–</strong></p><p><strong>inline-block类型 :  不单独占据一行，但是可以改变设置</strong></p><p>常见的<strong>inline-block</strong> 元素有：<img></p></blockquote><h5 id="2、元素转换类型"><a href="#2、元素转换类型" class="headerlink" title="2、元素转换类型"></a>2、元素转换类型</h5><p><strong>display类型</strong></p><h4 id="2、浮动定位"><a href="#2、浮动定位" class="headerlink" title="2、浮动定位"></a>2、浮动定位</h4><p><strong>float属性</strong></p><blockquote><div><br>width:200px;<br>height:200px;<br>boder:1px solid red;<br>float:left;<br></div></blockquote><h4 id="3、层定位"><a href="#3、层定位" class="headerlink" title="3、层定位"></a>3、层定位</h4><p><strong>概述</strong></p><p>像图象软件中的图层一样可以对每个layer进行能够精准定位操作</p><blockquote><p><strong>position 属性</strong>：<strong>（相对于谁定位）</strong></p><p><strong>fixed  固定定位</strong> ：相对于浏览器窗口进行定位</p><p><strong>relative   相对定位</strong> ：相对于直接父元素进行定位</p><p><strong>absotive  绝对定位</strong> ：相对于static定位意外的第一个父元素</p></blockquote><h2 id="六、CSS3续篇"><a href="#六、CSS3续篇" class="headerlink" title="六、CSS3续篇"></a>六、CSS3续篇</h2><h4 id="1、圆角边框和阴影"><a href="#1、圆角边框和阴影" class="headerlink" title="1、圆角边框和阴影"></a>1、圆角边框和阴影</h4><h4 id="2、文字与文本"><a href="#2、文字与文本" class="headerlink" title="2、文字与文本"></a>2、文字与文本</h4><blockquote><p><strong>text-shadow属性</strong> ：文本阴影</p><p><strong>–水平偏移   垂直偏移    阴影大小   颜色–</strong></p><p><strong>text-wrap属性</strong> ：允许单词、url强制进行换行</p><p><strong>–normal 属性–</strong></p><p><strong>–break-word 属性–</strong></p><p><strong>@font-face属性</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="https://albert-5.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="https://albert-5.github.io/tags/css/"/>
    
      <category term="前端" scheme="https://albert-5.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
