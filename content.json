{"meta":{"title":"Albert","subtitle":null,"description":"欢迎光顾本站~","author":"albert","url":"https://albert-5.cn","root":"/"},"pages":[{"title":"Music","date":"2019-04-27T03:22:49.000Z","updated":"2019-09-30T01:13:18.928Z","comments":true,"path":"Music/index.html","permalink":"https://albert-5.cn/Music/index.html","excerpt":"","text":"2019-04-27 2019-05-03"},{"title":"Desktop","date":"2019-04-27T04:47:05.000Z","updated":"2019-06-21T07:16:53.739Z","comments":true,"path":"desktop/index.html","permalink":"https://albert-5.cn/desktop/index.html","excerpt":"","text":"VIDEOS(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"indigo\",\"loop\":true,\"screenshot\":\"yes\",\"video\":{\"url\":\"http://pss3kkkhb.bkt.clouddn.com/albert.mp4\"},\"danmaku\":{\"id\":\"9E2E3368B5SDFDF387GF\",\"api\":\"https://api.prprpr.me/dplayer/\",\"addition\":[\"https://api.prprpr.me/dplayer/bilibili?aid=8520345\"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() LEARN@card{ 编程语言 Python c语言 待入门 Java } SOURCES@card{ #FADFA3 待添加 } ENTERTAIN@column-3{ @card{ 游戏1 红色警戒 } @card{ 游戏2 和平精英（菜鸡） } @card{ 游戏3 刺客信条 } } 共享资源"},{"title":"Books","date":"2019-04-29T07:21:56.000Z","updated":"2019-04-29T07:25:03.379Z","comments":true,"path":"books/index.html","permalink":"https://albert-5.cn/books/index.html","excerpt":"","text":""},{"title":"Games","date":"2019-04-29T07:22:22.000Z","updated":"2019-04-29T07:25:17.477Z","comments":true,"path":"games/index.html","permalink":"https://albert-5.cn/games/index.html","excerpt":"","text":""},{"title":"Picture","date":"2019-04-27T04:47:25.000Z","updated":"2019-05-02T08:15:50.843Z","comments":true,"path":"picture/index.html","permalink":"https://albert-5.cn/picture/index.html","excerpt":"","text":"记录生活 分享感动 🎞️ Images@blockquote{ @card{"},{"title":"关于我们","date":"2019-10-27T03:53:48.000Z","updated":"2019-10-27T07:03:31.979Z","comments":true,"path":"关于我们/index.html","permalink":"https://albert-5.cn/关于我们/index.html","excerpt":"","text":"@blockquote{ @card{ 🤟 关于我们} } @blockquote{ @card{ ✏️ We Do} } @blockquote{ @card{ 📚 Recording@timeline{ 2019@item{ 10月19日难忘的一天 📅 } @item{ 10月20日确认关系的一天 🌈 } @item{ 10月26日第一次一起看电影 🎞️ } } } }"},{"title":"关于我","date":"2019-04-27T04:47:43.000Z","updated":"2019-10-27T03:59:17.175Z","comments":true,"path":"about/index.html","permalink":"https://albert-5.cn/about/index.html","excerpt":"","text":"@blockquote{ @card{ 🏛️关于小站🧐hi~，大家好，我是albert，欢迎你来到我的小站！准确的说，这是我的第一站，记录、分享是我建站的目的；关于小站Logo，那是一位科学家，有着卓越的能力，代表着前沿科学技术，同时呢，也代表着大国工匠精神，也是个人的一种理想吧！！ } } @blockquote{ @card{ ♓关于我 albert，英文名取自于Iron Man中的主人公 Robert Downey Jr.,同时也是聪明、勇敢的象征； 目前本科在读，乐意结交有灵魂者； 爱好：摄影、科幻、运动、旅游 世界这么大，想出国✈️转转… } @blockquote{ @card{ 🌐交流 音乐 📻 网易云音乐 🎵 QQ音乐 🎶 邮箱 📭 QQ邮箱 📮 Gmail 📧 赞赏 💰 支付宝 💵 微信 💶 待添加··· 我的相册 📷 相册 🎞️ 其他 ℹ️ 豆瓣小家 📇 } } @blockquote{ @card{ 📝更新日志@timeline{ 2019@item{ 4月22日弃用jekyll，改用hexo+githubpages搭建博客 } @item{ 4月23日完成博客基础配置，邮箱、微博、github··· } @item{ 4月24日增加支付打赏功能，目前仅支持支付宝、微信 } @item{ 4月25日添加鼠标点击特效 } @item{ 4月26日增加music、film、book、camera页面 } @item{ 4月27日在music页面下借助aplayer创建音乐歌单 } @item{ 4月28日seo优化，收录于Google } @item{ 4月29日增加文章置顶功能 } @item{ 5月1日新增图床，减少加载时间 } @item{ 5月2日利用HTML5 UP模板建立相册并分类化处理 } @item{ 5月17日在阿里云网站上购买域名albert-5.cn } @item{ 5月20日.cn 域名实名认证成功并顺利使用 } @item{ 5月21日为网站添加绿锁头，还是绿的好看;点击预览 } @item{ 6月2日增加网站管家&lt;小老婆&gt; } } } }"},{"title":"Categories","date":"2019-04-28T09:19:42.000Z","updated":"2019-04-28T09:53:07.675Z","comments":false,"path":"categories/index.html","permalink":"https://albert-5.cn/categories/index.html","excerpt":"","text":""},{"title":"Movies","date":"2019-04-29T07:22:07.000Z","updated":"2019-04-29T07:25:29.190Z","comments":true,"path":"movies/index.html","permalink":"https://albert-5.cn/movies/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-04-28T09:19:21.000Z","updated":"2019-04-28T09:48:42.643Z","comments":false,"path":"tags/index.html","permalink":"https://albert-5.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"快捷键","slug":"快捷键","date":"2019-10-01T14:34:01.000Z","updated":"2019-10-01T14:38:27.146Z","comments":true,"path":"2019/10/01/快捷键/","link":"","permalink":"https://albert-5.cn/2019/10/01/快捷键/","excerpt":"","text":"Photoshop常用快捷键收 工具快捷键 动作 Mac windows 选择工具 V V 矩形/椭圆工具 M M 套索工具 W W 剪裁/切片工具 C C 滴管/取色/标尺/注释/计数工具 I I 修复画笔/修补/红眼工具 J J 画笔/铅笔/颜色替换工具 B B 图章工具 S S 历史记录画笔工具 Y Y 橡皮擦工具 E E 渐变/油漆桶工具 G G 减淡/加深/海绵工具 O O 钢笔工具 P P 文字工具 T T 选择工具 A A 矩形/椭圆/多边形/直线/自定义形状工具 U U 3D对象工具 K K 3D相机工具 N N 抓手工具 H H 旋转视图工具 R R 缩放工具 Z 图像菜单 动作 Mac Windows 调整-色阶 Cmd+L Ctrl+L 调整-曲线 Cmd+M Ctrl+M 调整-色相、饱和度 Cmd+U Ctrl+U 调整-色彩平衡 Cmd+B Ctrl+B 调整-黑白 Opt+Shift+Cmd+B Alt+Shift+Ctrl+B 调整-反相 Cmd+I Ctrl+I 去色 Shift+Cmd+U Shift+Ctrl+U 自动色调 Shift+Cmd+L Shift+Ctrl+L 自动对比度 Opt+Shift+Cmd+L Alt+Shift+Ctrl+L 自动颜色 Shift+Cmd+B Shift+Ctrl+B 图像大小 Opt+Cmd+I Alt+Ctrl+I 画布大小 Opt+Cmd+C Alt+Ctrl+C 记录测量 Shift+Cmd+M Shift+Ctrl+M 新建-图层 Shift+Cmd+N Shift+Ctrl+N 新建-通过拷贝的图层 Cmd+J Ctrl+J 新建-通过剪切的图层 Shift+Cmd+J Shift+Ctrl+J 创建剪贴蒙板 Opt+Cmd+G Alt+Ctrl+G 图层编组 Cmd+G Ctrl+G 取消图层编组 Shift+Cmd+G Shift+Ctrl+G 排列-置为顶层 Shift+Cmd+] Shift+Ctrl+] 排列-前移一层 Cmd+] Ctrl+] 排列-后移一层 Cmd+[ Ctrl+[ 排列-置为底层 Shift+Cmd+[ Shift+Ctrl+[ 向下合并 Cmd+E Ctrl+E 合并可见图层 Shift+Cmd+E Shift+Ctrl+E","categories":[{"name":"工具","slug":"工具","permalink":"https://albert-5.cn/categories/工具/"}],"tags":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://albert-5.cn/tags/Photoshop/"}]},{"title":"国内访学与发展规划","slug":"国内访学与发展规划","date":"2019-09-05T15:43:40.000Z","updated":"2019-09-08T07:14:45.738Z","comments":true,"path":"2019/09/05/国内访学与发展规划/","link":"","permalink":"https://albert-5.cn/2019/09/05/国内访学与发展规划/","excerpt":"","text":"关于国内访学的思考以及个人发展规划国内访学因为幸运我有机会去了别人家的大学，国内一所985、211以及双一流院校。大二参加了国内的访学项目并在此期间到合作学校进行为期一年的学习，这就意味着，我将离开刚刚熟悉的大学新校园，转而到另一所新大学去学习，一切都需要重新适应和改变，而且将会认识更多的同学，同时还将意味着我能够接受到更多优质的学习资源、遇到更多优秀的同学，努力提升自己成为一个优秀的人。 去年今日，我正在新的校园里畅游、徘徊，因为我想好好看看她（渴望而不可及的大学）到底是什么样子，和我的这个学校有什么不同吗？到底是什么魔力吸引着无数高考生的目光，使其奋进全力去考？而我到底值不值在这花费一年的时间来在此学习？ 校园里，有行驶着的来往汽车，有独自一人背着双肩包听着音乐的过路人，也有人成群结队嘻闹的同学，也有着滑着滑板穿梭在人群中的人······那是青春活力的展现，国家未来的希望；教室里，有人敲到着手机，探索着虚拟空间的奥秘，有人专注的翻阅着自己的课本，畅游在高数大物的海洋里，也有人在朗朗地背书，求知求实。这些看起来和我们学校确实没有什么不同，但是上过课之后就会有更多的感受，老师上课时对问题的仔细讲解，老师对学生的那种要求：大一就开始论文写作锻炼，大一就开始参加各种各样的比赛，导师的指导和教诲恐怕让人受益匪浅，或许一两年之后学生出来发表的都是science一星二星文章，而我们还不知发表论文这回事，这也说明人家的起点高，所要到达的高度也是我们所望尘莫及的，更有甚者，他们有的课程都是论文写作培训、比赛训练之类的，无不让人羡慕；另外，他们有更广的眼界，有着更多的机会去接触所谓的大V，科技讲座、人工智能峰会（论坛）······ 但是，反过来想，这是我自己的问题，必须由我来解决！ 国内的访学项目真的是拓宽了我的视野，不仅仅体验了那种浓浓的学习氛围、享受到了一些优质资源、认识了一堆学霸朋友，更多的是自身能力与那些“学霸”们之间的差距和不足的认识。一年下来，虽在自己的学校是所谓的“好学生”，其实到头来你啥也不是，唯有自己努力提升各项能力才有机会与此较横！ 发展规划回想在交换的一年时光，GPA属实高不就，甚至感觉有点浪费这个交换名额，各科成绩都没有在本校的高，比赛也没有参加几个，得到的一些奖都无法走上台面，在本校的实验室任务项目也都没能参加，自学的机器学习相关知识也很难掌握，需要时间去理解和实践。过去的也就只能过去了，如今的我大学生涯已经过半，若不继续努力恐怕前程会有点上头。这一年的时间，我想弥补前些时间的过错和不足： 编程方向仍以python为主，C语言为辅，主要工作是python数学科学和算法，进阶是机器学习和自然语言处理； 专业课程学习还是需要下一定功夫，预习复习、上课笔记 娱乐兴趣就是摄影、摄像以及后期，用影像去记录生活","categories":[{"name":"college","slug":"college","permalink":"https://albert-5.cn/categories/college/"}],"tags":[{"name":"思考反思","slug":"思考反思","permalink":"https://albert-5.cn/tags/思考反思/"}]},{"title":"网络技术笔记","slug":"网络技术笔记","date":"2019-08-01T09:34:41.000Z","updated":"2019-10-20T12:12:46.627Z","comments":true,"path":"2019/08/01/网络技术笔记/","link":"","permalink":"https://albert-5.cn/2019/08/01/网络技术笔记/","excerpt":"","text":"网络技术Chapter 1 基础知识1. 计算机网络的分类1.1. 局域网(Local Area Network LAN)特点： 局域网覆盖有限的地理范围，使用于机关、学校、有限范围的计算机、终端与各类信息处理设备联网的需求 提供传输效率(10Mbps~10Gbps),支持高码率、高质量传输环境 一般属于一个单位所有，易建立、维护和扩展 另一角度： 从介质访问方法的角度看，局域网可以分为共享介质式局域网与交换式局域网；从使用的传输介质类型的角度，又可以分为有限介质的有限局域网和无线局域网。 技术发展的三个方向： 提高以太网的数据传输速率 将一个大型局域网划分成多个用网桥或者路由器互联的网络 将共享介质方式改为交换方式(在交换式局域网的基础上，出现了虚拟局域网VLAN) 1.2. 城域网(Metropolitan Area Network MAN)概念：城市区域网络简称城域网，介于广域网和局域网之间的一种高速网络。目的是为了满足几十公里范围内的大量企业、机关、公司的多个局域网的互联要求，实现大量用户之间的数据、语音、图形的传输 1.3. 广域网又叫远程网，覆盖范围从几十公里到几千公里。可以覆盖几个国家或地区，甚至横跨几个洲，从而形成国际性的远程计算机网络(分组交换网、卫星通讯网和无线分组网实现) 计算机网络结构2.1. 早期的广域网结构上分成两部分：负责数据处理的计算机终端；负责数据通信的通信控制处理设备与通信线路 逻辑功能上分成两部分：资源子网和通信子网 资源子网由计算机系统、终端、终端控制器、连接外部设备、各类软件资源与信息资源组成；资源子网负责全网的数据处理业务，负责向网络用户体统各类网络资源和网络服务。 2.2. 用户计算机接入用户计算机可以通过局域网方式接入，也可以选择电话交换网(PSTN)、有线电视网（CATV）、无线城域网（WMAN）或无线局域网（WLAN）方式接入到作为地区级主干网的城域网。城域网又通过路由器与光纤接入到作为国家级或区域级主干网的广域网。多个广域网互联形成覆盖全世界的Internet系统 实训任务1. 任务一：宽带城域网的结构 宽带城域网的逻辑结构 设计一个宽带城域网将涉及三个平台和一个出口，即网络平台、业务平台、管理平台和城市宽带出口 网络平台的层次结构 网络平台的层次结构又可以分为：核心层、汇聚层、接入层 核心层主要承担高速数据的交换的功能，汇聚层主要承担路由和流量汇聚的功能，接入层主要承担用户接入和本地流量控制的功能。 核心交换层的功能 核心交换层将多个汇聚层连接在起来，为汇聚层的网络提供高速分组转发，为整个城市提供一个高速、安全与具有QoS保障能力的数据传输环境 核心交换层实现与主干网络的互联，提供城市的宽带IP出口 核心交换层提供宽带城域网的用户访问internet所需要的路由访问 汇聚层的基本功能 汇聚层的用户流量进行数据分组传输的汇聚、转发和交换 根据接入层的用户流量进行本地路由、过滤、流量均衡、QoS优先级管理以及安全控制、IP地址转换、流量整形等处理 根据处理结果把用户流量转发到核心层或本地进行路由处理` 接入层的基本功能 接入层的最后一公里问题，通过各种接入技术，连接最终用户，为它所覆盖范围内的永辉提供访问Internet以及其他信息服务 三层结构的基本思想是上层负责下层的数据汇聚、核心提供出口与QoS、汇聚本地路由、接入服务用户 2. 实训任务二：管理和运营宽带城域网的关键技术管理和运营宽带城域网的关键技术主要是：带宽管理、服务质量QoS、网络管理、用户管理、多业务接入、统计与计费、IP地址的分配和地址转换、网络安全 目前宽带城域网保证服务质量QoS要求的关键技术主要有资源预留(RSVP)、区分服务(DiffeServ)与多协议标记交换MPLS 宽带城域网带内网络管理是指利用数据通信网(DCN)、公共交换电话网(PSTN)、对网络设备进行数据配置。带宽网络管理是指利用网络协议(SNMP)建立网络管理系统 3. 实训任务三：基于10GE的城域网方案用于宽带城域网的光以太网有多种实现形式，其中最为重要的有两种：基于10GE的技术和弹性分组环技术。 10Gbps光以太网的技术优势主要表现在一下几个方面： 以太网与DMDW技术都十分成熟，并且已经广泛使用，组建相同规模的宽带城域网，光以太网额造价是SONET的1/5，是ATM的1/10 光以太网的特征 能够根据终端用户的实际应用需求分配带宽，保证带宽资源充分合理的应用 具有认证和授权功能，用户访问网络资源必须经过认证和授权，确保用户和网络资源的合法性 提供计费功能，能及时获得用户的上网时间记录和流量记录，支持按上网时间、用户流量或者包月计费方式、支持实时计费等 支持VPN和防火墙，有效保证网络安全 支持MPLS，具有一定的服务质量保证，提供分等级的QoS网络服务 弹性分组环RPR技术的城域网 一种直接的高效传输IP分组的传输技术，基础是Cisco公司提出的动态分组技术(DPT)技术 RPR将沿顺时针传输光纤叫做外环，将沿逆时针传输的光纤叫做内环。弹性分组环RPR的内环和外环都可以同统计复用的方法传输IP分组，同时可以实现“自愈环”的功能。RPR的内环和外环都可以传输数据分组与控制分组。每一个节点都可以使用两个方向的光纤与近邻节点通信。这样做的目的除了高效地利用光纤带宽之外，还有一个目的是加速控制分组传输，提高环的可靠性，实现“环自愈”功能，保证城域网的系统可靠性与服务质量。 RPR技术主要特点 带宽的占用率高 传统额FDDI环网中，当源结点向目的结点成功地发送一个数据帧之后这个数据帧要由源结点中从环收回；而RPR环限制数据帧只在源节点与目的节点之间的光纤段上传输，当源结点成功地发送一个数据帧之后，这个数据帧要由目的结点从环中收回，这样就提高了环带宽的利用率； 公平性好 RPR环中每个结点都执行SRP公平算法，使得结点之间能够获得平等的带宽，防止个别结点因流量大而造成环拥堵。 快速保护和恢复能力强 RPR采用自愈环的设计思想，能够在50ms的时间内，隔离出现故障的节点和光纤段，提供SDH级快速保护和恢复，同时不需要像SDH那样必须有专用的带宽； 保证服务质量QoS 四网融合 计算机网络、电信通信网、电视通信网以及物联网 4. 实训任务四：宽带接入技术的基本类型接入技术可以分为有线接入和无线接入两种；从实现技术的角度，目前宽带接入技术主要有以下几种：数字用户线xDSL、光纤同轴电缆混合网HFC技术、光纤接入技术、无线接入技术与局域网接入技术。其中无线接入又可以分为无线局域网接入、无线城域网接入与无线Ad hoc接入。 数字用户线xDSLjishu 数字用户环路，数字用户线是从用户到本地电话交换中心的一对铜双绞线，本子电话交换中心又叫做中心局；xDSL技术按上行(用户到交换局)和下行(交换局到用户)的速率是否相同分为速率对称性和速率非对称性两种 非对称数字用户线(ADSL Asymmetric Digital Subscriber Line) 高比特率数字用户线(HDSL) 速率自适应数字用户线(RADSL) 甚高比特率数字用户线(VDSL) ADSL(非对称数字用户线)主要特点 在现有电话铜双绞线上，以重叠不干扰传统模拟电话业务，即普通电话业务POTS的方式，提供高速数字业务。ADSL允许用户保留他们已经申请的模拟电话业务，可以支持用户在电话铜双绞线上的新型宽带业务。 用户不需要专门为获得ADSL服务而重新铺设电缆 提供额非对称宽带特性，上行速率在64 kbps~640 kbps,下行速率在500 kbps~7 Mbps。用户可以根据需要选择上行和下行速率。 宽带无线接入技术 无线接入技术主要有：802.11标准的无线局域网(WLAN)接入、802.16标准的无线城域网(WMAN)接入、Ad hoc接入技术，在无线宽带接入网的结构中，远距离采用802.16标准的WiMAX技术，可以在50km范围内提供70Mbps的传输速率； 802.16标准与无线城域网WMAN IEEE802.16标准体系的主要目标是制定工作在2~66MHz频率段的无线接入系统的物理层与介质访问控制MAC子层规范；在802.16标准增加了两个物理层标准的16d与16e，16d主要针对固定的无线网络部署，16e主要针对火车、汽车等移动物体的无线通信标准问题 802.11标准与无线局域网WLAN 定义了使用红外、调频扩频与直接序列扩频技术，传输速率为1Mbps或者2Mbps的无线局域网标准；11b定义了使用直接序列扩频技术，速率在1、2、5.5\\11Mbps;11a将传输速率提高到54Mbps","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.cn/categories/学习笔记/"}],"tags":[{"name":"计算机三级","slug":"计算机三级","permalink":"https://albert-5.cn/tags/计算机三级/"},{"name":"网络技术","slug":"网络技术","permalink":"https://albert-5.cn/tags/网络技术/"}]},{"title":"豆瓣电影top250","slug":"豆瓣电影top250","date":"2019-08-01T09:32:58.000Z","updated":"2019-08-01T09:34:11.547Z","comments":true,"path":"2019/08/01/豆瓣电影top250/","link":"","permalink":"https://albert-5.cn/2019/08/01/豆瓣电影top250/","excerpt":"","text":"豆瓣电影Top 250原理方法使用的模块chardet模块—判断编码 1Pip install chardet 使用上述命令安装模块 123456789101112131415#如果你的python没有安装chardet模块，你需要首先安装一下chardet判断编码的模块哦import chardetimport urllib#先获取网页内容data = urllib.urlopen('http://www.pythontab.com').read()#用chardet进行内容分析chardit = chardet.detect(data) data1 = urllib.urlopen('http://www.baidu.com').read() chardit1 = chardet.detect(data1) print chardit['encoding'] # pythontab print chardit1['encoding'] # baidu BeautifulSoup库 安装bs4模块 1pip install beautifulsoup4 代码使用 12345from bs4 import BeautifulSoupimport requestsurl = \"\"html = requests.get(url)soup = BeautifulSoup(html, 'html.parser') find_all()方法返回文档中符合条件的所有tags，尽管有时候我们只想得到一个结果。比如文章中只有一个标签，那么使用find_all()方法来查找标签不太合适了使用find_all()方法设置limit=1参数不如直接使用find()方法L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"position\":\"left\",\"width\":150,\"height\":300,\"jsonPath\":\"/live2dw/assets/assets/shizuku.model.json\"},\"mobile\":{\"show\":false}}); 12345&gt; soup.find_all('title', limit=1)&gt; # [&lt;title&gt;The Story&lt;/title&gt;]&gt; soup.find('title')&gt; # [&lt;title&gt;The Story&lt;/title&gt;]&gt; 唯一的区别是find_all()方法返回的结果是只包含一个元素的列表，而find()方法直接返回结果；find_all()方法没有找到指定元素时返回空列表，而find()方法找不到目标时返回None 拓展 关于find_all()和find()方法的介绍 find() 1find(name, attrs, recursive, text, **wargs) # recursive 递归的，循环的 这些参数相当于过滤器一样可以进行筛选处理。不同的参数过滤可以应用到以下情况： 查找标签，基于name参数 查找文本，基于text参数 基于正则表达式的查找 查找标签的属性，基于attrs参数 基于函数的查找 通过标签查找： 可以传递任何标签的名字来查找到它第一次出现的地方。找到后，find函数返回一个BeautifulSoup的标签对象。 123456from bs4 import BeautifulSoupwith open('ecologicalpyramid.html', 'r') as ecological_pyramid: soup = BeautifulSoup(ecological_pyramid, 'html')producer_entries = soup.find('ul')print(type(producer_entries)) 输出结果： 通过文本查找： 直接字符串的话，查找的是标签。如果想要查找文本的话，则需要用到text参数。如下所示： 123456from bs4 import BeautifulSoupwith open('ecologicalpyramid.html', 'r') as ecological_pyramid: soup = BeautifulSoup(ecological_pyramid, 'html')producer_string = soup.find(text = 'plants')print(plants_string) 输出：plants 通过正则表达式查找： 想找出第一个邮箱地址，但是第一个邮箱地址没有标签包含，所以通过其他方式很难找到。但是可以将邮箱地址进行正则表达式处理。 1234567891011121314import refrom bs4 import BeautifulSoupemail_id_example = \"\"\"&lt;br/&gt;&lt;div&gt;The below HTML has the information that has email ids.&lt;/div&gt; abc@example.com &lt;div&gt;xyz@example.com&lt;/div&gt; &lt;span&gt;foo@example.com&lt;/span&gt; \"\"\"soup = BeautifulSoup(email_id_example)emailid_regexp = re.compile(\"\\w+@\\w+\\.\\w+\") # regexp 表达式对象first_email_id = soup.find(text=emailid_regexp) print(first_email_id) 输出结果：abc@example.com 通过标签属性进行查找： 上面html代码，其中第一个消费者在ul标签里面且id属性为priaryconsumer（priary consumer一次消费者，初级消费者）。 123456from bs4 import BeautifulSoupwith open('ecologicalpyramid.html', 'r') as ecological_pyramid: soup = BeautifulSoup(eccological_pyramid, 'html')primary_consumer = soup.find(id='primaryconsumers')print(primary_consumer.li.div.string) 输出结果：deer 基于定制属性查找： 通过标签属性查找的方式适用大多数标签属性，包括id，style，title，但有 “-”，Class标签属性例外。 比如html5标签中的data-custom属性，如果我们这样 12345customattr = \"\"\"&lt;p data-custom='custom'&gt;custo attributeexample&lt;/p&gt;\"\"\"customsoup = BeautifulSoup(customattr, 'lxml')customSoup.find(data-custom=\"custom\") 那么则会报错。原因是在python中变量不能含有”-“这个字符，而我们传递的data-custom有这个字符。 解决办法是在attrs属性用字典进行传递参数。 12using_attrs = customsoup.find(attrs=&#123;'data-custom':'custom'&#125;)print(using_attrs) 基于css类的查找： class是python的保留关键字，所以无法使用class这个关键字。 第一种方法：在attrs属性用字典进行传递参数 12css_class = soup.find(attrs=&#123;&apos;class&apos;:&apos;primaryconsumers&apos;&#125;)print(css_class) 第二种方法：BeautifulSoup中的特别关键字参数class_。 1css_class = soup.find(class_ = &apos;primaryconsumers&apos;) 基于定义的函数进行查找： 可以传递函数到find()来基于函数定义的条件查找。函数必须返回True或False。 1234def is_secondary_consumers(tag): return tag.has_attr('id') and tag.get('id') == 'secondaryconsumers'secondary_consumer = soup.find(is_secondary_consumers)print(secondary_consumer.li.div.string) 输出：fox 将方法进行组合后进行查找： 可以用其中任何方法进行组合进行查找，比如同时基于标签名和id号。 find_all()函数 1find_all(name, attrs, recursive, text, limit, **kwargs) limit参数可以限制得到的结果的数目。 参照前面的邮件地址例子，得到所有邮件地址： 12email_ids = soup.find_all(text=emailid_regexp)print(email_ids) 输出结果：[u&#39;abc@example.com‘,u&#39;xyz@example.com‘,u&#39;foo@example.com‘] 使用limit参数： 12email_ids_limited = soup.find_all(text=emailid_regexp, limit = 2)print(email_ids_limited) 限制得到两个结果，所以输出结果：[u&#39;abc@example.com‘,u&#39;xyz@example.com‘] 可以向find函数传递True或False参数，如果传递True给find_all()，则返回soup对象的所有标签。对于find()来说，则返回soup对象的第一个标签。 12all_texts = soup.find_all(text=True)print(all_texts) 同样，可以在传递text参数时传递一个字符串列表，那么find_all()会找到挨个在列表中定义过的字符串。 12all_texts_in_list = soup.find_all(text=['plants', 'algae'])print(all_texts_in_list) 输出结果： 1[u'plants', u'alage'] 这个同样适用于查找标签，标签属性，定制属性和CSS类。如： 1div_li_tags = soup.find_all(['div', 'li']) 并且find()和find_all()都会查找一个对象所有后辈们，不过可以通过recursive参数控制。(recursive回归，递归) 如果recursive=False，只会找到该对象的最近后代。 通过标签之间的关系进行查找 查找父标签 通过find_parents()或find_parent()。它们之间的不同类似于find()和find_all()的区别。 find_parents()返回全部的相匹配的父标签，而find_parent()返回最近一个父标签。适用于find()的方法同样适用于这两个方法。 在第一消费者例子中，可以找到离Primaryconsumer最近的ul父标签。 1234primaryconsumers = soup.find_all(class_ = 'primaryconsumerlist')primaryconsumer = primaryconsumers[0]parent_ul = primaryconsumer.find_parents('ul')print(parent_ul) 一个简单的找到一个标签的父标签的方法是使用find_parent()却不带任何参数。 1immediateprimary_consumer_parent = primary_consumer.find_parent() 查找同胞 标签在同一个等级，这些标签是同胞关系，比如参照上面金子塔例子，所有的ul标签就是同胞的关系。上面的ul标签下的producers，primaryconsumers，， secondaryconsumers，teriaryconsumers就是同胞关系。 div下的plants和algae不是同胞关系，但是plants和临近的number是同胞关系。 Beautiful Soup自带查找同胞的方法。 比如find_next_siblings()和find_next_sibling()查找对象下面的同胞。(sibling兄弟姐妹) 123producers = soup.find(id = 'producers')next_siblings = producers.find_next_siblings()print(next_siblings) 输出结果将会输出与之临近的下面的所有同胞html代码。 查找下一个 对每一个标签来说，下一个元素可能会是定位字符串，标签对象或者其他BeautifulSoup对象，我们定义下一个元素为当前元素最靠近的元素 。 这不用于同胞定义，我们有方法可以找到我们想要标签的下一个其他元素对象。find_all_next()找到与当前元素最靠近的所有对象。而find_next()找到离当前元素最接近的对象。 比如，找到在第一个div标签后的所有li标签 12first_div = soup.divall_li_tags = first_div.find_all_next('li') 查找上一个 与查找下一个相反的是查找前一个，用find_previous()和find_all_previous()。 slwt的使用代理IP的爬取 【参考文章】 https://my.oschina.net/u/3914536/blog/1860929","categories":[{"name":"python","slug":"python","permalink":"https://albert-5.cn/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.cn/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"}]},{"title":"数学建模笔记","slug":"数学建模笔记","date":"2019-07-03T01:47:39.000Z","updated":"2019-07-11T01:49:14.718Z","comments":true,"path":"2019/07/03/数学建模笔记/","link":"","permalink":"https://albert-5.cn/2019/07/03/数学建模笔记/","excerpt":"","text":"数学交叉建模 图论基本概念顶点集合 $V={v ~1~, V ~2~， ······ }$ 边集合 $E={e1, e2, e3,······}$ 关系函数 $F(e)={u,v}$ 图的表示就有 $ G={V, E, F}$ 欧拉图特点： 线图，连通，无奇度顶点（https://zhidao.baidu.com/question/208310107.html） 边与边之间有相邻不相邻关系：共顶点则为相邻关系，反之亦然； 求欧拉巡回的算法：fleury算法，hierholzer算法 求最佳巡回算法：edmonds算法 图 巡回是指从一点出发经过一系列移动之后又能回到初始顶点； 不具有b结构的称为简单图 二部图 二部图与完全二部图： 若$V(G)=X∪Y$, $X∩Y=φ$ 且$X$中任意两顶点不相邻，$Y$ 中任意两顶点不相邻，则称为二部图或偶图；若$X$中每一顶点皆与$Y$ 中一切顶点相邻,称为 完全二部图或完全偶图,记为 $(m=|X|,n=|Y|)$ 有向图：就是有方向的图 加权图：图中的边上带有权重的图 加权图 子图和生成子图 子图：类似子集 生成子图：保留原图顶点，但是少了部分边 路径和连通 通路：只要可以走就行 walk 道路：边不能重复，但顶点可以重复 Trail 路径：顶点、边都不能重复 圈 定义：起点和终点重合的路径称为圈，长为K的圈称为k阶圈 起点和终点重合的道路称为闭通路 图与网络的数据结构邻接矩阵0不相邻，1相邻 邻接矩阵 1234567表示顶点，1表示相通，0表示不通； 加权图的带权邻接矩阵 A=（W~ij~）n×n $w~ij~$$=\\cases{权值&amp;$当Vi 与Vj 之间有边时$\\cr 0&amp;$当i=j时$\\cr∞&amp;$当Vi与Vj 之间无边时$\\cr}$ 有向图的邻接矩阵 A=（W~ij~）n×n $aij$=$=\\cases{1&amp;$若（vi,vj）∈E$\\cr 0&amp;$若（vi,vj）∉E$\\cr}$ 有向图 邻接矩阵 无向图的邻接矩阵 A=（W~ij~）n×n $a~ij~ $$=\\cases{1&amp;$当Vi 与Vj 相邻$\\cr 0&amp;$当Vi与Vj 不相邻$\\cr}$ 稀疏矩阵边矩阵 定义一个m列的矩阵第1,2行分别存放百年的起点和终点 边矩阵 最短路径MATLAB命令 https://www.cnblogs.com/markReaper/p/8454817.html 最小生成树 kruskal算法 关于图论中的匹配问题 https://mengzelev.github.io/2018/11/28/matchings/ https://zh.wikipedia.org/wiki/%E5%8C%B9%E9%85%8D_(%E5%9B%BE%E8%AE%BA) https://www.renfei.org/blog/bipartite-matching.html 匹配：不相邻的边构成的集合 &lt;最大匹配，匹配，理想匹配&gt; 座位安排问题，任务分配问题（加权二部图的最大权匹配问题），旅行商问题TSP，最小费用流 模糊聚类分析和模式识别聚类分析聚类定义：通俗地说，聚类就是分类问题（没有任何关于分类的先验知识，仅靠事物的相似性作为类属划分的准则属于无监督范畴） 常用的模糊聚类分析方法： 基于模糊函数的聚类分析方法：模糊传递闭包法，直接聚类法，最大树法和编网法 基于目标函数的聚类分析方法：称为模糊C均值聚类算法 模糊聚类分析 建立在模糊相似矩阵之上对分类对象进行定量分类的方法 主要内容有：数据标准化，建立模糊相似矩阵，动态聚类 如何聚类分析 数据标准化 建立数据矩阵 设论域$U={x~1~, x2, x3,······}$为被分类对象，每个对象又有m个指标表示性状，$xi={xi1,xi2·····xim}$，则得到原始数据矩阵$X=(x_{ij})_{n\\times m}$ 标准差标准化 (使数据正规化，在$[0,1]$之间) 标准化方法 ​ 极差正规化，极差标准化，最大值规格化 123.png 用最大最小值构造模糊相似矩阵 模糊相似矩阵 定理： 相似系数法 夹角余弦法 常用方法 聚类模糊等价矩阵 定义：给定$U$上的一个模糊关系$R_{ij}=[r_{ij}]_{n\\times n}$，若它满足： 自反性（$r_{ij}=1$） 对称性（$r_{ij}=r_{ji}$） 传递性（$R\\circ R \\subseteq R$） 称$R$是$U$上的一个模糊等价矩阵。 传递性 相似性度量的相关、相似系数矩阵满足自反性和对称性，但不一定满足传递性。 对于传递性,可先计算$R○R(记作R^2)$,然后看其是否满足传递性。若不满足,经过$R○R=R^2, R^2○R^2=R^4 …$运 算,可将$R$改造成满足传递性的模糊等价矩阵; 模糊等价矩阵的$\\lambda $截矩阵 设$R=[r_{ij}]{n×n}$是模糊等价矩阵，对任意$λ∈[0,1]$，称$Rλ=[r{ij}^{(λ)}]{n×n}为$$R=[r{ij}]_{n×n} λ$截矩阵，其中: 截矩阵2 分类 由模糊等价矩阵的$\\lambda$截矩阵可知，当$r_{ij}=1$时，$i与j应为同类$，否则为异类 让$\\lambda$ 由小到大变化，可形成动态聚类图 分类 最佳阈值$\\lambda$的确定 对于不同的$λ∈[0,1]$，可得不同的分类方案，从而 形成一种动态聚类图。这对全面了解对象的分类情 况是比较形象和直观的。但有的实际问题需要选择 某个阀值λ，确定一个具体的分类，这就是确定阀 值λ的问题。 &lt;动态聚类图&gt; 用$F-统计量$ 确定$\\lambda$的最佳值 最佳值的确定1 最佳值的确定2 模式识别隶属度和贴近度 隶属度 模糊向量和内外积 若0≤ai≤1(i=1,2,…,n),则称向量a=(a**1,**a2,…,a**n)为模糊向量。设a，b**是模糊向量，则分别称： ​ 为向量a与b内积和外积。符号$∧$和$∨$分别表示两个元素取小和取大。 最大隶属度原则 原则1 原则2 贴近度 贴近度是描述模糊集之间彼此靠近程度的指标,是我国学者汪培庄教授提出的,由于研究的问题不同,贴近度也有不同的定义形式,它的一般定义为: 设A，B是论域$U$上的两个模糊子集，则称 为A与B的贴近度 择近原则 回归模型相关关系基本概念一元线性回归分析一元回归模型的检验一元线性回归分析多元线性回归分析时间序列非平稳序列的处理 $X_t=X_{t-1}+\\delta_t$ $X_t=Z_t\\times\\delta_t, Z_t$~N(0,1)","categories":[{"name":"Math","slug":"Math","permalink":"https://albert-5.cn/categories/Math/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://albert-5.cn/tags/数学建模/"},{"name":"图论","slug":"图论","permalink":"https://albert-5.cn/tags/图论/"},{"name":"回归","slug":"回归","permalink":"https://albert-5.cn/tags/回归/"}]},{"title":"智能优化算法","slug":"智能优化算法","date":"2019-06-29T11:59:12.000Z","updated":"2019-06-29T12:01:45.999Z","comments":true,"path":"2019/06/29/智能优化算法/","link":"","permalink":"https://albert-5.cn/2019/06/29/智能优化算法/","excerpt":"","text":"智能优化算法遗传算法Genetic Algorithm，简称GA 基本思想： 根据问题的目标函数构造适值函数Fitness Function 产生一个初始种群 根据适值函数的好坏，不断的进行选择繁殖 若干代后得到适值函数最好的个体即为最优解。 构成要素： 种群 population 种群大小 pop-size 种群表达法 – 编码方法 遗传算子 genetic operator 交叉 crossover 变异 mutation 交叉率高，解空间大，但计算时间较长 选择策略 一般为正比选择 选择种群中适值高的个体，适者生存 停止准则 一般是指定最大迭代次数 GA算法流程图 解空间与编码空间的转换 各个步骤实现 初始种群的产生 编码方法 适值函数 遗传算法 选择策略 停止准则 $\\Delta$ 初始种群的产生 随机产生(依赖于编码方法)；种群的大小(依赖于计算机的计算能力和计算复杂度)。 例：0,1编码 ​ 产生$\\zeta_i\\in U(0,1)$ ​ $\\zeta_i&gt;0.5,\\quad x_i=1;$ ​ $\\zeta_i&lt;0.5,\\quad x_i=0;$ $\\Delta$ 编码方法 –二进制编码 二进制编码，用0,1字符串表达 背包问题：0表示不取，1表示取 特点： 精度高时编码较长，一般不采用此法而用实值函数 编码长不利于计算 便于位值计算，包括的实数范围大 $\\Delta$ 适值函数–根据目标函数设计 用适值函数$F(x)$标定目标函数$f(x)$采用 -minf(x)和 manf(x) $\\Delta$ 遗传运算–选择、交叉、变异 $\\bigstar$ 交叉 Crossover ​ $\\heartsuit$ 单切点交叉 ​ 随机产生一个断点 $[1,n-1]$ ​ ​ $\\heartsuit$ 双切点交叉 ​ 双切点交叉 $\\bigstar$ 变异 Mutation ​ 初始种群中没有需要的基因，在种群中按变异概率$\\ P_m$任选若干位基因改变位值0→1或1→0， 有意想不到的结果，$\\ P_m$一般设定得比较小，在5%以下。 $\\bigstar$ 选择 ​ 最常用的正比选择 ​ 对于个体$i$，适值$F_i$，选择概率如下公式计算$$P_i={F_i \\over{\\sum_{1}^{NP}F_i}}$$ $$NP–Number of Population$$ ​ 之后采用轮盘赌的方法进行选择： ​ 令$PP_0=0，PP_i=\\sum_{j=1}^{i} P_j$ ​ 随机产生 $\\varepsilon_i \\in U(0,1)$ ​ 当 $PP_i \\le \\varepsilon_i \\le PP_i$,选择个体 $i$， 粒子群算法 Particle Swarm Optimization 基本思想 粒子群算法q粒子群算法的思想源于对鸟群捕食行为的研究 模拟鸟集群飞行觅食的行为，鸟之间通过集体的协作使群体达到最优目的，是一种基于Swarm Intelligence的优化方法。 马良教授在他的著作《蚁群优化算法》一书的前言中写到： “自然界的蚁群、鸟群、鱼群、羊群、牛群、蜂群等，其实时时刻刻都在给予我们以某种启示，只不过我们常常忽略了大自然对我们的最大恩赐！……” 算法介绍 每个寻优的问题解都被想像成一只鸟，称为“粒子”。所有粒子都在一个D维空间进行搜索。 所有的粒子都由一个fitness function 确定适应值以判断目前的位置好坏。 每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。 每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态调整。 细说PSO D维空间中，有N个粒子； ​ 粒子$i$位置：$x_i=(x_{i1},x_{i2},\\cdots x_{iD})$，将$x_{i}$代入适应函数$f(x_i)$求适应值； ​ 粒子$i$速度：$v_i=(v_{i1},v_{i2},\\cdots v_{iD})$ ​ 粒子$i$个体经历过的最好位置：$pbest_i=(p_{i1},p_{i2},…p_{iD})$ ​ 种群所经历过的最好位置：$gbest=(g_1,g_2,…g_D)$ 通常，在第$d（1≤d≤D）$维的位置变化范围限定在$[X_{min, d},X_{max,d}]$内,速度变化范围限定在$[-V_{min,d},V_{max,d}]$内（即在迭代中若$v_{id},x_{id}$超出了边界值，则该维的速度或位置被限制为该维最大速度或边界位置） 粒子$i$的第$d$维速度更新公式：$$v_{id}^{k}=\\omega v_{id}^{k-1}+c_1r_1(pbest_{id}-x_{id}^{k-1})+c_2r_2(gbest_d-x_{id}^{k-1})$$ 粒子$i$的第$d$维位置更新公式$$x_{id}^{k}=x_{id}^{k-1}+v_{id}^{k-1}$$$v_{id}^{k}$–表示第$k$次迭代粒子$i$飞行速度的矢量的第$d$维分量 $x_{id}^{k}$–表示第$k$次迭代粒子$i$位置矢量的第$d$维分量 $c_1,c_2$–表示加速度常数，调节学习最大步长 $r_1,r_2$–表示两个随机函数，取值范围为$[0,1]$，以增加搜索随机性 $w$–表示惯性 权重，非负数，调节对解空间的搜索范围 算法流程 1.Initial： 初始化粒子群体（群体规模为n），包括随机位置和速度。 2.Evaluation： 根据fitness function ，评价每个粒子的适应度。 3.Find the Pbest： 对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值做比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest。 4.Find the Gbest： 对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值做比较，如果当前的适应值更高，则将用当前粒子的位置更新全局最佳位置gbest。 5.Update the Velocity： 根据公式更新每个粒子的速度与位置。 6.如未满足结束条件，则返回步骤2 ​ 通常算法达到最大迭代次数$G_{max}$或者最佳适应度值的增量小于某个给定的阈值时算法停止。 粒子群算法 构成要素 群体大小$m$ $m$是一个整型参数，$m$很小时，陷入局部最优解的可能性就越大；$m$很大时，pso的优化能力很好。当群体数目增长至一定水平时，再增长将不再有显著的作用。 权重因子 最大速度 $V_m$ 在于维护算法的探索能力与开发能力的平衡 $V_m$较大时额，探索能力增强，但粒子容易飞过最优解；$V_m$较小时，开发能力增强，但容易陷入局部最优解；因此$V_m$一般设为每维变量变化范围的$10\\%-20\\%$ 邻域的拓扑结构 将群体内所有个体都作为粒子的邻域 只将群体中的部分个体作为粒子的邻域 邻域拓扑结构$\\rightarrow^{决定}$群体历史最优解 因此，将粒子群算法分为 全局粒子群算法和局部粒子群算法 全局粒子群算法 粒子自己历史最优解 粒子群体的全局最优解 局部粒子群算法 粒子自己历史最优解 粒子邻居内粒子的最优解 邻域随迭代次数的增加线性变大，最后邻域拓展到整个粒子群。 粒子空间的初始化 较好地选择粒子空间的初始化空间，将大大缩短收敛时间，初始化空间根据具体问题的不同而不同，也就是说这是问题依赖的。 算法流程 在初始化范围内，对粒子群进行随机初始化，包括随机位置和速度 计算每个粒子的适应值 更新粒子个体的历史最优位置 更新粒子群体的历史最优位置 更新粒子的速度和位置，公式如下：$$v_{k+1}=c_0v_k+c_1\\xi (p_k-x_k)+c_2\\eta(p_k-x_k)$$ $$x_{k+1}=x_k+v_{k+1}$$ 若未达到终止条件，则转第二步 惯性权重 $\\omega $ 描述的是粒子上一代速度对当前速度的影响，$\\omega$较大时，全局寻优能力强，局部寻优能力弱；反之，则局部寻优能力强。当问题空间较大时，为了在搜索速度沙河搜索精度之间达到平衡，通常是使算法在前期有较高的全局搜索能力以得到合适的种子，而在后期有较高的局部搜索能力以提高收敛精度。$$w=w_{max}-(w_{max-w_{min}})\\times {run\\over run_{max}}$$$w_{max}最大惯性权重，w_{min}最小惯性权重，run当前迭代次数，run_{max}为算法迭代总次数$","categories":[{"name":"优化算法","slug":"优化算法","permalink":"https://albert-5.cn/categories/优化算法/"}],"tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"https://albert-5.cn/tags/遗传算法/"},{"name":"粒子群算法","slug":"粒子群算法","permalink":"https://albert-5.cn/tags/粒子群算法/"}]},{"title":"课程","slug":"课程","date":"2019-06-21T07:14:35.000Z","updated":"2019-06-21T07:16:19.452Z","comments":true,"path":"2019/06/21/课程/","link":"","permalink":"https://albert-5.cn/2019/06/21/课程/","excerpt":"","text":"通识课程平台通识必修课程（最少修读31学分） 军事理论训练 2 英语1 3 体育1 1 体育2 1 民族理论与民族政策 2 思修 3 英语2 3 体育3 1 毛概 6 体育4 1 马原 3 近代史 2 ————28分————– 形策（一部分应该） 就业指导 通识选修课程（选修文科类课程最少修读4分）通识选修课程（最少修读6学分）大学生英语扩展课程（最少6学分） 英语3 3 英语4 3 高级媒体视听说 3 学术英语阅读与写作 &lt;应该可以用 创意写作 代替&gt; 3 中国文化概况 3 英语国家社会与文化入门 &lt;应该可以用 跨文化交际 代替&gt; 3 学科基础平台（学科基础必修课程） 高等数学A(1) 线性代数 计算机基础 自动化类专业导论 程序设计语言 高等数学A(2) 大学物理B(1) 大学物理B(1)实验 大学物理B(2) 大学物理B(2)实验 工程制图与CAD 电路原理 信号与系统分析 模拟电子技术 概率论 复变函数 数字电子技术 微机原理 计算机科学学院的课 软件技术基础 专业课程（最少修读43学分）专业选修（最少修读19学分） 运筹学 2 已选 专业应用软件 数学实验代替 2.5 自动化专业英语 2 EDA技术 数据库原理与应用 2.5 已选 操作系统原理 近代控制理论 数字信号处理 控制系统仿真 智能仪表 网络与通信技术 2.5 计算机控制系统 PLC技术与应用 嵌入式技术与应用 DSP技术与应用 管理信息系统 人工智能导论 模式识别导论 2.5 计算机图象处理 机器人导论 &lt;可以用 机器人探秘 代替&gt; 现场总线与测控网络 人工神经网络导论 2 最优控制技术 2 机器学习导论 2 过程控制系统 运动控制系统 2.5 无线通讯网络 专业必修（最少修读24学分） 电机及拖动基础 自动控制原理 检测技术 功率电子技术 电器控制技术 单片机技术与应用 实践教学平台（最少修读26.5学分）实践教学（最少6.5学分）社会实践（最少1.5学分） 自动化类社会实践1 自动化类社会实践2 自动化类社会实践3 课程设计（最少5学分） 软件技术课程设计 电子技术课程设计 单片机课程设计 控制技术课程设计 教学实习（最少修读15学分）教学实习（最少修读3学分） 金工实习 电子技术工艺实习 生产实习 毕业实习（最少修读2学分） 毕业实习 毕业论文（设计）【最少修读10学分】 毕业论文 创新创业平台（最少修读5学分） 创新学分（最少修读3学分） 创业学分 已经修超了","categories":[{"name":"college","slug":"college","permalink":"https://albert-5.cn/categories/college/"}],"tags":[{"name":"大学课程","slug":"大学课程","permalink":"https://albert-5.cn/tags/大学课程/"}]},{"title":"Waring","slug":"Waring","date":"2019-06-14T12:38:56.000Z","updated":"2019-09-08T07:18:39.639Z","comments":true,"path":"2019/06/14/Waring/","link":"","permalink":"https://albert-5.cn/2019/06/14/Waring/","excerpt":"","text":"拒绝伸手党！什么是伸手党伸手党其实指的是一类人，这一类人有的是出于不懂事而产生的伸手现象的未成年人，有的是依赖性极强的成年人，伸手党大致有以下特征： 任何资源（图片、音乐、链接等）都只想通过他人直接获得 虚拟社区（线上游戏、讨论区）中的讨要点卡、高级账号者 理直气壮的向别人索要他人成果 他人发布的消息以及通知等不认真阅读，反复询问者【自己定义】 ​ ———————-来源于百度百科 为什么会有伸手党我感觉伸手党的存在一定程度上反映了个人的一些所谓懒的行为，自己不想去寻找或者付出努力，一味的寻求他人，希望别人直接把资源或者自己想要的东西发给你，他们都要类似的表现，例如什么问题直接来问而不是先去搜索一下如何进行解决。连说明书都懒得去看，也不想着如何去做，失去了学习的能力，也不会想着提升自己。而且能「Google」的就别「百度」，原因你懂的，这时估计会有人说了，你能上谷歌？怎么弄的的 。。。。。。。【WTF 我竟无言以对】 原罪 但是话说过来，又有谁没有做过伸手党呢？你敢说小时候没有抄过作业？【哈，作业写完了吗？借鉴一下呗】，哎呀，真香！但是这只是曾经，那是小时候，玩是天性，不想现在自己要去忙活学习之外的事情，经历、成长、适应社会，再做伸手党恐怕有点过分哦~ 自己定义的伸手党为什么会把这个列为伸手党，我感觉此等行为和伸手党行为莫名的一致。 虽说不是音乐、视频等资源，但是作为一种信息的阅览，其中包含的也是一种资源。 【辅导员】【班长】【各大社团】等一系列的通知，公告等漫天飞舞，还有无尽的【@全体成员】铺天盖地，大多数还都是认真阅读后提出自己的疑问，但总有一些特例不去仔细阅读通知内容，一股劲的@管理询问 这个活动时什么时候开始啊，地点在哪啊 活动的具体形式是什么呀 将个人照片交到某某楼某某教室某某老师，则会有人问了 纸质的还是电子照片啊，老师什么时候在啊 $\\cdots\\cdots$ 拒绝伸手党我们大多时候都会遇到这种情况，很简单，不理会就是了。一些明显的能一个「谷歌」解决的问题，有什么必要去回复呢？到最后只能回复一句 请仔细阅读公告内容！ 或者直接无奈的给你这个： So what? 啊哈 如何避免成为伸手党 善于利用工具：遇到问题先经过自己的思考，实在没有主意就去Google 或者Baidu寻找提示或者思路，人人都能及格甚至优秀，奈何你连翻书都不会 承认自己的渺小和无知：一个人说出【我不知道】【我不了解】可能会很难，但是正因为你不知道，所以你才要去不断的学习，只有这样或许才能不断的进步，如果连这种勇气都没有，成功？恐怕只是一个梦 信息要读Carefully：接到通知或者公告，要自己阅读，不能看到活动通知就说什么时候开始，什么形式，举办方花费精力做的文案可不是白纸，还有黑字呢 学好英语：学好英语更好的利用谷歌工具，更好的看懂论文文献，更好的交流和学习，这里检讨一下自己，曾经英语不努力，现在交流mmp。 做好自己的人生规划吧！ 本内容不针对任何人，只是提醒自己不要做伸手党","categories":[{"name":"Waring","slug":"Waring","permalink":"https://albert-5.cn/categories/Waring/"}],"tags":[{"name":"伸手er","slug":"伸手er","permalink":"https://albert-5.cn/tags/伸手er/"},{"name":"自我警告","slug":"自我警告","permalink":"https://albert-5.cn/tags/自我警告/"}]},{"title":"Wechat爬取好友信息","slug":"Wechat爬取好友信息","date":"2019-06-12T13:49:31.000Z","updated":"2019-06-13T17:13:01.126Z","comments":true,"path":"2019/06/12/Wechat爬取好友信息/","link":"","permalink":"https://albert-5.cn/2019/06/12/Wechat爬取好友信息/","excerpt":"","text":"微信好友 一览无余【itchat】一个微信的开源API，微信是一种常用的社交网络应用程序。 通过python中的聊天访问个人微信账户，然后通过微信机器人进行处理个人所有基本信息。 安装itchat模块1pip install itchat 简单使用123import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 详情见itchat官方网站 主要用到的方法有： itchat.login()微信扫码登录 itchat.get_friends()返回完整的列表好友，每个好友为一个字典，其中第一项为自己的账号基本信息，带入参数update=True，将更新好友列表并返回，具体使用itchat.get_friends(update=True) 技巧：使用itchat.login()进行登录微信会有一个问题，就是每运行一次就会生成一个二维码，叮··· 扫描登录，是不是过于麻烦了？ 直接采用itchat.auto_login()，在一定时间内，可以不用扫码登录，只需要在手机移动端确定登录就行了，毕竟是在模拟网页登录 开始操作12345678# 导入所需要的库import itchatimport csvimport pandas as pd# 启用热键扫码登录微信itchat.auto_login(hotReload=True)# 抓取好友信息friends = itchat.get_friends(update=True)[0:] 这时，好友信息已经在存储在friends里面了。 定义函数抓取个字段信息get_var(var) 1234567891011121314151617def get_var(var): variable = [] for i in friends: value = i[var] variable.append(value) return variable# 调用函数得到各个变量,存在csv文件中NickName = get_var('NickName')Sex = get_var('Sex')Province = get_var('Province')City = get_var('City')Signature = get_var('Signature')Username = get_var('UserName')ContactFlag = get_var('ContactFlag')SnsFlag = get_var('SnsFlag') 定义函数parse_friends()，将得到的好友数据存储在txt文本中 1234567891011121314# 收集并保存好友信息数据def parse_friends(): # 设置需要爬取的信息字段,使用字典形式,参考官网以及个人需求设置字段信息 result = &#123;'NickName': NickName, 'Sex': Sex, 'Province': Province, 'City': City, 'UserName': Username, 'ContactFlag': ContactFlag, 'SnsFlag': SnsFlag, 'Signature': Signature, &#125; for user in friends: with open('myfriends.txt', 'a', encoding='utf8') as fh: fh.write('-------------------------\\n') for r in result: with open('myfriends.txt', 'a', encoding='utf8') as fh: fh.write(str(r) + \":\" + str(user.get(r))+\"\\n\") print(\"分析完毕！\") 设置最后打印标识，提醒已完成信息存储；同时当前文件夹中出现一个文件myfriends.txt 信息文件 定义函数male_female()统计男女以及其他人数和比例 统计 然后利用pandas模块将文件信息保存在csv文件中 12345678data = &#123;'NickName': NickName, 'Sex': Sex, 'Province': Province, 'City': City, 'UserName': Username, 'ContactFlag': ContactFlag, 'SnsFlag':SnsFlag, 'Signature':Signature, &#125;frame = DataFrame(data)frame.to_csv('data2.csv', index=True, encoding='utf-8')with open('data2.csv', 'r', encoding='utf-8') as myfile: reader = csv.reader(myfile) for row in reader: print(row) 便于后续采用pandas中的 value_counts 进行计数可视化处理 简单可视化操作 采用pyecharts中的Pie绘制饼图 12# 导入模块from pyecharts.charts import Pie 123456configure(output_image=True)pie = Pie(\"性别比例\", background_color='white', title_text_size=25)attr = ['male', 'female', 'other']v1 = [57.14, 27.04, 15.82] # 好友男女百分比pie.add('', attr, v1, is_label_show=True)pie.render() # render渲染，默认在当前文件夹中的render.html 再使用pyecharts时，可能会出现一些错误，比如不存在Pie或者无法导入Pie等 看了一些博客之后，我采用的方法是降级，即降低库的版本，可能是与python版本有冲突 效果 比例.png 或许这就是你Single的原因吧 –苦笑–","categories":[{"name":"Wechat爬虫","slug":"Wechat爬虫","permalink":"https://albert-5.cn/categories/Wechat爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.cn/tags/爬虫/"},{"name":"微信","slug":"微信","permalink":"https://albert-5.cn/tags/微信/"}]},{"title":"算法导论复习","slug":"算法导论复习","date":"2019-06-02T06:22:04.000Z","updated":"2019-06-23T15:28:06.707Z","comments":true,"path":"2019/06/02/算法导论复习/","link":"","permalink":"https://albert-5.cn/2019/06/02/算法导论复习/","excerpt":"","text":"算法复习 1 插入排序思想： 通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 •Sorting problem: –Input: A sequence of n numbers a~1~, a~2~, …, a~n~ –Output: A permutation (reordering) a’~1~, a’~2~, …, a’~n~ of the input sequence such that a’~1~&lt;=a’~2~ &lt;= … &lt;=a’~n~ •An instance of the sorting problem –Input: 8 2 4 9 3 6 –Output: 2 3 4 6 8 9 •Notation: –Sorting is a fundamental operation in CS –A large number of good sorting algorithms have been D&amp;R 算法描述 伪代码 具体python代码实现参考博客文章 时间复杂度的问题： •Worst-case: (usually) –T(n) = maximum time of algorithm on any input of size n. T(n)=maxI {T(n,I)} –Time Complexity (Default ) •Average-case: (sometimes) –T(n) = expected time of algorithm over all inputs of size n. –Need assumption of statistical distribution of inputs. ? •Best-case: (bogus虚假) –Cheat with a slow algorithm that works fast on some input. ? 2 时间复杂度描述$$\\Theta(n) \\quad既有上界又有下界$$ •Engineering: –Drop low-order terms; ignore leading constants. example:$$3n^3 + 90n^2 –5n + 6046 = Θ(n3)$$ $$O(n)\\quad 只有上界$$ $$Ω(n)\\quad 只有下界$$ 3 分治思想recursively 递归 subproblems 子问题 median 中位数 Merge sort •Problem: –Input: A[1,n] –Output: A[1,n] in sorted order •Divide-and-conquer paradigm –Divide: Divide the n-element sequence to be sorted into two subsequences of n/2 elements each. –Conquer: Sort the two subsequences recursively using merge sort. –Combine: Merge the two sorted subsequences to produce the sorted answer. Recursion tree递归树解决递归式问题 例子：$$Solve \\quad T(n)=2T(n)+cn,\\quad where c&gt;0\\quad is \\quad constant$$ 1558947965911 4 快速排序思想: ​ 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 前言介绍 1558947965911 123456789PARTITION (A, p, r) # A是待排序数组 x ← A[r] i ← p-1 FOR j ← p TO r-1 IF A[ j] ≤ x THEN i ← i + 1 exchange A[i] ↔ A[ j] exchange A[i+1] ↔ A[r] RETURN i+1 1558947965911 ​ the run time drops from Ω(n log n) to Ω(n^2^) 提高快速排序的方法 Median-of-three(三平均分区法) 关于这一改进的最简单的描述大概是这样的：与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势： （1） 首先，它使得最坏情况发生的几率减小了。 （2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。 提高的方法可以说是这样的： 首先对整个列表的元素进行选取，第一个位置first，中间位置middle，最后一个位置的元素last，然后以这三个数的中位数（以middle）为基准，对列表剩余的元素进行比较采用插入排序进行sort，这样一来，左边的元素都是小于middle的元素，右边的元素都是大于middle的元素； 然后在对middle左边的元素进行上述操作，对右边进行上述操作，直至待排的元素个数为1。 至此，整个排序也就完成了； 5 Dynamic programming 动态规划Rod cutting Given a rod of length n inches and a table of prices pi for i = 1,2,3,…,n, determine the maximum revenue(收入) r(n) obtainable by cutting up the rod andselling the pieces. 给定长度为n英寸的杆和i = 1,2,3，…，n的价格表p~i~，确定通过切割杆和杆可获得的最大收入r(n)来销售。 问题描述 拓展阅读 6 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法；比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 贪心算法在有最优子结构的问题中尤为有效； 通常情况下，贪心算法采用自顶向下的设计，因为不需要作出过多的选择求解所有子问题； 找零钱问题 123456789101112131415Change-Making ProblemFinding the number of ways of making changesfor a particular amount of cents, n, using a givenset of denominations C=&#123;c1…cd&#125; (e.g, the UScoin system: &#123;1, 5, 10, 25, 50, 100&#125;)– An example: n = 4,C = &#123;1,2,3&#125;, solutions: &#123;1,1,1,1&#125;,&#123;1,1,2&#125;,&#123;2,2&#125;,&#123;1,3&#125;. Minimizing the number of coins returned for aparticular quantity of change (available coins&#123;1, 5, 10, 25&#125;)– 30 Cents (solution: 25 + 5, two coins)– 67 Cents ? 17 cents given denominations = &#123;1, 2, 3, 4&#125;? 算法 活动选择 有一个需要使用每个资源的N个活动组成的集合S ={a1, a2, ···, an},资源每次只能由一个活动使用。每个活动都有一个开始时间和si和结束时间fi，且0=&lt;si&lt;=fi&lt;∞，一旦被选择后，活动ai就只占据时间[si, fi]，如果[si,fi]和[sj,fi]不重叠，则称ai、aj兼容。 12345678910# 活动选取的贪心算法Greedy-Activity-Selector(s, f) n = s.length A = &#123;a1&#125; k = 1 for m = 2 to n if s[m] &gt;= f[k] # 时间的比较 A = A U &#123;am&#125; k = m return A 最优子结构 如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。贪心算法要做的就是逐步求取局部最优解，以致达到全局整体最优。 赫夫曼编码 讨论赫夫曼编码问题，赫夫曼编码的思想就是变长编码；也就是说让字符表中出现概率高的字符的编码长度尽可能的小，而出现概率高的字符的编码相对较长；然后遵循前缀码的要求，即是任意一个编码都不是其他编码的前缀，便于解码。 作者：JeffCoding原文：https://blog.csdn.net/jeffleo/article/details/53557143 赫夫曼编码是一种广泛用于数据压缩的问题，该算法的主要优势在于节约了存储和传输成本。举一个例子：假设要传输的数据为 Figure 0 那么传输成本就是：453 + 30 3 + 29 3 + 10 3 + 8 3 + 5 3 = 381个字符 我们可以使用赫夫曼编码思想来解决先合并最小频率的2个字符对应的子树，计算合并后的子树的频率；重新排序各个子树；重复步骤1重复步骤2对二叉树中的边赋予0、1，得到各字符的变长编码。对于上举的例子而言就是：EF最小，首先构造EF的生成树，重新排序 Figure 1 构造EF 和 D的生成树，重新排序 Figure 2 构造EFD 和 C 的生成树, 重新排序 Figure 3 构造EFDC 和 B 的生成树，重新排序 Figure 4 构造EFDCB 和 A 的生成树，重新排序 Figure 5 赫夫曼编码后的二进制数据为： Figure 6 可以看见，利用赫夫曼思想设计之后，频率高的字符，二进制码短了，频率低的字符，二进制码长了，这样就有效得减少了总得二进制码数。 那么传输成本就是：451 + 30 2 + 29 3 + 10 4 + 8 5 + 5 5 = 292个字符，节约了23%的成本！ End 7 最大流问题流网络 digraph G=(V,E) weights, called capacities on edge c(u,v)边缘容量 two distinct vertices (不同的顶点) source, ‘s’; sink ‘t’ 流网络 The value of a flow is the net flow out of the source:$$\\sum p(s,v)-\\sum p(v,s)$$流网络流出的值是净网络 网络的值 The value of this flow is 1-0+2=3 残存网络 假定有一个流网络G=（V，E），其源点为s，汇点为t，f为G中的一个流。对即诶点对u，v，定义残存容量（residual capacity） img ，有： img 残存网络可能包含图G中不存在的边，残存网络中的反向边允许算法将已经发送出来的流量发送回去。一个残存网络示例图如下： Rabin-KarpRabin-Karp img 图a是一个流网络，b是a对应的残存网络，注意每条边上的值，残存网络中针对每条正向边计算出该条边在存在流的情况下的剩余容量，并画出一条反向边，反向边的容量即是发出流的大小，方便将发出的流运输回发送地，并将权重为0的边省略。 8 字符串匹配Rabin-Karp算法 在实际应用中，Rabin-Karp算法的预处理时间为O（m）,并且在最坏的情况下的时间复杂度为O((n-m+1)m),相对于朴素字符串，它的运行时是比较好的。 整个算法思想介绍如下： 数学中有霍纳法则,我们运用霍纳法则在O(m)内计算p： p=P[m]+10(P[m-1]+10(P[m-2]+…+10(P[2]+10P1)…))) 霍纳法则的解释如下： 运用霍纳法则，类似的我们也可以根据T[s+1…s+m]计算出t. 但为了节约时间，我们可以利用一下方法在常数时间内根据ts,计算出ts+1.具体过程如下图解: 如图所示，ts=31415,ts+1=14152,则 ts+1=(ts-(T[s+1]=3)10^(m=4))10+(T[s+m+1]=2) 注：(ts-(T[s+1]=3)*10^(m=4))=31415-30000=1415 即 ts+1=10(ts-10^(m-1)T[s+1])+T[s+m+1] 在计算过程中，可能会出现p与t的值过大，可以取模运算 确定优先状态自动机 有限自动状态机 上面这个图描述的就叫一个有限状态自动机，图中两个圆圈，也叫节点，用于表示状态，从图中可以看成，它有两个状态，分别叫0和1. 从每个节点出发，都会有若干条边，当处于某个状态时，如果输入的字符跟该节点出发的某条边的内容一样，那么就会引起状态的转换。例如，如果当前状态处于0，输入是字符a,那么状态机就会从状态0进入状态1.如果当前状态是1，输入字符是b或a,那么，状态机就会从状态1进入状态0.如果当前所处的状态，没有出去的边可以应对输入的字符，那么状态机便会进入到错误状态。例如，如果当前处于状态0，输入字符是c,那么状态机就会出错，因为从状态0开始，没有哪条边对应的字符是c。 状态机会有一个初始节点，和一个接收节点，以上图为例，我们可以设置初始节点为0，接收节点为1，当进行一系列的输入，使得状态机的状态不断变化，只要最后一个输入使得状态机处于接收节点，那么就表明当前输入可以被状态机接收。例如对应字符串”abaaa”, 从初始节点0开始，状态机根据该字符串的输入所形成的状态变化序列为：{0，1，0，1，0，1}。由于最后状态机处于状态1，所以该字符串可以被状态机接收。如果输入的字符串是:abbaa, 那么状态机的变化序列为：{0，1，0，0，1，0}， 由于最后状态机处于非接收状态，因此这个字符串被状态机拒绝。 在程序中，使用二维表表示一个状态机： 输入 a b 状态0 1 0 状态1 0 0 接下来我们看看一个文本的匹配流程，假定要查找的字符串为P=”ababaca”, 被查找的文本为T=”abababacaba”. 一次读入T的一个字符，用S表示当前读入的T的字符，一开始读入一个字符，于是S=a.然后看看，从P开始，连续几个字符所构成的字符串可以成为S的后缀，由于当前S只有一个字符a,于是从P开始，连续1个字符所形成的字符串”a”,可以作为S的后缀。把这个字符串的长度记为k,于是此时k 等于1. 继续从T中读入字符，于是S=”ab”, 此时，从P开始，连续两个字符所构成的字符串”ab”可以作为S的后缀，于是k = 2.反复这么操作，于是便有以下序列： 1234567891011S=a, k = 1, P[1] 是S的后缀S=ab, k = 2, P[1,2] 是S的后缀S=aba, k = 3, P[1,2,3]是S的后缀S=abab, k= 4, P[1,2,3,4]是S的后缀S=ababa, k = 5, P[1,2,3,4,5]是S的后缀S=ababab, k = 4, P[1,2,3,4]是S的后缀S=abababa, k = 5, P[1,2,3,4,5]是S的后缀S=abababac, k = 6, P[1,2,3,4,5,6]是S的后缀S=abababaca, k = 7, P[1,2,3,4,5,6,7]是S的后缀S=abababacab, k =2, P[1,2] 是S的后缀S=abababacaba, k = 3, P[1,2,3] 是S的后缀。 从上述过程中，我们可以看到第九步的时候字符串P已经成为了S的后缀，此时的S是文本T的前缀，因此可以说明在字符串T中找到了模式串P。 如果问题变化，构造一个方法，使得一次运行便能知道从P开始，连续读取几个字符能使得这几个字符构成的字符串是S的后缀。这个方法，就需要上面我们提到的有限状态自动机了 用于字符串匹配的自动机 假定字符串P和文本T只由a,b两个字符组成，也就是字符集为∑={a,b,c}, P含有m个字母，于是，我们要构造的自动机就含有m个状态节点。假设我们当前处于状态节点q, 那么当下一个输入字符是a和b时，从当前节点q该跳转到哪一个节点呢？ 如果用$P_q$来表示长度为q的P的前缀，以q=4, p=”ababaca”, $P_q$ =”abab”, 那么当处于状态4, 当输入为a时，我们构造字符串 S = $P_q$ + ‘a’ = “ababa”, 然后看看字符串P从第一个字符开始，连续几个字符所构成的字符串可以成为S的后缀，就当前S为例，从第一个字符开始，连续5个字符，也就是P[1,2,3,4,5]可以作为S的后缀，于是，我们就有，当状态机处于节点4，输入为a时，跳转的下个状态就是5. 同理，当处于状态q=4,输入为字符b时，S = $P_q$ + ‘b’ = “ababb”,此时从P开始，连续读取0个字符才能形成S的后缀，于是当状态机处于状态4，如果读入字符是b, 那么跳转的下一个状态是0，同理，如果输入字符是c, 那么S = $P_q$ + ‘c’ = “ababc”, 此时从P开始，连续读取0个字符所形成的空字符串才能作为S的后缀，于是当状态机处于状态节点4，输入字符为c时，跳转到节点0. 如果q从0开始，一直到m,反复运用刚才提到的步骤，便会产生下面这个跳转表： 输入 a b c 状态0 1 0 0 状态1 1 2 0 状态2 3 0 0 状态3 1 4 0 状态4 5 0 0 状态5 1 4 0 状态6 7 0 0 状态7 1 2 0 状态I就是上面介绍的K的值，也就是P中形成的字符串可以构成S的后缀的长度； KMP算法 算法流程 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 next数组的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀，例如如果next[j]=k,代表j之前的字符串中有最大长度为k的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符； 步骤 ① 寻找前缀后缀的最大公共元素长度 对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示： 比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k+1 = 2）。 ② 求next数组 next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示 比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1） 补充 寻找最长前缀后缀 如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示： img 也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）： img 而且，根据这个表可以得出下述结论 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 给定字符串“ABCDABD”，可求得它的next 数组如下： img 把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。 kmp算法的复杂度是O(n+m) 参考文章 https://blog.csdn.net/tyler_download/article/details/52549315 https://blog.csdn.net/v_july_v/article/details/7041827#t5","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"插入排序","slug":"插入排序","permalink":"https://albert-5.cn/tags/插入排序/"},{"name":"算法导论","slug":"算法导论","permalink":"https://albert-5.cn/tags/算法导论/"},{"name":"最大流问题","slug":"最大流问题","permalink":"https://albert-5.cn/tags/最大流问题/"},{"name":"KMP算法","slug":"KMP算法","permalink":"https://albert-5.cn/tags/KMP算法/"}]},{"title":"网络流Network_Flow","slug":"网络流Network-Flow","date":"2019-06-01T04:44:08.000Z","updated":"2019-06-01T04:45:35.097Z","comments":true,"path":"2019/06/01/网络流Network-Flow/","link":"","permalink":"https://albert-5.cn/2019/06/01/网络流Network-Flow/","excerpt":"","text":"内容来源于爱美工的程序员 网络流（Network Flow）网络流和线性规划、动态规划是有关系的。它们都属于数学规划，也就是用数学的方法来帮助决策。（详情参考清华大学《数学规划》）这样来看，就没有神秘可言了。小样，换个马甲我还认识你。所以，网络流也是一个解决极值问题的数学方法。 要解决问题，总得先有个靠谱的模型吧。动态规划和线性规划里边都有公式啥的。总之，要先形式化（建模），再解决。所以，就有了流网络。 流网络（Flow Network）顾名思义，流网络是一种用流构成的网络，如下图。 img 可以把边想象成自来水的管道，把节点想象成管道的连接组件。其中，管道的容量不一定相同，所以就有了不同的边的权重（管道容量是一个大于等于0的常量）。流网络是一个有向图，所以，管道是有方向的（水的流向只能按照管道的方向流）。注意图中两个特殊的连接组件，s代表源，也就是水的入口，t代表汇，也就是水的出口。也就是说，水从s点灌入，从t点流出，具体有多少水流入s，我们不用管，反正是源源不断；从t流出的水去哪，我们也不用操心。 这样，我们就得到了一个流网络，s是流的入口，t是流的出口，s和t之间有若干个管道连接。要谨记这个流网络中管道的容量限制和方向限制，若是没有它，又何必来学网络流。 流（Flow）流网络可以看成是一张线路图，这里是自来水管道的线路图，相当于硬件基础设施。 我们现在要做的是使用这个基础设施，也就是往管道里灌水，确保每个管道里的流量不超过容量限制。比如，我们可以这样灌，如下图。边的权重增加了流量参数，使用斜线与容量进行分隔。 注意：这里的所有图中，如果有斜线标识，则左侧表示流，右侧表示容量。如果没有斜线，则只是表示容量。 img 对流网络灌水得到的就是“流”。当然，这只是其中一种满足流量不超过容量限制的灌水方法。还可以有很多种灌水的方法。但是都要遵循以下两个原则： 容量限制：管道的流量不能超过容量。 流量守恒：流入管道连接组件的流量等于流出的流量。 至此，我们成功的得到了“流”。 s-t流（s-t Flow）现实往往是不按套路出牌的。比如，连接的地方（节点）可能有权重，能够蓄水。比如，有多个源多个汇。比如，有多个管道连接两个节点。 总之，现实的种种迹象表明，我们需要设计一个兼容并包的模型，考虑种种情况。 但是，我们不想考虑那么多情况。 于是，就有了一个小伙想了个点子，定义一种标准模型，我们只研究这个标准的模型。其它的情况通过一些方法转化成这个标准模型。 是的，这个标准模型就是s-t流。一些转化方法如下图。 img 最大流（Maximum Flow）费尽心思，从初步的流网络，到我们比较喜欢的标准形式s-t流，是时候考虑正事儿了。 流网络是固定的，但是流是不确定的。所以，我们想在多种灌水的方法中寻找最佳。 何为最佳？ 在源灌入大量的水，通过选择最好的管道流量和流向，使得汇流出的流量最大。但是，最大流不是想找就能找到的，所以这是个问题，即最大流问题。 Trial 1: Dynamic programming既然是数学规划，首先想到的是能不能使用动态规划。 现实情况是，目前还没有解决最大流问题的动态规划算法。 Trial 2: Iteration想到的另外一种方法是迭代法，伪代码表示如下。 12345678x = x0;while true do x = improve(x); if stopping(x) then break end ifend whilereturn x 主要是思想是从某个流开始，不断的改进这个流，直到到达我们想要的最大流。 不得不说，这想法太粗略了。一些问题没有解决，比如，如何选择开始的流，如何改进，何时停止算法。 为了解决这些问题，我们需要继续补充一些基础知识。这样才能干掉这个问题。 （为什么不试试线性规划？线性规划是可以解决的，但是对于这种网络的结构，并不能很高效。） 割（Cut）对于一个流网络，在若干个管道上切一刀，使这个网络分成两部分，这两部分将无法连通。所以，我们有很多种切割的方法，把这个网络分成两部分。每一种切割的方法对应于一个“割”。 s-t割（s-t Cut）s-t割是一种特殊的“割”，这种切割的方式需要保证在切割之后s和t不再连通，即s和t不属于同一部分了。 对于一个s-t割，必然会把s和t分到两个小网络中，并且切坏了若干个管道。这两个小网络之间的管道容量之和就是割的值，只计算从包含s的小网络流向包含t的小网络的管道容量之和，反方向不考虑。一个s-t割如下图。 img 可以计算出，割的值为12+14=26。可以看到，割的值只与流网络有关，和流无关。对于一个确定的流网络，一刀切下去，割的值就确定了。 最小割（Minimum Cut）对于一个流网络，我们可以得到多个割的值，因为切的方法有很多种，如下图。 img 在这里，我们更关心割值最小的情况，即最小割。为什么更关心最小割？下面会说~ 净流量（Net Flow）注意到，割的值是和流无关的，只与流网络有关。也就是说，割的值只是取决于管道的容量和方向，以及切的方法。 如果我们观察一下流，发现了一个规律，如下图。 img 真的是固定值有木有！这个固定值就是净流量。之所以有这个规律，是因为流量守恒。 需要注意，在计算净流量时，需要考虑两个方向的值，并求代数和。从s流向t记为正，从t流向s记为负。对于割值的计算，则无需考虑从t流向s的。因为割值实际计算的是管道容量，净流量考虑的是真实的流量。 残留网络（Residual Network）残留网络，顾名思义，就是流网络中去掉流剩下的网络。对于某条管道，其容量减去流以后剩下的流构成的网络，就形成了残留网络。每一个流会对应一个残留网络，残留网络 = 流网络 - 流，如下图。 img 需要说明的是，蓝色的边称作反向边，方向与原来的方向相反，数值为原来流量的值。 为什么要加上这个看似多余的反向边？ 反向边的作用就是给程序一个可以后悔的机会。（来自这里)） 也就是说，加这个边是为了寻找最大流的程序的执行。 增广路径（Augmenting Path）扯这么多，主要是为了引出这个增广路径。因为增广路径能帮我们找到最大流。 增广路径就是残余网络中的一条s到t方向的路径，如下图。 img 如果我们找到了这样一条路径，说明原来的流不够大，还可以在这条路径上压入一些流量，在这里是3，取11、12、3中最小值。 这样，我们就可以得到更大的流。 思考从流（我们更关心最大流），到割（我们更关心最小割），到残留网络，再到增广路径，我们在做啥子吗？ 我的理解是，这些流呀割呀都是理论储备，最终是想证明一句话：残留网络$G_f$中不包含增广路径时，f就是G的最大流。 而残留网络、增广路径是解决这个最大流问题的手段，通过寻找增广路径的方法来改进当前的流，朝最大流逼近。但是，问题是何时停止算法呢？这就是理论储备部分告诉我们的，如下图。 img 最大流最小割定理（Max-Flow Min-Cut Theorem）重述一遍，残留网络$G_f$中不包含增广路径时，f就是G的最大流（或者说，最大流的流量等于最小割的容量）。 这就是传说中的最大流最小割定理。 这个可以用反证法证明，假设当不包含增广路径时没有达到最大流，那么就会找到一条路径来增大流，也就找到了增广路径，所以矛盾。大致是这样证明。 Ford-Fulkerson方法Ford-Fulkerson是一种求解最大流的方法，依赖于上面积淀的基础知识（主要是残留网络、增广路径、割的功劳），也称作“扩充路径方法”。之所以称之为方法而不是算法，是因为这个只是一种指导思想，在此指导之下，有很多种实现方式。 Ford-Fulkerson是一种迭代法，过程如下： 流网络中所有顶点对的流大小清零（此时，网络流为零） 每次迭代，通过寻找一条增广路径来增加流的值 无法找到增广路径时，迭代结束 可以看到，最关键问题是如何寻找增广路径，而Ford-Fulkerson方法的效率正取决于此。如果选择方法不好，就有可能每次增加的流非常少，而算法运行时间非常长，甚至无法终止。 但是，Ford-Fulkerson并没有告诉我们如何寻找增广路径。所以，它是个方法，而不是算法，伪代码如下。 1234567891011121314 initialize f(e) = 0 for all ewhile there is a s-t path in residual graph Gf do arbitrarily choose an s-t path P in Gf f = augment(P, f)end whileaugment(P, f) let b = bottleneck(P) for each edge e = (u, v) ∈ P do if (u, v) is a forward edge then increase f(u, v) by b else decrease f(u, v) by b end if end for 其中，augment是一个改变当前流的函数，即使用找到的增广路径P来压入流，增大当前的流f。而bottleneck从当前的增广路径P中找到瓶颈边（残留网络中，路径上流量最小的边），把这个流量压入。 正是因为在选择增广路径时是arbitrarily，所以Ford-Fulkerson方法有多种实现。 Scaling technique第一种是scaling的方法，通过伪代码更好解释。 123456789initialize f(e) = 0 for all elet △ = Cwhile △ ≥ 1 do while there is a s-t path in Gf(△) do choose a s-t path f&apos; = augment(P, f) f = f&apos; end while △ = △ / 2 可以看到，通过定义一个△来调节增广路径的选择顺序。C是一个定义的常熟。如果残留网络中的边（流量值）小于C，则“删除”该边，在新的网络中选择增广路径。如果这样的网络中找不到增广路径（也就是说，所有的边都不符合△的限制），则把△缩放为原来的一半，继续寻找增广路径。直到△不满足大于等于1时，算法结束。 例子来自卜老师的课件，△初始化为96。第一次的时候，残留网络的所有边被“删除”（标记为蓝色），因为都小于96。然后△调整为96/2=48，这样就获得了一条增广路径，并压入流。直到找不到增广路径，算法结束，如下图。 img 可以看到，scaling方法是通过加一个△（阈值）来选择增广路径的。通过这个阈值，可以尽可能的一次压入多一些的流。我们的目标是迭代的次数少且每次压入的流要多。 Edmonds-KarpEdmonds-Karp算法是使用BFS（广度优先搜索）的方式，选择最近的路径作为增广路径，伪代码如下。 123456initialize f(e) = 0 for all ewhile there is a s-t path in Gf do choose a shortest s-t path in Gf using BFS f&apos; = augment(P, f) f = f&apos;end while 补充走了好久终于等到现在… 总结来说，前面一直在铺垫，积累些基础知识，为了得到最大流最小割定理，然后证明Ford-Fulkerson方法能够获得最大流。 但是，这终归是个方法。方法没有告诉我们哪一种寻找增广路径的算法是最好的。于是就有人搞了各种算法，进行了各种测试，性能也就各不相同了，如下图。 img 总之，是为了算法实现的更好，终极目标是高效的找到最大流，也就是解决最大流问题咯。 一些参考： http://www.csie.ntnu.edu.tw/~u91029/Cut.html#2 http://blog.csdn.net/leolin_/article/details/7202691 http://blog.csdn.net/smartxxyx/article/details/9293665 http://blog.csdn.net/kk303/article/details/6728400 http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html http://chhaj5236.blog.163.com/blog/static/112881081200982835124243/ http://xpgc.vicp.net/course/ada4ia/TechDoc/ch09/ia-09-maxflow.pdf 1-- EOF --","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://albert-5.cn/tags/算法导论/"},{"name":"网络流","slug":"网络流","permalink":"https://albert-5.cn/tags/网络流/"},{"name":"最大流问题","slug":"最大流问题","permalink":"https://albert-5.cn/tags/最大流问题/"}]},{"title":"Typora语法","slug":"Typora语法","date":"2019-05-31T08:35:16.000Z","updated":"2019-05-31T08:47:44.970Z","comments":true,"path":"2019/05/31/Typora语法/","link":"","permalink":"https://albert-5.cn/2019/05/31/Typora语法/","excerpt":"","text":"Typora 语法数学表达式要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令，例如：$lim_{x \\to \\infty} \\ exp(-x)=0$将产生如下的数学表达式： $\\lim_{x \\to \\infty} \\exp(-x)=0$ 下标下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 上标上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 插入表情:happy:使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线Underline. 删除线GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 代码 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生printf()样式。 输入~~~或者12- ​1234public Class HelloWorld&#123; System.out.println(\"Hello World!\");&#125;​ 1234567将会产生```javapublic Class HelloWorld&#123; System.out.println(&quot;Hello World!&quot;);&#125; 强调使用两个*号或者两个_包裹的内容将会被强调。例如 12**使用两个*号强调内容**__使用两个下划线强调内容__ 将会输出 使用两个*号强调内容使用两个下划线强调内容Typroa 推荐使用两个*号。 斜体在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\\* 插入图片我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 插入URL连接使用尖括号包裹的url将产生一个连接，例如：&lt;www.baidu.com&gt;将产生连接:&lt;www.baidu.com&gt;. 如果是标准的url，则会自动产生连接，例如:www.google.com 也可以借用HTML中的语法结构，使用标签 目录列表Table of Contents（TOC）输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 水平分割线使用***或者---，然后回车，来产生水平分割线。 标注我们可以对某一个词语进行标注。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 表格12345|姓名|性别|毕业学校||:---|:---:|:---:||1|男|1||2|男|1||3|女|1| 将产生: 姓名 性别 毕业学校 1 男 1 2 男 1 3 女 1 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个是居中，最后一个是右对齐。 数学表达式块输入两个美元符号，然后回车，就可以输入数学表达式块了。例如： 1$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$$ 将会产生: 123.png 任务列表使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。 1234- [ ] 吃饭- [ ] 逛街- [ ] 看电影- [ ] 约泡 吃饭 逛街 看电影 约泡 列表输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** tfboys* 杨洋* 我爱你 无序的列表 tfboys 杨洋 我爱你 1234**有序的列表**1. 苹果6. 香蕉10. 我都不喜欢 有序的列表 苹果 香蕉 我都不喜欢 块引用使用&gt;来插入块引用。例如： 1&gt;这是一个块引用！ 将产生： 这是一个块引用！ 标题使用#表示一级标题，##表示二级标题，以此类推，有6个标题。","categories":[{"name":"学习","slug":"学习","permalink":"https://albert-5.cn/categories/学习/"}],"tags":[{"name":"typora","slug":"typora","permalink":"https://albert-5.cn/tags/typora/"}]},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2019-05-23T15:51:26.000Z","updated":"2019-05-24T11:56:46.207Z","comments":true,"path":"2019/05/23/模拟退火算法/","link":"","permalink":"https://albert-5.cn/2019/05/23/模拟退火算法/","excerpt":"","text":"模拟退火算法 模拟退火算法(SimulatedAnnealing)是基于Monte-Carlo迭代求解策略的一种随机寻优算法,主要用于组合优化问题的求解。 假设现在有这么一个函数：$$f(x) = x^3-72x^2+4x+5$$现要求其在[0,100]范围内的最小值，如果不求导计算，可能第一反应都是穷举法，把范围内每个值都算一遍再比较大小。如果求的是整数范围，那么要算100遍，但是如果要精确到小数后8位，则要算10000000000次，即便使用计算机依然是一个庞大的运算过程。而优化问题中很多都类似于问题，无法用穷举法解出答案，我们叫这类问题为NP难问题（可查看维基百科：NP-hard），于是，有人提出了爬山法 也可以参考下争取几句话描述一下爬山法，模拟退火，遗传算法他的博客文章博客文章 但是这个方法的缺点在于最优解的产生依赖于最初值的选取，无法解决非凸函数，即容易收敛于局部最优解；同时，也无法解决有平台的函数的问题 于是，Kirkpatrick等提出了模拟退火算法，它是一种启发式搜索算法，即按照预定的控制策略进行搜索，在搜索过程中获取的中间信息将用来改进控制策略 1. 模拟退火算法的原理 1.1 概念 模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。 模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以一定的概率准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果。 1.2 状态空间与邻域函数 状态空间也称为搜索空间，它由经过编码的可行解的集合所组成。而邻域函数应尽可能满足产生的候选解遍布全部状态空间。其通常由产生候选解的方式和候选解产生的概率分布组成。候选解一般按照某一概率密度函数对解空间进行随机采样获得，而概率分布可以为均匀分布、正态分布、指数分布等。 1.3 状态转移概率（Metropolis准则） 状态转移概率是指从一个状态转换成另一个状态的概率，模拟退火算法中一般采用Metropolis准则，具体如下：$$P = \\begin{cases}1 &amp; E(x_{new})&lt;E(x_{old}) \\exp(-E(x_{new})&lt;E(x_{old})\\over{T} &amp; E(x_{new})\\geq E(x_{old})\\end{cases}$$其与当前温度参数T有关，随温度的下降而减小。 1.4 冷却进度表 冷却进度表是指从某一高温状态T向低温状态冷却时的降温函数,设时刻的温度为T(t)，则经典模拟退火算法的降温方式为：$$T(t)={T_0\\over{lg(t+1)}}$$快速模拟退火算法的降温方式为：$$T(t) = {T_0\\over{t+1}}$$另外还有其他的降温函数，其实只是收敛的速度不同罢了。 1.5 初始温度 一般来说，初始温度越大，获得高质量解的几率越大，但是花费的时间也会随之增加，因此，初温的确定应该同时考虑计算效率与优化质量，常用的方法包括： (1)均匀抽样一组状态，以各状态目标值的方差为初温。 (2)随机产生一组状态，确定亮亮状态间的最大目标值差，然后根据差值，利用一定的函数确定初温，如：$$T_0 = -{\\Delta_{max}\\over P_r}$$其中Pr为初始接受概率。 (3)根据经验公式给出 1.6 循环终止准则 内循环终止准则： （1）检验目标函数的均值是否稳定 （2）连续若干步的目标值变化较小 （3）按一定的步数进行抽样 外循环终止准则 （1）设置终止温度 （2）设置外循环迭代次数 （3）算法搜索到的最优值连续若干步保持不变 （4）检验系统熵是否稳定 Python实现过程： 下面便通过python求解开头提到的问题，首先定义函数，然后通过pyplot看看函数在[0,100]上的大致图像： 12345678910111213141516from __future__ import divisionimport numpy as npimport matplotlib.pyplot as pltimport math#define aim functiondef aimFunction(x): y=x**3-60*x**2-4*x+6 return yx=[i/10 for i in range(1000)]y=[0 for i in range(1000)]for i in range(1000): y[i]=aimFunction(x[i])plt.plot(x,y)plt.show() img 可以看到最小值大概在48左右，通过求导计算得到最小值为48.45。 接下来便构造SA模型： 定义初温、低温阈值并通过随机得到初始x，同时定义时刻t。通过均匀分布构造邻域函数，同时设定内循环次数为50次，降温函数使用$$T(t) = {T_0\\over{t+1}}$$代码实现如下： 12345678910111213141516171819202122232425262728T=1000 #initiate temperatureTmin=10 #minimum value of terperaturex=np.random.uniform(low=0,high=100)#initiate xk=50 #times of internal circulation y=0 #initiate resultt=0 #timewhile T&gt;=Tmin: for i in range(k): #calculate y y=aimFunction(x) #generate a new x in the neighboorhood of x by transform function xNew=x+np.random.uniform(low=-0.055,high=0.055)*T if (0&lt;=xNew and xNew&lt;=100): yNew=aimFunction(xNew) if yNew-y&lt;0: x=xNew else: #metropolis principle p=math.exp(-(yNew-y)/T) r=np.random.uniform(low=0,high=1) if r&lt;p: x=xNew t+=1 print(t) T=1000/(1+t) print (x)print(aimFunction(x)) 经过循环输出x与y，结果如下： ​ 48.45411386249023 -55082.24210065413 可以看到SA算法很好的逼近了最优解。 参考文章 模拟退火算法与python实现","categories":[{"name":"智能算法","slug":"智能算法","permalink":"https://albert-5.cn/categories/智能算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/tags/算法/"},{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://albert-5.cn/tags/模拟退火/"}]},{"title":"Leetcode","slug":"Leetcode","date":"2019-05-16T08:29:30.000Z","updated":"2019-10-20T12:11:40.107Z","comments":true,"path":"2019/05/16/Leetcode/","link":"","permalink":"https://albert-5.cn/2019/05/16/Leetcode/","excerpt":"","text":"领扣–引领新时尚 1. 两数之和问题给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法1–暴力解法 思路： 给定一个数组和一个特定的目标值，对每一个数进行遍历，然后利用两层循环遍历的值进行if条件判断，如果相等，则返回下标；否则返回None. 具体实现： class Solution:def twoSum(self, nums,target): for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] == target: return [i, j] else: continue nums = [2,7,11,15]target = 9solution = Solution()print(solution.twoSum(nums,target)) 缺点：过于暴力，两层循环使得时间代价过高。 时间复杂度：O(n^2^) 解法2–较优化算法 思路： 相比于暴力解法，此法优化了双层循环 一次循环遍历，然后用目标值减去数组中的每一个值，然后判断减去得到的值是否在数组中，进而再判断小标问题； 具体实现： 1234567891011121314&gt; class Solution:&gt; def twoSum(self, nums, target):&gt; for i in range(0, len(nums)):&gt; a = target - nums[i]&gt; if a in nums:&gt; b = nums.index(a)&gt; if b != i:&gt; return [i, b]&gt; &gt; nums = [2, 7, 11, 15]&gt; target = 9&gt; solution = Solution()&gt; print(solution.twoSum(nums, target))&gt; 解法3–优化算法 &lt;来源于网络，怪自己 :sweat:···&gt; 思路： 优解:创建一个字典，通过循环把 target - nums[x]作为键，x作为值存入字典，边存边检查当前正在处理的nums[x]是否存在于字典中，存在：返回字典中nums[x]的值，和当前正在使用的x的值。 具体实现： 1234567891011121314&gt; class Solution:&gt; def twoSum(self, nums, target):&gt; dic = &#123;&#125;&gt; for x in range(len(nums)):&gt; if target - nums[x] in dic:&gt; result = [dic[target - nums[x]], x]&gt; return result&gt; dic[nums[x]] = x&gt; &gt; nums = [2, 7, 11, 15]&gt; target = 9&gt; solution = Solution()&gt; print(solution.twoSum(nums, target))&gt; 2. 回文数问题判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 解法1–较优化解法 思路： 将所给数字转化为字符串，因为回文数是具有对称性的，所以比较字符串的第一位和最后一位、第一次位和末尾次位 ······但是由于一位数以及负数和末尾为0的数的特殊性，应该加以判断。 由于对称性，所以考虑字符长度，奇偶数：通过模2判断只需要判断一般就可以了。 实现： 12345678910111213141516171819202122232425262728293031&gt; class Solution(object):&gt; &gt; def isPalindrome(self, x):&gt; n = str(x)&gt; print(n)&gt; m = len(n)&gt; count = 0&gt; if m == 1:&gt; return True&gt; elif n[0] == \"-\" or n[m-1] == '0':&gt; return False&gt; elif m % 2 == 0:&gt; for i in range(int(m/2)):&gt; if n[i] == n[m-1-i]:&gt; count += 1&gt; else:&gt; return False&gt; else:&gt; for i in range(int((m+1)/2)):&gt; if n[i] == n[m-1-i]:&gt; count += 1&gt; else:&gt; return False&gt; if count == int(m/2) or count == int((m+1)/2):&gt; return True&gt; &gt; &gt; X = 0&gt; solution = Solution()&gt; print(solution.isPalindrome(X))&gt; 时间复杂度为 O(n) 执行代码，运行时间108 ms","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://albert-5.cn/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/tags/算法/"},{"name":"两数之和","slug":"两数之和","permalink":"https://albert-5.cn/tags/两数之和/"},{"name":"回文数","slug":"回文数","permalink":"https://albert-5.cn/tags/回文数/"}]},{"title":"sublime配置有关问题","slug":"sublime配置有关问题","date":"2019-05-06T07:42:54.000Z","updated":"2019-05-06T07:46:34.288Z","comments":true,"path":"2019/05/06/sublime配置有关问题/","link":"","permalink":"https://albert-5.cn/2019/05/06/sublime配置有关问题/","excerpt":"","text":"Answer &amp;&amp; Question安装Package Control安装Package Control有两种方式，第一种方式为：在控制台中输入安装命令。调出控制的方式为：Ctrl+`。Sublime Text2和Sublime Text 3的命令如下： sublime text 2 1import urllib2,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation') sublime text 3 1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 这一种方法我试了，好像没有卵用，打开console时会出现错误—由于连接方在一段时间后没有正确答复或者连接的主机没有反应，连接尝试失败 So, 失败告终，唯能另寻别发 后来在网上找了大量文章，看了好多解决方法，但大多无用，因为那个官网是无法访问的，好像是因为ip6什么的问题，但是除了······*^注释1这样可以下载得到package control压缩包 万事大吉？？？想的可真多啊 ^-^ 下载之后在指定的preferences/browser packages进行拖放下载好且解压好的文件，之后看是否出现package setting，如果出现，Ctrl+shift+P，输入install package，你就会看到这个包 也就说明 You are ok 但是不可避免出现 there are no packagesa avaliable for installation的错误。 怎么办？？？？ 可愁死我了······· 找了资料发现是这个原因 在利用sublime进行插件下载时，sublime会调用channel_v3.json文件，点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default，可以看到该文件是放置在网络中进行读取的，而由于GFW的原因，导致无法读取该文件（但是竟然可以直接访问？？），这也就是导致插件无法下载的原因 所以只需要修改这个json文件即可 方法也有很多，这是我在知乎上看到的https://www.zhihu.com/question/26373122/answer/156739767 但是我没有成功，嘤嘤嘤，主要是因为json文件没法下载 后来找到了,给你 添加到本地文件夹，然后在点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default看到一个channels，后面的路径修改下就可以了 别慌！！ 记得试一下哦，老方法， Ctrl+shift+P，输入install package，你就可以开始玩耍啦~~ 学习之中遇到的问题就记录下来了，小白上路，若有问题可联系me^contact me,欢迎指正。","categories":[{"name":"sublime","slug":"sublime","permalink":"https://albert-5.cn/categories/sublime/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://albert-5.cn/tags/sublime/"},{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"}]},{"title":"摄影理论篇","slug":"摄影","date":"2019-05-03T03:00:03.000Z","updated":"2019-10-20T12:01:10.120Z","comments":true,"path":"2019/05/03/摄影/","link":"","permalink":"https://albert-5.cn/2019/05/03/摄影/","excerpt":"","text":"[TOC] 一. 人像摄影1. 概念所谓人像摄影，是指通过摄影的形式，在照 片上用鲜明突出的形象描绘和表现被摄者相 貌和神态的作品，它是被摄者的影像写真。 • 一幅优秀的人像摄影作品，是许多成功因 素的总和：神情、姿态、构图、照明、曝 光、制作均要达到较高的境界，它们是一 个总体的各组成部分。 • 不管是在现场中抓拍的还是在照相室里摆 拍的，不管是否带有情节，只要是以表现 被摄者具体的外貌和精神状态为主的照片， 都属于人像摄影的范畴。 • 人像摄影的景别，主要有以下几种： （1）特写 以表现被摄者的面部特征为 主要目的 （2）近景 它以表现人物的面部相貌为主 背景环境在画面中只占极少部分 （3）半身 以脸部面貌为主要表现对象以外 还常常包括手的动作。 （4）全身 使人物的形象与背景环境的特点 互相结合，都能得到适当的表现 • 拍摄方向大体上分作: • 正面人像 • 七分面人像 • 三分面人像 • 侧面人像 • 调子影响视觉和情感。人像摄影可以分作高调、低调、一股影调、软调、硬调五种 影调。 高调：画面的影调构成以亮调子为主，尽量避免或者少用暗调子。 人像照片的背景要明亮、干净、均匀，但最好又保留一点淡淡的层次，以便衬托出被摄者更亮的部位。 • 夜景人像 1）直接使用相机的夜景人像模式2）使用AV档，曝光组合主要以夜景的背景 为参考，第二张开启闪光灯，照亮人像， 难点在于前后用光均衡。 2. 技巧人像焦段的选择 • 1)镜头焦段选择：28-180 毫米皆可以，但是 50-135毫米最常用。尤其推荐85mm定焦镜 头。• 2）光圈控制，适度虚化背景，突出人物主 体。F2.0-F5.6常用 拍摄人像小诀窍 • 1）相机的测光模式为点测，点测人像的脸 部，曝光增加0.5-1档，使得皮肤美白； • 2）相机有人像和美肌美肤模式请设置 • 3）化妆，服装，饰物非常重要； • 4）反光板或者外置闪光灯补光要常用，减 弱脸部阴暗，另外使得眼睛有眼神光； • 5）多和模特交流，减少她的紧张； • 6）尝试多种拍摄视角和运光方式，身体可 以尝试多种POSE； • 7）事先应该确定风格。 二. 新闻摄影1. 要求 1新闻摄影 : “新” :首先是个新字。应该是 新鲜事、新闻，别人不知道的、没见过的。 2纪实:反映真实的现场，让未能身临其境者 如同亲历。 3具备这两点后，新闻还要有社会价值。 2. 新闻摄影5W  何时（when）；  何地(where)；  何人(who)；  何事(what)；  为何(why)。 瞬间成为永恒，成为历史的见证 不要细细追求技术完美，抓住瞬间才是关键 3. 会场类相片 相机参数： 1.档位选择：首先考虑使用A档 若光线较差，使用A档则会出现曝光时间过长，照片模 糊，此时考虑换成M档，将快门速度设置在1/15至1/60 之间 2.光圈：合理，F2.8-F5.6拍摄人物，F8拍摄全 3.ISO感光度：灯光较亮—100-800 灯光一般—800-1600 灯光较暗—1600以上 4.白平衡：自动白平衡 日光灯 荧光灯 拍摄曝光和器材要求 会议拍摄曝光和器材要点：1）大功率外置闪光灯必备，最 好套好小型柔光罩；2）镜头折合后焦距24-105mm；3）充分利用会场内的现场光；4）ISO设置到 800-1600；5）控制光圈，使得闪光灯和现 场光平衡。 1.正面全景 2.近景特写 3.角落全景 4.台上全景 5.颁奖合 三. 建筑、红外、LOMO、针孔摄影、延时摄影、超现实摄影1. 建筑摄影1. 要点• 建筑的形体（体现建筑空间的深度，感受到三维空间的真实世界，其表现在运用视觉透视和利用阴影来提高建筑的空间感）、轮廓（当建筑处在背光面时，光线从建筑的背面射来，在强光的烘托下，轮廓剪影成了建筑的主要视觉要素，而空间、质感、色彩等等其它要素统统都被隐没在阴影之中。）、线条、尺度比例、质感和色 彩是建筑摄影中视觉要素的主要成分。• 在大多数情况下，上述要素并不是以相同 的地位在画面上同时出现，特别是当摄影 师需要突出表现建筑的某一特征时更是如 此。在画面中需要重点突出那些视觉要素 取决于照片的用途，也取决于摄影师的创 作意图和创作风格。 • 点 线 面 立体空间是建筑摄影最主要观察的 2. 失真方法普通135相机和镜头，站在地面拍摄，产生透视失真，图像有 汇聚效应，头小脚大。但是，大画幅或者技术相机通过，前镜头板的上升，完美解决该问题。 3. 控制建筑透视失真方法 • 35mm相机及其透视调整镜头 • 目前尼康、佳能、徕卡、美能达等相机厂 均生产透视调整镜头，如佳能相机的TS-E 24mm、45mm和90mm透视调整镜头，徕卡 R系列相机的28mm透视调整镜头，美能达 相机的35mm透视调整镜头，尼康相机的 28mm、35mm 和 85mm透视调整镜头。 建筑摄影顾名思 义，其主要记录 和表现对象为各 种建筑以及由于 建筑物的存在而 产生的空间关系 和状态。 4. 透视最初研究透视是 采取通过一块透明的平面去看景物的方法 ，将所见景物准确描画在这块平面上，即 成该景物的透视图。后遂将在平面画幅上 根据一定原理，用线条来显示物体的空间 位置、轮廓和投影的科学称为透视学 使用中等焦距镜头在一定距离上拍摄建筑标志性雕塑可以避免近距离拍摄是因透视加剧而 产生的比例失真，这时建筑、雕塑、人的比例关系更为客观 5. 建筑摄影的6个使用拍摄建议 1、利用反射或倒影增加美 2、利用好几何线条 3、利用人工光源衬托 4、寻找兴趣点 5、俯视营造纵深感 6、HDR、移轴效果、全景拼接、鱼眼扭曲…… • 建筑摄影八要素：角度、光线、线条、云 彩、框架的运用、影子、景观、人物； • 视觉要素：形体、轮廓、线条、尺度比例 、质感、色彩…… 2. LOMO摄影 Lomo有了新含义，Lomo是Let Our lives be Magic and Open lomo是缩写形式，原英文是Let our life be magic and open（意即让我们的生活开放、 有魔力）。在相机里指简单、随意的风格 关于LOMO的十大原则 1.Take your Lomo every-where you go .走到哪儿,就把Lomo带到哪儿。 2.Use it anytime-day and night .Lomo不分昼夜。 3.Lomography is not an interference in your life, but a part of it.不用担心Lomo打扰 你的生活,它就是生活的一部分。 4.Shoot from the hip. 想拍哪儿就拍哪儿。 5.Approach the objects of your lomographic desireas close as possible.近点儿,再近 点儿。 6.Don’t think.什么都不用想。 7.Be fast.还要快。 8.You don’t have to know beforehand what you’ve captured on film. 不必了解你要拍 什么。 9.You don’t have to know beforehand what you’ve cap-tured on film…and afterward seither.更不必了解你拍到了什么。 10.Don’t worry about the rules.把以上的9条都忘掉。 3. 红外摄影红外摄影是一种较为另类的拍摄方式，利 用红外感光设备与红外滤镜配合，有别于 传统的黑白彩色照片，拍出的画面给人以 强烈的震撼让人爱不释手；同时红外线相 对可见光对一些材料及衣料具有穿透能力 （薄化纤、烟雾、水气…），能拍出神奇的 透视效果 红外摄影技术的获得 • 1）将价格很低的数码相机CMOS或者CCD传 感器前的低通滤镜拆除，镜头前加红外滤 镜。改造后只能用于红外摄影。 1.改装F828作为红外相机是极为正确 1.28-200mm简直是红外版的一镜走天下，何况还有2.0-2.8的大光圈！ 2.EVF让你时刻都能观察不一样的红外世界（单反相机怎么改也不行，光学取 景器就是光学取景器），而且F828除了EVF外还有个液晶屏也能取景（废话）， EVF和液晶屏能随机背一起进行上下旋转，极大扩展了构图的可能性！ 3.不像单反相机是对焦和感光元件相互分离的设计，F828的感光元件即对焦 元件，因此改成红外机后没有跑焦问题！4.镜头前是58mm螺纹，不需拆机即可随意更换各种波段的红外滤镜！（改红 外的单反这条最悲剧）5.在液晶屏中实时电子测光，红外线下曝光准确，所拍即所见！ • 2）不破坏现有相机的功能，镜头前直接加 红外滤镜。 • 1. 喜欢浓烈色彩的, 可以选择630nm 或者更低波长的590滤镜, 自定义 白平衡后, 原片一般天空呈亮红偏棕色,或者说是琥珀色, 植物树叶呈蓝 色. 红蓝通道调换后(后文有说明)天空蓝色饱和度高, 树叶黄色或者金 黄色.• 2. 喜欢适中的, 可以选择680, 原片天空呈棕红色, 树叶浅蓝, 通道调换 后天空比较接近正常天空的蓝色, 树叶呈浅黄色.• 3. 喜欢较为纯正红外但又希望带有色彩的, 可以选择720滤镜, 原片天 空呈暗棕红色, 饱和度较低, 树叶白, 通道调换后天空暗浅蓝色, 树叶白. 760滤镜理论上来说有是有颜色的,实际颜色很浅, 几乎是黑白的.• 4. 喜欢纯红外的可以选择850nm滤镜, 无色彩, 天气好时, 天空深暗, 可以得到反差较高的图片, 对于雾霾有更好的穿透力. 4. 针孔摄影• 1）利用小孔成像的原理，抛弃我们已经使 用习惯的光学镜头；• 2）可以得到四周有暗角的、中心稍微清晰 的图像；• 3）一般来说，针孔的透视关系和广角镜头 接近； 特点 • 模糊、变形、色彩诡异的影像• 拍摄风景也有朦胧美感• 具有超现实主义的图像风格 针孔摄影实现的方法• 1）购买专门的针孔相机，一般使用胶卷• 2）利用数码单反改造 5. 延时摄影延时摄影是以一种较低的帧率拍下图像或者视频，然后用正常或者较快的速率播放画面的摄影技术 方法• 1）相机没有内置延时摄影的，按照间隔时 间逐张拍摄，可用电子定时快门自动触发 ，后期软件合成；• 2）直接使用相机内置延时摄影APP，例如 sony相机，设置好参数，主要是间隔时间和 总时长。 拍摄时间间隔参考• 1)在拍摄城市白天的车流和行人时，间隔时 间设置为 1秒，拍摄间隔小于1秒 • 2)在拍摄城市夜晚的车流时，间隔时间设置 为2秒到5秒之间，机身设置快门速度为间 隔时间减1秒。 • 3)在拍摄天空云层运动时，依云层运动速度 ，设置间隔时间为3秒到10秒不等，云层运 动速度越慢，间隔时间最越长。 延时摄影的分类• 1）固定场景延时摄影，相机固定不动，拍 摄内容部分移动；• 2）移轴延时摄影，相机适当缓慢匀速移动 ，同时拍摄内容部分运动，比1显得丰富有 趣。 四. 纪实摄影摄影从诞生之日开始就赋予了“真实记录” 的使命 现代公认的摄影术的诞生是1893年，法国人画家 达盖尔银版摄影技术正式问世 把真实的瞬间保留下来，是摄影对历史记录的伟大贡献 摄影的最主要的美学特征也 是他的纪实性。 艺术摄影：所谓艺术摄影就是最大限度的 使用视觉形式和各种摄影手段，表达摄影 师的艺术思想和哲学理念。他不受真实性 的影响，不受摄影手段的限制，也不受时 间和空间的制约。 艺术摄影和纪实摄影是否真实这点上区别 很大 纪实性摄影：所谓纪实性摄影就是对任何真实事件、场景、物体的现实现场的记录。 纪实摄影归类为两个方面:1）关于自然和物;2）关于社会与人。 决定性瞬间是纪实摄影的根本 环境的决定性瞬间 前景的决定性瞬间， 背景的决定性瞬间， 光影的决定性瞬间所组成。 人物的决定性瞬间 神态的决定性瞬间， 交流决定性瞬间， 运动决定性瞬间所组成。 纪实摄影的拍摄方法纪实摄影不是艺术，画面的美和光影 的斑斓不是他的追求目标。 他的意义在于 是否真实的记录了历史，纪实摄影作品的好坏有 它自己的标准  照片所承载的信息要准确。就是使读者一看就明 白，照片说的是什么意思。表达的是什么观点和 立场。 纪实摄影的拍摄原则就是；真实的记录，不对正在发生的事件做任何干涉和影响。使事件按照自己的发展规律发展，不论事件是好是坏。 构图原则 1）照片所表现的事件真实而有现场感 短焦距镜头的使用，使得能较好的 保证现场感的体现 利用标准镜头的透视关系和视角最接近 人类的眼睛，所拍摄的作品符合人们的习 惯 28-50mm之间的焦距，比较符合纪实 摄影的要求 2）构图的形式要适合视觉的习惯 3）视觉中心构图，就是把主体安放在视觉中 心的位置上，利于读者注意画面主体，明确主 体，清楚事件的主体是在什么环境下运作的。 纪实摄影的拍摄方法 1）守株待兔法： 2）声东击西法 3）掩护法： 4）突然袭击法 5）逼迫法： 6）盲拍法 7）最合理的做法是，和被拍摄对 象沟通聊天，乃至和他一起生活 很长时间，深入了解他并记录他 适当 提高ISO，ISO400-1600，ISO自动最 合理了。光圈适当缩小，F2.8、 F4 快门 保持高速。 拍摄经验 1）置于AV光圈优先档；  2）光圈 F2.0-F4.0（35mm-50mm镜头）；  3）矩阵测光，80%的照片能够合适曝光。只要 不过曝光，后期可以处理；  4）ISO随时设置，注意快门是否低于安全快门 速度（镜头焦距的倒数），尽量不低于1/125S. 如果图简单，ISO设置成AUTO  5）触摸屏相机极大的优势，对焦点所摸所得。  6）看准时机，连拍多张。 纪实摄影三个关键点 1）寻求题材：关注普通人的生活，但是关 注的题材带有社会的共性。对社会现象记 录和深度发掘； 2）观察：带着探究本质的精神去观察现象 3）思考：深入题材，独特的现象记录，思 考所记录的表现和题材背后的内在本质联 系·。 纪实摄影前期选题思考  1）人文纪实的最大的难题不是如何拍，而是拍什 么？  2）宏观观察社会，微观记录。从社会具体现象来 表达社会特征；  3)走出猎奇误区，不要觉得拍摄一些旅游中不常见 的少数民族生活就肯定是好作品，拍摄你最熟悉的 生活；  4）唯美误区，形式至上的误区；  5）影赛的误区，那是极大的误导；  6）突出时代，远离抽象，眼下习以为常的现象十 年后说不定觉得好有趣味好有意义；","categories":[{"name":"摄影","slug":"摄影","permalink":"https://albert-5.cn/categories/摄影/"}],"tags":[{"name":"人像摄影","slug":"人像摄影","permalink":"https://albert-5.cn/tags/人像摄影/"},{"name":"LOMO摄影","slug":"LOMO摄影","permalink":"https://albert-5.cn/tags/LOMO摄影/"},{"name":"红外摄影","slug":"红外摄影","permalink":"https://albert-5.cn/tags/红外摄影/"},{"name":"延时摄影","slug":"延时摄影","permalink":"https://albert-5.cn/tags/延时摄影/"}]},{"title":"toefl & ielts","slug":"toefl-ielts","date":"2019-04-28T03:50:51.000Z","updated":"2019-08-04T09:02:41.097Z","comments":true,"path":"2019/04/28/toefl-ielts/","link":"","permalink":"https://albert-5.cn/2019/04/28/toefl-ielts/","excerpt":"","text":"TOEFL托福是美国教育考试中心开发出来的给非英语国家学生的英语水平测试 1、认可国 北美国家（特别是美国）包括日本对托福成绩的接受度较高； 英联邦国家（英国、荷兰、加拿大、澳大利亚、新西兰、瑞士等）更接受甚至只接受托福成绩； 2、考试形式雅思和托福的考试内容也不相同，虽然都是对“听说读写”四种英语能力的测试，但是雅思更加注重生活应用，词汇量没有托福要求的那么多；而托福更加注重学术方面，对专业性的要求更高一点 托福是纯机考，也就是说不管是听力、阅读还是写作，甚至口语都是对着一台电脑，以“人机”的方式进行考核的。 3、分数分配托福是四项单项各30分，总计120分，最后几项分数加起来为总成绩；考试时间大概在4个小时左右，可能会有加试的情况； 其中，托福成绩在100分以上是不错的分数 有限期为两年 4、考试费用 项目 金额 托福网考考试费 1985 逾期报名附加费 310 转考费 620 恢复已取消的成绩 154 成绩赠送费（每份） 146 口语或写作单项复议 615 口语和写作双项复议 1229 托福复习套餐Prem(不包含考试费) 1086 托福复习套餐prep 395 折扣报名费 1716 考费差额 1 44 考费差额 2 224 考费差额 3 1104.5 IELTS1、认可国雅思是英国大使馆文化教育处来出题的 相对的英国目前大部分高校只认可雅思成绩 2、考试形式 雅思则是笔试 +面试的形式，口语环节是面对面直接和考官交流的，分数的弹性相对更大一点。对于喜欢交流的人而言考雅思更能会更加有利。 3、分数分配雅思的四项单项都是九分满分制，最后以四项平均分定为最终分数，一般情况下，雅思在7分以上是不错的成绩 有效期为两年","categories":[{"name":"English","slug":"English","permalink":"https://albert-5.cn/categories/English/"}],"tags":[{"name":"toefl","slug":"toefl","permalink":"https://albert-5.cn/tags/toefl/"},{"name":"ielts","slug":"ielts","permalink":"https://albert-5.cn/tags/ielts/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-22T15:42:22.451Z","updated":"2019-08-04T09:02:02.983Z","comments":true,"path":"2019/04/22/hello-world/","link":"","permalink":"https://albert-5.cn/2019/04/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://albert-5.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://albert-5.cn/tags/hexo/"}]},{"title":"sort_algorithm","slug":"sort-algorithm","date":"2019-03-28T09:47:54.000Z","updated":"2019-06-14T15:38:00.569Z","comments":true,"path":"2019/03/28/sort-algorithm/","link":"","permalink":"https://albert-5.cn/2019/03/28/sort-algorithm/","excerpt":"","text":"一、概念排序算法是一种能将一串数据按照特定顺序进行排列的一种算法 稳定性: 稳定排序算法会让原本有相等数值的记录维持相对顺序，也就说当有两个相等的数据A，B时，且原本A在B的前面，则在排序后A仍然是在B的前面，这就是稳定性的概念； 二、冒泡排序1、啥子叫冒泡排序 它是一种较为简单的排序算法，具体过程就是遍历所要排序的数列，每一次比较两个数，如果他们顺序错误则交换顺序，直至所有的数据交换完毕，也就是完成了数列的排序；由于在交换过程中，最小的元素会处于顶端的位置，所以叫做冒泡排序 。 2、过程分析 在实现冒泡排序的过程中，每次循环之后，数列中最大的元素移动到了最末端，然后在进行下一次的循环遍历，选出次大的元素，继续循环，直至排完序，则最小的处在顶端的位置 3、实现12345678910111213141516171819202122def bubble_sort(alist): for j in range(len(alist)-1): for i in range(0，len(alist)-1-j): # 操作下标而不是直接作用于元素上 if alist[i] &gt; alist[i+1]: alist[i],alist[i+1] = alist[i+1],alist[i] # 优化情况def bubble_sort(alist): for j in range(len(alist)-1): count = 0 # 记录交换的次数 for i in range(0,len(alist)-1-j): if alist[i] &gt; alist[i+1]: alist[i],alist[i+1] = alist[i+1],alist[i] count += 1 if count is 0: # 如果count为0，则说明没有进行交换 break if __name__ == \"__main__\": li = [1,2,6,4,12,9] bubble_sort(li) print(li) 说明： 最优时间复杂度为O(n) &lt;遍历一遍发现全都排好了&gt; 最坏时间复杂度为O(n^2) 稳定 三、选择排序1、思想一组数据相当于分成了两个部分，后一部分是待排数列，初始默认第一个元素是最小值，然后从这些待排的数列中进行遍历找到最小值并记录下标位置，然后与记录的初始最小值比较，如果找到的小于初始值则进行交换，然后继续遍历；也就是说,整个过程就是在找最小值。 2、实现123456789def select_sort(alist): '''选择排序''' n = len(alist) for j in range(n-1): min_index = j for i in range(j+1,n-1): if alist[min_index] &gt; alist[i]: min_index = i alist[j], alist[min_index] = alist[min_index], alist[j] 时间复杂度：O(n^2) 稳定性：简单的考虑这种情况，在一个乱序的列表中[11,23,12,23,6],排序时第一个23较大，则在排序时会由于交换而移动到最后面，则在排列第二个23时，因为它不比第一个23大，所以不变化，由此可见，二者交换了顺序，稳定性就是不稳定 四、插入排序1、思想通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 2、实现12345678910111213def insert_sort(alist): '''插入排序''' n = len(alist) # j表示循环次数，也即是有多少个元素执行此过程 for j in range(1, n): i = j # i是表示从从待排序列中取出第一个，然后进行扫描比较 while i &gt; 0: if alist[i] &lt; alist[i-1]: alist[i], alist[i-1] = alist[i-1], alist[i] i -= 1 else: break 3、时间复杂度最优时间复杂度: O(n) &lt;数列已按照升序排列，这个时间复杂度仅仅是遍历的时间&gt; 最坏时间复杂度: O(n^2) 稳定性:稳定 五、希尔排序1、概念它是插入排序的一种，也称为缩小增量排序，是直接插入排序算法的一种更为高效的改进版；但是它是不稳定的。具体思想就是把数据按照下标的一定增量进行分组，然后对每一个组进行插入排序，随着增量的一步步减少，每一组包含的数据越多，当增量为1时，整个排序完成！ 2、实现12345678910111213def shell_sort(alist): n = len(alist) gap = n // 2 # 确定步长 while gap &gt;= 1: for j in range(gap,n): i = j while i &gt; 0: if alist[i] &lt; alist[i-gap]: alist[i],alist[i-gap] = alist[i-gap],alist[i] i -= gap else: break gap //= 2 最优时间复杂度: 无法确定 最坏时间复杂度: O(n) 稳定性: 不稳定 六、快速排序1、思想 先从给定数列中取出一个基准数据值，记为x 排序过程中，小于x的数据全放在左边，大于x的数据全放在其右边 然后再次重复上述步骤即可 2、实现123456789101112131415161718192021def quick_sort(alist,first,last): if first &gt;= last: return mid_value = alist[0] low = first high = last while low &lt; high: # high左移 while low &lt; high and alist[high] &gt;= mid_value: high -= 1 alist[low] = alist[high] # low右移，在判断里面进行移动low的值以防它移动过度 while low &lt; high and alist[low] &lt; mid_value: low += 1 alist[high] = alist[low] alist[low] = mid_value # 此时low的位置就是初始的那个值 # 递归使用函数本身，快排左边 quick_sort(alist,first,low-1) # 递归快排右边 quick_sort(aliist,low+1,last) 最优时间复杂度： O(n*logn) 最坏时间复杂度： O(n^2) # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项 稳定性：不稳定 七、归并算法1、思想 &nbsp;&nbsp;分而治之，就是将一组待排序列向下均分、均分、均分······直至每一个小分组中只有一个元素，然后向上走进行合并操作，以致达到排序的目的 2、实现1234567891011121314151617181920212223def merge_sort(alist): '''归并排序''' # 分而治之，先进行分的操作 n = len(alist) if n &lt;= 1: return alist mid = n/2 # 分的结果为两个新的列表left 和 right;以下是递归操作 left = merge_sort(alist[:mid]) right = merge_sort(alist[mid+1:]) left_pointer, right_pointer = 0,0 result = [] while left[left_pointer] &lt; len(left) and right[right_pointer] &lt; len(right): if left[left_pointer] &lt;= right[right_pointer]: result.append(left[left_pointe]) left_pointer += 1 else: result.append(right[right_pointer]) right_pointer += 1 result += left[left_pointer:] result += right[right_pointer:] return result#----------------------------------------------------------- 最优时间复杂度：O(n*logn) 最坏时间复杂度：O(n*logn) # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项 稳定性：稳定","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://albert-5.cn/tags/排序算法/"},{"name":"插入排序","slug":"插入排序","permalink":"https://albert-5.cn/tags/插入排序/"},{"name":"归并排序","slug":"归并排序","permalink":"https://albert-5.cn/tags/归并排序/"},{"name":"快速排序","slug":"快速排序","permalink":"https://albert-5.cn/tags/快速排序/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2019-03-25T09:54:05.000Z","updated":"2019-04-29T09:56:46.195Z","comments":true,"path":"2019/03/25/栈和队列/","link":"","permalink":"https://albert-5.cn/2019/03/25/栈和队列/","excerpt":"","text":"一、python递归函数深度限制python使用递归函数会受到递归深度的限制，大概是900多点(因为100次的时候就会报错：maximum recursion depth exceeded in comparison)，嘿嘿嘿 解决方法 导入python中 sys模块，import sys 然后使用 sys 下的 setrecursionlimit去重新规定它的限制 **ps:但是要注意一点设置Python解释器堆栈的最大深度以限制。此限制可防止无限递归导致C堆栈溢出并导致Python崩溃。 最高可能的限制取决于平台。当用户需要深度递归的程序和支持更高限制的平台时，用户可能需要设置更高的限制。这应该小心，因为太高的限制可能导致崩溃 二、栈stack1、栈的操作**· stack()创建一个空栈 · push()添加一个新的元素item到栈顶 · pop()弹出栈顶元素 · peek()返回栈顶元素 · is_empty()判断栈是否为空 · size()返回栈的元素个数** 2、栈的代码实现123456789101112131415161718192021222324252627282930class Stack(object): '''栈''' def __init__(self): self.__list = [] # 建立私有容器 def push(self,item): ''添加一个新的元素到栈顶'' self.__list.append(item) # self.__list.insert(0,item) 在栈顶插入时复杂度为n,相反在尾部时复杂度就为1 def pop(self): '''弹出栈顶元素''' self.__list.pop() # self.__list.pop(0) return def peek(): '''返回栈顶元素''' if self.__list: return self.__list[-1] else: None def is_empty(self): '''判断栈是否为空''' return not self.__list def size(self): '''返回栈中元素的个数''' return len(self.__list if __name__ == \"__main__\": s = Stack() 三、队列queue1、只允许在一端进行插入操作，另一端进行删除操作的线性表2、队列的实现· queue()创建一个空的队列 · enqueue(item)添加一个新的元素item到队列中 · dequeue()从队头删除一个元素 · is_empty()判断队列是否为空 · size()返回队列中的元素个数 1234567891011121314151617181920212223class Queue(object): '''队列''' def __init__(self)： self.__list = [] def enqueue(self,item): '''往队列中添加一个item元素''' self.__list.append(item) # self.__list.insert(0,item) # 无论选择哪个总有一个的复杂度是O(1)，另一个是O(n)，具体选择根据自己功能哪个用的多 def dequeue(self): '''从队列中删除一个元素''' return self.__list.pop() def is_empty(self): '''判断一个队列是否为空''' return self.__list == [] def size(self): '''返回队列的大小''' return len(self.__list) if __init__ == \"__main__\": s = Queue() s.enqueue(1) s.enqueue(2) 四、双端队列**· deque创建一个空的双端队列 · add_front(item)从队头加入一个item元素 · add_rear(item)从队尾加入一个item元素 · remove_front()从队头删除一个item元素 · remove_rear()从队尾删除一个item元素 · is_empty()判断双端队列是否为空 · size()返回双端队列的大小** 123456789101112131415161718192021class Deque(object): '''双端队列''' def __init__(self)： self.__list = [] def add_front(self,item): '''往双端队列的头部添加一个item元素''' self.__list.insert(0,item) def add_rear(self): self.__list.append(item) def pop_front(self): '''从双端队列的头部删除一个元素''' return self.__list.pop(0) def pop_rear(self): '''从双端队列的尾部取出元素''' return self.__list.pop() def is_empty(self): '''判断一个双端队列是否为空''' return self.__list == [] def size(self): '''返回双端队列的大小''' return len(self.__list) 五、链表1、单向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Node(object): '''节点''' def __init__(self,elem): self.elem = elem self.next = None # 同样可以利用python的二元组进行操作(elem) class Single_LinkList(object): '''单链表''' def __init__(self,node=None): # 就是一个内部的使用，规定一个头结点，而且这个头结点应该是私有的，因为在封装后的SingleLinkList对象中，外部能够调用的就是以下的几个函数，其他的是无法使用的，所以私有化处理了，纯粹是自己的内部函数去使用； self.__head = node def is_empty(self): '''判断链表是否为空''' return self.__head = None def length(self): '''链表长度''' # cur游标，用来移动遍历节点 cur = self.__head # count 记录数量 count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): '''链表遍历''' cur = self.__head while cur != None: print(cur.elem) cur = cur.next print(\"\\n\") def add(self,item): '''链表头部添加元素,头插法''' node = Node(item) node.next = self.__head.next self.__head = node def append(self,item): # 这里的item仅仅是数据元素，而不是节点 '''链表尾部添加元素，尾插法''' node = Node(item) if self.is_empty(): # 判断链表是否为空 self.__head = node else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node def insert(self,pos,item): # 在任意位置添加元素，pos表示需要添加元素的位置，item表示要添加的数据 '''在某个位置插入元素''' if pos &lt;= 0: self.add(item) elif pos &gt; (self.length-1): self.append(item) else: pre = self.__head # pre的用法和cur一样 count = 0 while count &lt; pos-1: count += 1 pre = pre.next node = Node(item) node.next = pre.next pre.next = node def remove(self,item): '''删除节点''' cur = self.__head pre = None while cur != item: if cur.elem == item: # 要判断此节点是不是头节点 if cur == self.__head: self.__head = cur.next break else: pre.next = cur.next break else: pre = cur cur = cur.next def search(self,item): '''查找节点是否存在''' cur = self.__head while cur is not None: if cur.elem == item: return True else: cur = cur.next return False 链表和顺序表的比较 操作 链表 顺序表 访问元素 O(1) O(1) 头部插入 or 删除元素 O(1) O(n) 尾部插入 or 删除元素 O(n) O(1) 在中间插入 or 删除元素 O(n) O(n) 六、双向链表1、操作**· is_empty()链表是否为空 · length()链表长度 · travel()遍历整个链表 · add(item)链表头部添加信息 · append(item)链表尾部添加信息 · insert(pos, item)在特定位置添加元素 · remove(item)删除节点 · search(item)查找节点是否存在** 2、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Node(object): '''节点''' def __init__(self,item): self.elem = item self.next = None self.prev = Noneclass DoubleLinkList(object): '''双链表''' def __init__(self,node=None): self.__head = node def is_empty(self): '''判断双链表是否为空''' return self.__head is None def length(self): '''双链表长度''' cur = self.__head count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): '''遍历双链表''' cur = self.__head while cur != None: print(cur.elem) cur = cur.next print(\"\\n\") def add(self,item): '''头部添加元素''' node = Node(item) node.next = self.__head.next self.__head = node node.next.prev = node def append(self,item): '''双链表的尾部添加元素''' node = Node(item) if self.is_empty(): self.__head = node else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node node.prev = cur def insert(self,pos,item): '''在双向链表的某个位置插入元素''' if pos &lt;= 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: cur = self.__head count = 0 while count &lt; pos: count += 1 cur = cur.next # 退出循环之后，cur指向pos位置 node = Node(item) node.next = cur node.prev = cur.prev cur.prev = node cur.prev.next = node def remove(self,item): '''删除节点''' # cur 游标指向头结点的时候，pre指向空，相差一个单位的距离 cur = self.__head pre = None while cur != None: if cur.elem is item: # 判断当前游标cur指向是不是在1处 if cur is self.__head: self.__head = cur.next # 判断cur.next是否为空，因为空的元素是没有prev的 if cur.next: cur.next.prev = None else: cur.prev.next = cur.next if cur.next: cur.next.prev = cur.prev break else: cur = cur.next def serch(self,item): '''查找节点''' cur = self.__head whilt cur != None: if cur.elem is item: return True else: cur = cur.next return False","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://albert-5.cn/categories/算法/数据结构/"},{"name":"python","slug":"算法/数据结构/python","permalink":"https://albert-5.cn/categories/算法/数据结构/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://albert-5.cn/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"https://albert-5.cn/tags/栈/"},{"name":"队列","slug":"队列","permalink":"https://albert-5.cn/tags/队列/"},{"name":"链表","slug":"链表","permalink":"https://albert-5.cn/tags/链表/"}]},{"title":"查找算法","slug":"查找算法","date":"2019-03-20T09:56:30.000Z","updated":"2019-06-14T15:37:49.227Z","comments":true,"path":"2019/03/20/查找算法/","link":"","permalink":"https://albert-5.cn/2019/03/20/查找算法/","excerpt":"","text":"一、二分查找1、思想二分查找又被称为折半查找，优点就是比较次数少，查找速度快，平均性能好，但其缺点是要求待查表为有序表，假设表中的元素是按照升序排列的，将表中间位置记录的关键字与查找的关键字作比较，如果两者相等，则查找成功；否者就利用中间位置记录分为前、后两个子表，如果中间位置的关键字大于查找关键字，则进一步查找前一个子表，否者就查找后一个子表，然后重复即可 2、实现123456789101112def binary_search(alist,item): '''二分查找''' n = len(alist) if n &gt; 0: mid = n/2 if alist[mid] == item: return True elif item &lt; alist[mid]: binary_search(alist[:mid],item) else: binary_search(alist[mid+1:],item) return False 3、时间复杂度问题 关于时间复杂度的问题，首先讨论最坏的情况，就是进行到最后一步才找到元素item，在这种情况下因为是二分查找法，每次都是对半的，所以一共有O(log n) 最优时间复杂度：O(1) 二、树1、概念 它是另外一种数据结构，但元素之间的关系并不是线性结构，而是一种更为复杂的结构；但是它有以下特征： 1、如果他的结构不为空，则其中就存在着唯一的起始节点，称之为树根root；2、每个节点有零个或多个子节点；3、没有父节点的节点成为根节点；4、每一个非根节点有且只有一个父节点；5、除了根节点之外，每个子节点可以分为多个不相交的子树······ 2、常用术语名称 节点的度：一个节点含有的子树的个数称为该节点的度 树的度：一棵树中，最大的节点的度 叶子节点或终节点：度为零的节点 父节点：若一个节点含有子节点，则这个节点就称为该子节点的父节点 节点的层次：从根节点开始定义起，根为第一层，根的子节点为第二层，以此类推······ 树的高度或深度：树中节点的最大层次 3、树的分类 无序树：树中任意节点的子节点之间没有顺序关系，也叫做自由树 有序树：树中任意节点的子节点之间有顺序关系 二叉树：每个节点最多含有两个子树的树 完全二叉树：对于一颗二叉树，假设其深度为d，除了第d层外，其他各层的节点数目均已经达到最大值，且第d层所有节点从左向右连续的紧密排列；==满二叉树==的定义是所有叶节点都在最底层的完全二叉树; 平衡二叉树&lt;AVL树&gt;：当且仅当任何节点的两棵子树得到高度差不超过2的二叉树 排序二叉树（二叉查找树，binary search tree）：也称为二叉搜索树、有序二叉树 ![20190330](C:/Users/DELL/Desktop/markdown%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/20190330.jpg) ​ 霍夫曼树：用于信息编码，待权路径最短的二叉树称为哈夫曼树或者是最优二叉树 B树：一种对读写操作进行优化的自平衡的二叉查找树，能够爆出数据有序，拥有多余两个子树； 树的应用场景 1、xml、html等标签的关系 2、路由协议运用了树的算法 3、mysql数据库索引 4、文件系统的目录结构 5、AI算法，机器学习中的 decision tree等 三、二叉树1、性质 在二叉树的第i层最多有2 ^i-1^ 个节点 深度为k的二叉树最多有(2 ^k^ -1)个节点 对于任意一颗二叉树，如果叶子节点数为N ~0~ ，而度数为2的节点的总数为N ~2~ ，则有N ~0~ = N ~2~ + 1； 2、实现1234567891011121314151617181920212223242526272829303132class Node(object): '''构造节点''' def __init__(self,item): '''构造左右孩子''' self.elem = item self.lchild = None self.rchild = Noneclass Tree(object): '''二叉树''' def __init__(self): self.root = None def add(self,item): node = Node(item) queue = [self.root] if self.root is None: self.root = node return # 判断队列是否为空 while queue: # 取出当前节点 cur_node = queue.pop() # 判断当前节点的左右子树是否为空 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) if cur_node.right is None: cur_node.rchild = node return else: queue.append(cur_node.right) 四、广度遍历1、思想这种遍历方法就是按照路径长度由远及近地访问节点，也即是说按照二叉树的层次遍历访问层中的每一个节点；==这种遍历无法使用递归==；在这种宽度优先遍历中，只规定了逐层访问，并没有规同一层的节点访问顺序，但从算法的角度上，必须规定一个顺序，常见的是在每一层里都从左往右逐个访问；==实现这一算法是用队列作为缓存;== 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node(object): '''构造节点''' def __init__(self,item): '''构造左右孩子''' self.elem = item self.lchild = None self.rchild = Noneclass Tree(object): '''二叉树''' def __init__(self): self.root = None def add(self,item): node = Node(item) queue = [self.root] if self.root is None: self.root = node return # 判断队列是否为空 while queue: # 取出当前节点 cur_node = queue.pop(0) # 判断当前节点的左右子树是否为空 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) if cur_node.right is None: cur_node.rchild = node return else: queue.append(cur_node.right) def breath_travel(self): '''广度优先遍历''' if self.root is None: return queue = [self.root] while queue: cur_node = queue.pop(0) print(cur_node.elem) if cur_node.lchild is not None: queue.append(cur_node.lchild) if cur_node.rchild is not None: queue.append.rchild(cur_node.rchild) 五、深度优先遍历1、思想深度优先遍历不同于广度优先遍历，其遍历有三种不同的方式: 先序遍历[^脚注1]，中序遍历[^脚注2]，后序遍历[^脚注3] 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(object): '''构造节点''' def __init__(self,item): '''构造左右孩子''' self.elem = item self.lchild = None self.rchild = Noneclass Tree(object): '''二叉树''' def __init__(self): self.root = None def add(self,item): node = Node(item) queue = [self.root] if self.root is None: self.root = node return # 判断队列是否为空 while queue: # 取出当前节点 cur_node = queue.pop(0) # 判断当前节点的左右子树是否为空 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) if cur_node.right is None: cur_node.rchild = node return else: queue.append(cur_node.right) def breath_travel(self): '''广度优先遍历''' if self.root is None: return queue = [self.root] while queue: cur_node = queue.pop(0) print(cur_node.elem) if cur_node.lchild is not None: queue.append(cur_node.lchild) if cur_node.rchild is not None: queue.append.rchild(cur_node.rchild) def preorder(self,node): '''先序遍历''' # 判断节点是否为空 if node is None: return print(node.elem) # 打印根节点 self.preorder(node.lchild) # 递归打印左子树 self.preorder(node.rchild) # 递归打印右子树 def inorder(self,node): '''中序遍历''' # 判断节点是否为空 if node is None: return self.inorder(node.lchild) # 递归打印左子树 print(node.elem) # 打印根节点 self.inorder(node.rchild) # 递归打印右子树 def postorder(self,node): '''后序遍历''' # 判断节点是否为空 if node is None: return self.postorder(node.lchild) # 递归打印左子树 self.postorder(node.rchild) # 递归打印右子树 print(node.elem) # 打印根节点 六、哈夫曼树1、思想 设有实数集$$W = {w_0,w_1,w_2,\\cdots,w_{m-1}}$$T是一颗扩充二叉树，其 m 个外部节点分别为以 w ~i~ 为权，而且T的带权外部路径长度 WPL在所有这样的扩充二叉树中达到最小，则称 T 为数据集 W 的 最优二叉树或者是哈夫曼树 Click Here and Learn More 2、实现12345678910111213141516171819202122232425class BinTNode(): def __init__(self,item,leftchild=None, rightchild=None): self.elem = item self.leftchild = leftchild self.rightchild = rightchildclass HTNode(BinTNode): # 这里继承了BinTNode类，定义了一个专门为构建哈夫曼树的节点类，特点就是增加了一个小于的比较操作 def __lt__(self,othernodes): return self.elem &lt; othernode.elem # 这里定义了一个专门为哈夫曼算法服务的优先队列类，其中增加了一个检查队列中元素个数的操作class HuffmanPrioQ(PrioQueue): def number(self): return len(self._elems) def HuffmanTree(weights): tree = HuffmanPrioQ() for w in weights: tree.enqueue(HTNode(w)) while tree.number() &gt; 1: t1 = tree.dequeue() t2 = tree.dequeue() x = t1.elem + t2.elem tree.enqueue(HTNode(x,t1,t2)) return tree.dequeue 算法复杂度： 第一个循环构造了m颗二叉树，并把他们加入大序列中，按照上面的写法则时间复杂度为O(m log m)，因为加入一个元素需要O(log m)次筛选 第二个循环需要m-1次，每次减少一颗树。其中构造一颗新树的时间与m是无关的，是O(1)复杂度的操作。每次迭代需要把一颗新的树加入到优先队列，需要O(log m)复杂度的时间，整个循环就是O(m log m)时间； 3、树、森林、二叉树的关系实际上是一种一一对应的关系，可以把任何一个（有序）树林映射到一颗二叉树上，而其逆映射把这颗二叉树映射回原来的树林，映射关系如下： 顺序连接同一节点的各个子节点（它们原来在原树林里的兄弟节点），作为这些节点的右分支的边（也就是说，将树/森林中下一兄弟最为二叉树的右分支） 保留每个节点到其第一个子节点的连接作为该节点的左分支，并删去这个节点到它节点的其他子节点的连接（即是说原森林里第一个子节点作为二叉树里的左分支） [^脚注1]: 先序遍历方式：根 —&gt;左—&gt;右[^脚注2]: 中序遍历方式：左 —&gt;根—&gt;右 [^脚注3]: 后序遍历方式：左 —&gt;右—&gt;根","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"},{"name":"python","slug":"算法/python","permalink":"https://albert-5.cn/categories/算法/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"},{"name":"查找算法","slug":"查找算法","permalink":"https://albert-5.cn/tags/查找算法/"},{"name":"数和森林","slug":"数和森林","permalink":"https://albert-5.cn/tags/数和森林/"}]},{"title":"英语学习","slug":"英语学习","date":"2019-03-01T16:20:48.000Z","updated":"2019-05-24T16:22:15.896Z","comments":true,"path":"2019/03/02/英语学习/","link":"","permalink":"https://albert-5.cn/2019/03/02/英语学习/","excerpt":"","text":"话题1 Directions: Suppose you are asked to give advice on whether to attend college at home or abroad, write an essay to state your opinion. You are required to write at least 150 words but no more than 200 words. 参考范文： Nowadays, there has been a heated discussion as to a better choice between attending college at home and abroad. Views on the topic vary greatly among people from different walks of life. Some believe that it is a better choice to study in domestic colleges, but others consider it better to study abroad. I totally agree with the latter idea for the reasons presented below. To begin with, it harms the society in that the greater the competition is, the higher the recruitment requirements willbecome. Therefore, with experiences of studying abroad, graduates will become more competitive in job hunting. Furthermore, it is beneficial to the students themselves to study abroad. Without the choice to pursue overseas study, many great scholars today would never have achieved such great success. From my perspective, it is crucial that the government should encourage people to pursue overseas study. Also it is crucial that people should understand the meaning and value of attending college abroad. Only in this way can we achieve greater success. 词汇学习： discussion[dɪˈskʌʃən]讨论，谈论 college[‘kɔlidʒ]大学;学院;学院的全体师生;社团 at home 在家;在国内 domestic[dəˈmɛstɪk]家庭的;热心家务的， 仆人，佣人 consider[kənˈsɪdə]考虑;考虑到;认为 话题2 英语六级作文话题：手机直播 Directions: For this part, you are allowed 30 minutes to write a short essay on mobile live video broadcasting. You are required to write at least 150 words but no more than 200 words. 参考范文： In recent years, mobile live video broadcasting has been very popular among young people. People can broadcast their daily life anytime at any place as they like as long as they have a smartphone. In my opinion, there are disadvantages as well as advantages of mobile live video broadcasting. On the one hand, mobile live video broadcasting enables people to show their talent online, which gives them a chance to earn money online. And it is also a good way to share their life experience with their friends and family. On the other hand, if people don’t use their time properly, they may become addicted to it. Particularly, if students spend too much time playing it, they may neglect their studies, which is not good for them. In conclusion, mobile live video broadcasting is a fashionable way to enrich people’s life. However, we should make best use of our time and keep ourselves from being addicted to it. 话题3英语六级作文话题：买房的重要性 参考范文： Importance of Buying a House There is a heated debate on the importance ofbuying a house with the soaring house prices. Those emphasizing the in^ortance of buyiog ahouse maintain that living in your bwn house makes you feel better and more comfortablecompared to that in a rented one. Besides, no investment is more rewarding than buying ahouse nowadays. Statistics from both home and abroad shows that owning a houseguarantees an increase in assets. Quite the contrary, many people say, buying a house is not that important. On one hand,a rented apartment can provide the same comfortable or even better life for people. This isespecially true when many people have no money to decorate their houses after the bigpurchase. On the other hand, peopk can spend more money on other more protitableinvestment than involving in real estate, such as buying stocks or other art poliections. Personally, I think possessing a house is extremely important. At its core, a house is ashelter After buying a house, people will becomc stable. What’s more important is that thctrchildren will also settle and can concentrate on study _ children could get affected as theyadapt themselves with the new places, teachers and creating new friends making them Lagbehind academically. 词汇学习： importance [ɪmˈpɔːtəns]重要;重要性;傲慢 comfortable[ˈkʌmftəbəl]舒适的，舒服的;自在的;安逸的;宽裕的 extremely[ɪkˈstriːmlɪ] 极端地，非常地，很 话题4英语六级作文话题：国学 参考范文： In recent years, Sinology, the study of Chinese traditional culture, literature, history, society etc, has become increasingly popular For instance, it is reported that many primary and secondary schools have set up courses of sinology, in which students are taught classical works by Chinese ancient educators and philosophers, like Confucius- Another good illustration is in the program CCTV Lecture Room famous scholars, e.g, Yu Dan, give lectures on Chinese ancient philosophies and literatures. Sinology becomes prevalent due to the fact that it is of vital significance for both the individuals and the society. For one thing, Sinology is the essence of Chinese civilization with more than 5,000 years. Thus, for individuals, they can enlarge their scope of knowledge, enrich their experience and adapt themselves to the complicated society. For another, it is acknowledged that the rehabilitation of Sinology can contribute to the establishment of a harmonious society. In my opinion, all Chinese people should inherit the merits of Sinology. To do so, we can read books by ourselves or to attend lectures on this issue. Besides, we have the gation to popularize introducing it to the world By doing so, we can not only inherit it but also make it glorious and prosperous. 词汇学习： For instance例如，比如; 拿 … 来说 it is reported据悉 真题 真题 1【题目】 Directions: Directions: For this part, you are allowed 30 minutes to write an essay commenting on the saying “Seek to understand others, and you will be understood.”You can cite examples to illustrate your views.You should write at least 150 words but no more than 200 words. 【参考范文】 There is a proverb going like this, “Seek to understand others, and you will be understood.” Simple as the saying is, its implication deserves exploring. From my perspective, the real sense of the proverb lies in mutual understanding. One of the reasons that mutual understanding is so vital is that it forms the basis of all friendships and relationships. Mutual understanding allows existing differences between two or more partied to be acknowledged, accepted and respected, so that common ground and a collective vision can be found. This is true regardless of whether the relationship is between individuals, businesses or even countries. For example, the US and British governments may not see eye to eye on every issue, but they have been able to put aside their differences and forge a friendship and alliance supported by their shared values. We may not fully agree with other people’s opinions or beliefs. However, by understanding the reasons behind their words and actions, we can learn to “disagree without being disagreeable”so that quarrels are averted. Therefore, for those who wish to build lasting relationships, prevent conflict with others, seeking and achieving mutual understanding with others is not only important, but essential. 真题2 2016年6月 【审题提纲】 这是一篇典型的议论文，主题是探讨虚拟世界与现实生活的关系。题目想告诉我们网络的虚拟人生无法取代真实的人生，甚至可能危害真实的人生。考生在行文时，可一方面强调网络所创造的虚拟世界所带来的好处，另一方面也可指出以网络为媒介的虚拟世界对真实人生的危害。 第一段：指出虚拟世界的现状，论述过程中可引用数据。 第二段：分析利弊，直陈得失，议论时可适当举例。 第三段：提出建议或措施。比如从年轻人自身或结合社会来给出建议。 【参考范文】 The Internet, as a platform of the virtual world, has aroused public attention these years. However, in a new Gallup poll, about 100 million Chinese cyber citizens are willing to chat with the other side of the net for several hours, but refuse to talk with their neighbors even for a moment. This deserves our consideration. Actually, this phenomenon is prevalent nowadays. There’s no denying that the Internet creates a cyberspace for people to evade the burden of the real world and find temporary relaxation. People can experience their own dream and enjoy heartily in the virtual world. For example, an increasing young adults could feel extremely proud of their upper ranks in online games. Nevertheless, it is clear that the more time one spends on surfing, the less time one does with his or her family and friends. If the situation continues, it will weaken one’s bonds with the real life. For instance, it would become difficult for them to fulfill necessary tasks and, more seriously, their individual development would be consequently hampered. As a result, addiction to the virtual world will render a person nothing in the real world. Obviously, appropriate measures need to be taken. For one thing, the youth should be educated to realize the importance of the real life. For another, their time on online and activities in real life should be balanced. 【写作模板】 (中心词), as（补充说明中心词）, has aroused public attention these years. However, in a new Gallup poll, a(数据说明). This deserves our consideration. Actually, this phenomenon is prevalent nowadays. There’s no denying that(毫无疑问的好处). People can (细节支持) in the virtual world. For example,(举例). Nevertheless, it is clear that(显而易见的弊端或危害). If the situation continues, it will weaken(细节支持). For instance,(举例一) and, more seriously, (举例二) .As a result, addiction to the virtual world will render(总结危害). Obviously, appropriate measures need to be taken. For one thing,(角度一). For another,(角度二). 真题3 2016年6月 【审题提纲】 这是一篇典型的议论文，主题是探讨在线学习与学校学习的关系。题目想告诉我们在线学习是无法取代学校学习的。考生行文时，一方面可强调在线学习所带来的好处，另一方面也需指出在线学习存在的弊端，同时论证学校学习是能改善这些弊端的最佳途径。 第一段：描述现状，说明自己的观点。 第二段：分析在线学习的利弊，同时指出学校学习可以弥补在线学习的不足。 第三段：指出自己的应对之策并结合学生身份，说明采取哪种学习方式不重要，最重要的是要更加有效地学习。 【参考范文】 With the growing of the world wide web, those luckily enough to learn by the net face the decision of e-learning and attending school. The choice is a difficult one as both ways of learning have advantage. Personally, I believe, although e-learning is obviously convenient, the benefits are often not significant and in many ways learning in this kind of way can limit one’s experience. Undoubtedly, the conveniences of e-learning include the fact that it easily breaks through the limitations of time and space and offers the update knowledge and lower learning cost. Additionally, it is a more advanced approach to access to essential and useful information. However, the disadvantage of e-learning is clear as well. It cannot allow the students to socialize; namely, it cannot help develop the necessary social skills needed to survive in today’s fast-pace world. Fortunately, this can be fulfilled by attending school. For example, many people meet their best friends while attending school. These friendships are deepened over spending hours and hours in the same classrooms together. Consequently, the bonds that are formed in classroom cannot be replaced by e-learning. In a word, when combined with other learning methods, such as face-to-face sessions, e-learning is most effective. That is to say, it is a good idea that we combine e-learning and attending school together. No matter what we choose, as college students, we should study more effectively. 【写作模板】 With the growing of the world wide web, those(某类和主题相关的人群) face the decision of (关键词1+关键词2). The choice is a difficult one as both ways of(关键词的类别) have advantage. Personally, I believe, although(关键词1) is obviously convenient, the benefits are often not significant and in many ways (局限性). Undoubtedly, the conveniences of(关键词1)include the fact that it(细节支持). Additionally, (细节支持). However, the disadvantage of (关键词1) is clear as well. It cannot(弊端); namely, it cannot(进一步解释弊端). Fortunately, this can be fulfilled by(关键词2). For example, (举例). Consequently, (小结). In a word, when(假设某种条件), such as(举例),(关键词1) is most effective. That is to say, it is a good idea that(进一步阐述我的观点). No matter what we choose, as college students, we should (结合自身举例，使文章立意升华). 真题4 2016年6月 【审题提纲】 本文是一篇非常典型的科技类话题作文。题目要求从机器人的使用出发，设想机器人的未来前景。考生可结合自身对机器人的认识，论述自己的观点。纵观六级考试这三套题目，考查的均是与科技相关的话题，这就说明与科技相关的话题始终是六级作文考查的重点。 第一段：引出文章话题，假设机器人对人类生活所做出的改变。 第二段：针对此现象阐述观点。 第三段：自己的看法。 【参考范文】 At the mention of the robots, many fiction films are rising before my eyes, such as AI(Artificial Intelligence). I would like to imagine what will happen when an increasing number of robots take the place of human beings in our life. How interesting the scene is—there’s a robot ready to help you, whether it is helping your mother with household chores or helping you copy the text. Clearly, the robots contribute to the progression of human beings’ society. For one thing, they liberate the labor force and promote the industrial efficiency. For another, they are engaged in some dangerous work, protecting mankind from the risks. However, sometimes the robots cause troubles. On the one hand, it will impair man’s innovation ability, if humanity completely depends on the robots for a long time. On the other hand, a single robot can wreck a lot, if robots are given awareness. Hence, if robots are to reach further, there are still much real challenge. As for me, robots will not take the place of human beings totally, although they would exceed the man in many aspects, such as power of work, operating rate and memory function. Nevertheless, because robots lack the capability of logical thinking and reasoning, it dooms that they can not solve the complicated problems as humans do. Therefore, robots cannot do better than human in many fields, let alone substituting humans. 【写作模板】 At the mention of the (关键词), (具体情况), such as(举例). I would like to imagine(题目主旨). How (与主题相关的形容词)the scene is— (细节支持). Clearly, the(关键词)contribute to the progression of human beings’ society. For one thing,(细节支持). For another,(细节支持). However, sometimes the(关键词) cause troubles. On the one hand,(细节支持). Hence, if (关键词) are to reach further, there are still much real challenge. As for me,(自己的看法), although they would(让步假设), such as(举例). Nevertheless, because(某种原因), it dooms that they can not (存在弊端). Therefore,(进一步总结). 真题5Equality of Education Opportunity 近年来出现一些教育不公平的现象 出现这些现象的原因和后果 为了改变这种状况，我认为…… 【范文】 Equality of Education Opportunity In recent years the problems which are causedby the inequality of education opportunity haveattracted the public’s attention. For instance, thebackward teaching facilities anddilapidated schoolbuildings in rural areas are in sharp contrast tothose advanced facilities and well-equippedclassrooms in urban areas, students from poor families cannot go to universities because ofthe high tuition. There are several factors which contribute to these problems. First, the distribution ofresources is unbalanced between rural and urban schools. Second, educational loans for poorstudents are far from enough. Third, the inequality in some schools’ admission policies alsoturns many students away. The education inequality can result in many bad impacts. On onehand, it can affect people’s future employment. On the other hand，it is the root of manysocial problems. To change this situation, I think, we should take the following measures. Firstly, thegovernment’s spending on education should be increased and the allocation of public resourcesgives priority to rural and weak urban schools. Secondly, the implementation of thegovernment financial aid system for students should be accelerated. Thirdly, the governmentshould speed up education reforms to ensure everyone has equal access to schools. 高分替换词32个高分替换词 1) 大多数人 most people→ the majority of the population 2) 经常 often→frequently 3) 我相信 I believe→ from my standpoint, from my perspective 4) 必须 must→ it is a must for us to… 5) 知道 know→ be aware of 6) 因为 because→in that 7) 最后 at last→eventually 8) 然而 but→however 9) 如果 if→provided that 10) 各行各业的人 all kinds of people→people from all walks of life 11) 引起，导致 lead to→contribute to 12) 人 people→individuals 13) 好的 good→desirable, beneficial 14) 坏的 bad→undesirable 15) 很多many→ numerous 16) 越来越 more and more→ a(n) increasing/mounting number of 17) 很 very→extremely 18) 方面 side→aspects 19) 表明 show→demonstrate, indicate 20) 利用 use→utilize 21) 因此/结果 so→therefore 22) 部分 part→proportion 23) 提高 improve→enhance 24) 改变 change→transform 25) 强调/重视 emphasize→ attach great importance to 26) 培养 develop→cultivate 27) 破坏 destroy→undermine 28) 解决 deal with →tackle /figure out 29) 普遍的 everywhere→universal 30) 明显的 obvious→apparent 31) 在当今社会 in the modern society→in the current society 32) 使 make→enable 词组 at the thought of 一想到… as a whole 就整体而论 （in general 就整体而论） at will 随心所欲 be abundant in 富于，富有 （be rich in 富于，富有） access to 能接近，进入，了解 without accident 安全地 of one’s own accord 自愿地 ,主动地 （ without being asked 自愿地 ,主动地） in accord with 与…一致 （ out of one’s accord with 同…不一致） with one accord 一致地 (with everybody agreeing 一致地） in accordance with 依照，根据 (in agreement with 依照，根据） on one’s own account 1) 为了某人的缘故， 为了某人自己的利益 2) (=at one’s own risk) 自行负责 3) (=by oneself)依靠自己 take…into account 把…..考虑进去 give sb. an account of 说明， 解释 (理由) account for 解释， 说明 ​ (give an explanation or reason for 解释） on account of 由于，因为 ​ (because of 由于，因为） on no account 决不 ​ (in no case, for no reason 决不） accuse…of…指控，控告 (charge…with; blame sb. for sth. ; blame sth. on sb. ; complain about 指控，控告） be accustomed to 习惯于 ​ (be used to)习惯于 be acquainted with 了解 act on 奉行，按照…行动; ​ act as 扮演 ​ act for 代理 adapt oneself to 使自己适应于 ​ (adjust oneself to 使自己适应于） adapt…for 改写以适应（新的需要） in addition 此外， 又， 加之 in addition to 除…外 ​ （as well as 除…外） adhere to 粘附; 坚持， 遵循 adjacent(=next to) 毗邻的， 临近的 adjust to (=change slightly)调节; 适应 admit of (=be capable of) …的可能，留有…的余地 in advance (before in time) 预告， 事先 to advantage 有利的，使优点更加突出地 have an advantage over 胜过 have the advantage of 由于…处于有利条件 have the advantage of sb. 知道某人所不知道的事 take advantage of 利用 agree with 赞同(某人意见) ​ agree to 同意 in agreement (with) 同意， 一致 ahead of 在…之前， 超过… ​ ahead of time 提前 in the air 1)悬而未决. 2)在谣传中 above all 尤其是， 最重要的 in all 总共， 总计 after all 毕竟，到底; 1) (not) at all 一点也不; 2) all at once(=suddenly)突然; 3) once and for all 只此一次; 4) above all 最重要的; 5) first of all 首先; 6) all in all 大体上说; 7) be all in 累极了; 8) all but 几乎 allow for (take into consideration) 考虑到， 估计到 amount to总计， 等于。 answer for 对…负责。 conform to 适合，符合。 be anxious about 为…焦急不安; ​ （anxious for） apologize to sb. for sth. 为…向…道歉 appeal to sb. for sth. 为某事向某人呼吁. ​ appeal to sb. 对某人有吸引力 apply for 申请 apply to 与…有关;适用 approve of 赞成 arise from(=be caused by) 由…引起 arrange for sb. to do sth. 安排…做… arrive on 到达; ​ arrive at 到达某地(小地方);获得; ​ arrive in 到达某地(大地方); be ashamed of 以…为羞耻 assure sb. of sth. 向…保证， 使…确信 attach to缚， 系 ,结 make an attempt at doing sth. 试图做… attend to 注意，照顾 ​ attend on 侍候，照料 attitude to/ toward …对…的态度 attribute…to… 把…归因于…，认为…是…的结果 on the average 平均 (be) aware of 意识到，知道 at the back of 在…后面 in the back of 在…后部(里面); ​ on the back of 在…后部(外面) at one’s back 支持，维护; turn one’s back on sb. 不理睬(某人),背弃，抛弃 behind one’s back 背着某人(说坏话) be based on / upon 基于 on the basis of 根据…, 在…基础上 beat…at 在…运动项目上打赢 begin with 以…开始 on behalf of 以…名义 believe in 相信，依赖，信仰。 benefit (from) 受益，得到好处。 for the benefit of 为了…的利益(好处) for the better 好转 get the better of 打败， 胜过。 by birth 在出生上，论出身，按血统 ​ at birth 在出生时 blame sb. for sth. 因…责备某人 ​ blame sth. on sb. 把…推在某人身上 in blossom开花(指树木) on board 到船上，在船上，上火车或飞机 boast of 吹嘘 out of breath 喘不过气来 in brief 简言之 in bulk 成批地，不散装的 take the floor 起立发言 on business 出差办事 be busy with sth.于某事 ​ be busy doing sth. 忙于做某事 last but one 倒数第二 but for 要不是（表示假设） buy sth. for…money 用多少钱买 be capable of 能够， 有能力 be capable of being+过去分词 是能够被…的 in any case 无论如何 in case 万一 in case of 如果发生…万一 in the case of 至于…, 就…而言 in no case 在任何情况下都不 be cautious of 谨防 center one’s attention on 把某人的注意力集中在…上 be certain of (be sure of) 有把握， 一定 for certain of (for sure )肯定地，有把握地 by chance(by accident)偶然","categories":[{"name":"English","slug":"English","permalink":"https://albert-5.cn/categories/English/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://albert-5.cn/tags/英语/"},{"name":"六级","slug":"六级","permalink":"https://albert-5.cn/tags/六级/"},{"name":"作文","slug":"作文","permalink":"https://albert-5.cn/tags/作文/"}]},{"title":"AnyConnect","slug":"AnyConnect","date":"2019-02-28T09:43:44.000Z","updated":"2019-06-14T15:37:32.959Z","comments":true,"path":"2019/02/28/AnyConnect/","link":"","permalink":"https://albert-5.cn/2019/02/28/AnyConnect/","excerpt":"","text":"最近发现使用Cisco AnyConnect在Win8.1上系统上连接VPN时，会出现anyconnect was not able to establish a connection to the specified secure gateway问题导致无法成功连接VPN，错误提示如下所示 problem: AnyConnect was not able to establish a connection to the specified secure gateway. Please try connecting again. 其实解决方法也是很简单的，只需要： 此电脑鼠标右击 -&gt;管理 -&gt;服务于应用程序 -&gt; 服务 -&gt; 禁用 Internet Connection Sharing即可","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://albert-5.cn/categories/疑难杂症/"}],"tags":[{"name":"Windows 10","slug":"Windows-10","permalink":"https://albert-5.cn/tags/Windows-10/"},{"name":"VPN","slug":"VPN","permalink":"https://albert-5.cn/tags/VPN/"},{"name":"anyconnect","slug":"anyconnect","permalink":"https://albert-5.cn/tags/anyconnect/"}]},{"title":"CSS","slug":"CSS","date":"2019-01-14T09:34:51.000Z","updated":"2019-06-14T15:37:08.889Z","comments":true,"path":"2019/01/14/CSS/","link":"","permalink":"https://albert-5.cn/2019/01/14/CSS/","excerpt":"","text":"一、CSS概述内容的样式 英文全称: Cascating Style Sheets^注释1 二、CSS语法基本语法格式 p{font-size:#;——&gt;字体大小color:blue; ——–&gt;字体颜色 font-weight:bold;——&gt;加粗} 注意： 1、最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。 2、为了使用样式更加容易阅读，可以将每条代码写在一个新行里。 1、css添加方法a： 行内添加 &lt;!DOCTYPE HTML&gt; 学习笔记CSS篇 &lt;/!doctype&gt; b: 内嵌样式 &lt;!DOCTYPE HTML&gt; p{ color:black;/设置字体颜色/ } 学习笔记CSS篇,内嵌样式的添加 &lt;/!doctype&gt; p{ 1color:#; } c: 单独文件外部样式表文件 style.css p{color：#;} 网页文件 12.html 使用 href 链接到 css文件 单独样式的优点 页面结构HTML代码与样式CSS代码的完全分离，便于维护 如果需要改变网站的风格，只需要修改公共CSS文件即可 可以在同一个HTML文件中引用多个外部样式表 2、 添加方式的优先级_ 多重样式可以层叠，可以覆盖 _ 样式的优先级按照“就近原则” _ 行内样式 &gt; 内嵌样式 &gt; 链接样式 &gt; 浏览器默认样式 三、CSS选择器1、标签选择器采用内嵌式时，以body、h1、p等直接作为标签名 body{background-color:##; text-align:#; font-size:#;} h1{ font:\"黑体\"；font-size:#; } p{ color:#; font-size:\"#\"; } hr{width:220px;} 标题正文的段落版权所有L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"position\":\"left\",\"width\":150,\"height\":300,\"jsonPath\":\"/live2dw/assets/assets/shizuku.model.json\"},\"mobile\":{\"show\":false}}); 2、类别选择器 printf() 1234567891011121314&gt; &lt;style type=&quot;text/css&quot;&gt;&gt; p&#123; font-size:12px;&#125;&gt; .one&#123; font-size:13px;&#125;&gt; .two&#123; font-size:14px;&#125;&gt; &lt;/style&gt;&gt; &lt;body&gt;&gt; &lt;p class=&quot;one&quot;&gt;类型1&lt;/p&gt;&gt; &lt;p class=&quot;two&quot;&gt;类型2&lt;/p&gt;&gt; &lt;p class=&quot;three&quot;&gt;类型3&lt;/p&gt;&gt; &lt;p class=&quot;four&quot;&gt;类型4&lt;/p&gt;&gt; &lt;p class=&quot;five&quot;&gt;类型5&lt;/p&gt;&gt; &lt;p&gt;普通的段落文字&lt;/p&gt;&gt; &lt;/body&gt;&gt; 3、ID选择器printf() 12345678&lt;style type=\"text/css\"&gt; #one&#123;font-size:12px;&#125; #two&#123;font-size:24px;&#125; &lt;/style&gt;&lt;body&gt; &lt;p id=\"one\"&gt;文字1&lt;/p&gt; &lt;p id=\"two\"&gt;文字2&lt;/p&gt;&lt;/body&gt; 4、嵌套声明printf() 12345678&lt;style&gt; p span&#123; color:#; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;&lt;span&gt;学习&lt;/span&gt;&lt;/p&gt;&lt;/body&gt; 5、文本样式格式 属性 描 述 取值 color 文本颜色 red #f00 letter-spacing 字符间距 2px、3px line-height 行高 14px 1.5em 120% text-align 对齐 center left right justify text-decoration 装饰线 none overline underline line-though text-indent 首行缩进 2em 6、背景设置1、背景属性空元素需要先定义元素的高度和宽度 background-color background-image–背景图片 url(“logo.jpg”) background-repecat–背景图片的填充方式 repeat repeat-x(横向填充) repeat-y(纵向填充) no-repeat(填充一次) bacground 2、CSS超链接超链接的四种状态 a:link 普通的、未被访问的链接 a:visited 用户已经访问的链接 a:hover 鼠标指针位于链接的上方悬停 a:active 链接被点击的时刻 :伪类选择器 顺序 a:hover 必须位于a:link 和a:visited之后 a:active 必须位于a:hover之后 3、列表样式 life-style 所有用于列表的属性设置于一个声明之中 list-style-image 为列表项标志设置图像 list-style-position 标志的位置 list-style-type 标志的类型 无序列表ul和有序列表ol 4、表格的样式表格大小 属性 width(宽),height(高) printf() table{ 123width:500px;height:200px; } 表格边框属性boder 123table,td,th&#123; boder:1px solidn#eee&#125; td标签—单元格的样式 th标签—表头的样式 另一个属性 boder-collapse —内外边框重叠问题 123table&#123; boder-collapse:collapse;&#125; 5、CSS表格–奇偶选择器 :nth-child(odd|even)12tr:nth-child(odd)background-color:#EAF2D3; 四、CSS布局和定位问题1、盒子模型概念 页面上的区域、图片、导航、列表、段落都可以是盒子 除了content之外其他的都是属性的名字 1234567891011121314151617181920&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;style type=\"text/css\"&gt;&gt; #box&#123;&gt; width:100px;&gt; height:100px;&gt; border:1px solid;&gt; padding:20px;&gt; margin:10px;&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;div id=\"box\"&gt;&gt; 你猜啊&gt; &lt;/div&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; 2、盒子属性 border-width: px thin medium thick border-style:dashaed^注释2 dotted^注释3 solid^注释4 double^注释5 border-color: 颜色 border:width style color 五、CSS定位机制概述：就是盒子的位置 三种定位机制 1、文档流 flow定位：默认的方式 2、浮动 float定位：设置float属性 3、层定位 layer：设置position属性 1、文档流定位1、元素分类 block类型：每个此类型的元素都要独占一行 常见的block元素有： ··· inline类型 : 每个元素不单独占一行，且width height不可设置 常见的inline元素有： –显示为inline元素 display:inline– inline-block类型 : 不单独占据一行，但是可以改变设置 常见的inline-block 元素有： 2、元素转换类型display类型 2、浮动定位float属性 width:200px;height:200px;boder:1px solid red;float:left; 3、层定位概述 像图象软件中的图层一样可以对每个layer进行能够精准定位操作 position 属性：（相对于谁定位） fixed 固定定位 ：相对于浏览器窗口进行定位 relative 相对定位 ：相对于直接父元素进行定位 absotive 绝对定位 ：相对于static定位意外的第一个父元素 六、CSS3续篇1、圆角边框和阴影2、文字与文本 text-shadow属性 ：文本阴影 –水平偏移 垂直偏移 阴影大小 颜色– text-wrap属性 ：允许单词、url强制进行换行 –normal 属性– –break-word 属性– @font-face属性","categories":[{"name":"前端","slug":"前端","permalink":"https://albert-5.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://albert-5.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://albert-5.cn/tags/前端/"}]}]}