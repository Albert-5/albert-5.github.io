{"meta":{"title":"Albert","subtitle":null,"description":"欢迎光顾本站~","author":"albert","url":"https://albert-5.cn","root":"/"},"pages":[{"title":"Music","date":"2019-04-27T03:22:49.000Z","updated":"2019-05-03T03:39:08.313Z","comments":true,"path":"Music/index.html","permalink":"https://albert-5.cn/Music/index.html","excerpt":"","text":"2019-04-27 2019-05-03"},{"title":"Books","date":"2019-04-29T07:21:56.000Z","updated":"2019-04-29T07:25:03.379Z","comments":true,"path":"books/index.html","permalink":"https://albert-5.cn/books/index.html","excerpt":"","text":""},{"title":"Desktop","date":"2019-04-27T04:47:05.000Z","updated":"2019-06-09T15:00:08.596Z","comments":true,"path":"desktop/index.html","permalink":"https://albert-5.cn/desktop/index.html","excerpt":"","text":"VIDEOS(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"indigo\",\"loop\":true,\"screenshot\":\"yes\",\"video\":{\"url\":\"http://pss3kkkhb.bkt.clouddn.com/albert.mp4\"},\"danmaku\":{\"id\":\"9E2E3368B5SDFDF387GF\",\"api\":\"https://api.prprpr.me/dplayer/\",\"addition\":[\"https://api.prprpr.me/dplayer/bilibili?aid=8520345\"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() LEARN@card{ 编程语言 Python c语言 待入门 Java } SOURCES@card{ #FADFA3 待添加 } ENTERTAIN@column-3{ @card{ 游戏1 红色警戒 } @card{ 游戏2 和平精英（菜鸡） } @card{ 游戏3 刺客信条 } }"},{"title":"Categories","date":"2019-04-28T09:19:42.000Z","updated":"2019-04-28T09:53:07.675Z","comments":false,"path":"categories/index.html","permalink":"https://albert-5.cn/categories/index.html","excerpt":"","text":""},{"title":"Games","date":"2019-04-29T07:22:22.000Z","updated":"2019-04-29T07:25:17.477Z","comments":true,"path":"games/index.html","permalink":"https://albert-5.cn/games/index.html","excerpt":"","text":""},{"title":"Picture","date":"2019-04-27T04:47:25.000Z","updated":"2019-05-02T08:15:50.843Z","comments":true,"path":"picture/index.html","permalink":"https://albert-5.cn/picture/index.html","excerpt":"","text":"记录生活 分享感动 🎞️ Images@blockquote{ @card{"},{"title":"Movies","date":"2019-04-29T07:22:07.000Z","updated":"2019-04-29T07:25:29.190Z","comments":true,"path":"movies/index.html","permalink":"https://albert-5.cn/movies/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-04-28T09:19:21.000Z","updated":"2019-04-28T09:48:42.643Z","comments":false,"path":"tags/index.html","permalink":"https://albert-5.cn/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-04-27T04:47:43.000Z","updated":"2019-06-07T14:43:24.603Z","comments":true,"path":"about/index.html","permalink":"https://albert-5.cn/about/index.html","excerpt":"","text":"@blockquote{ @card{ 🏛️关于小站🧐hi~，大家好，我是albert，欢迎你来到我的小站！准确的说，这是我的第一站，记录、分享是我建站的目的；关于小站Logo，那是一位科学家，有着卓越的能力，代表着前沿科学技术，同时呢，也代表着大国工匠精神，也是个人的一种理想吧！！ } } @blockquote{ @card{ ♓关于我 albert，英文名取自于Iron Man中的主人公 Robert Downey Jr.,同时也是聪明、勇敢的象征； 目前本科在读，乐意结交有灵魂者； 爱好：摄影、科幻、运动、旅游 世界这么大，想出国✈️转转… } @blockquote{ @card{ 🌐交流 音乐 📻 网易云音乐 🎵 QQ音乐 🎶 邮箱 📭 QQ邮箱 📮 Gmail 📧 赞赏 💰 支付宝 💵 微信 💶 待添加··· 我的相册 📷 相册 🎞️ 其他 ℹ️ 豆瓣小家 📇 } } @blockquote{ @card{ 📝更新日志@timeline{ 2019@item{ 4月22日弃用jekyll，改用hexo+githubpages搭建博客 } @item{ 4月23日完成博客基础配置，邮箱、微博、github··· } @item{ 4月24日增加支付打赏功能，目前仅支持支付宝、微信 } @item{ 4月25日添加鼠标点击特效 } @item{ 4月26日增加music、film、book、camera页面 } @item{ 4月27日在music页面下借助aplayer创建音乐歌单 } @item{ 4月28日seo优化，收录于Google } @item{ 4月29日增加文章置顶功能 } @item{ 5月1日新增图床，减少加载时间 } @item{ 5月2日利用HTML5 UP模板建立相册并分类化处理 } @item{ 5月17日在阿里云网站上购买域名albert-5.cn } @item{ 5月20日.cn 域名实名认证成功并顺利使用 } @item{ 5月21日为网站添加绿锁头，还是绿的好看;点击预览 } @item{ 6月2日增加网站管家&lt;小老婆&gt; } } } }"}],"posts":[{"title":"Waring","slug":"Waring","date":"2019-06-14T12:38:56.000Z","updated":"2019-06-14T13:18:12.186Z","comments":true,"path":"2019/06/14/Waring/","link":"","permalink":"https://albert-5.cn/2019/06/14/Waring/","excerpt":"","text":"拒绝伸手党！什么是伸手党伸手党其实指的是一类人，这一类人有的是出于不懂事而产生的伸手现象的未成年人，有的是依赖性极强的成年人，伸手党大致有以下特征： 任何资源（图片、音乐、链接等）都只想通过他人直接获得 虚拟社区（线上游戏、讨论区）中的讨要点卡、高级账号者 理直气壮的向别人索要他人成果 他人发布的消息以及通知等不认真阅读，反复询问者【自己定义】 ​ ———————-来源于百度百科 为什么会有伸手党我感觉伸手党的存在一定程度上反映了个人的一些所谓懒的行为，自己不想去寻找或者付出努力，一味的寻求他人，希望别人直接把资源或者自己想要的东西发给你，他们都要类似的表现，例如什么问题直接来问而不是先去搜索一下如何进行解决。连说明书都懒得去看，也不想着如何去做，失去了学习的能力，也不会想着提升自己。而且能「Google」的就别「百度」，原因你懂的，这时估计会有人说了，你能上谷歌？怎么弄的的 。。。。。。。【WTF 我竟无言以对】 原罪 但是话说过来，又有谁没有做过伸手党呢？你敢说小时候没有抄过作业？【哈，作业写完了吗？借鉴一下呗】，哎呀，真香！但是这只是曾经，那是小时候，玩是天性，不想现在自己要去忙活学习之外的事情，经历、成长、适应社会，再做伸手党恐怕有点过分哦~ 自己定义的伸手党为什么会把这个列为伸手党，我感觉此等行为和伸手党行为莫名的一致。 虽说不是音乐、视频等资源，但是作为一种信息的阅览，其中包含的也是一种资源。 【辅导员】【班长】【各大社团】等一系列的通知，公告等漫天飞舞，还有无尽的【@全体成员】铺天盖地，大多数还都是认真阅读后提出自己的疑问，但总有一些特例不去仔细阅读通知内容，一股劲的@管理询问 这个活动时什么时候开始啊，地点在哪啊 活动的具体形式是什么呀 将个人照片交到某某楼某某教室某某老师，则会有人问了 纸质的还是电子照片啊，老师什么时候在啊 $\\cdots\\cdots$ 拒绝伸手党我们大多时候都会遇到这种情况，很简单，不理会就是了。一些明显的能一个「谷歌」解决的问题，有什么必要去回复呢？到最后只能回复一句 请仔细阅读公告内容！ 或者直接无奈的给你这个： So what? 啊哈 如何避免成为伸手党 善于利用工具：遇到问题先经过自己的思考，实在没有主意就去Google 或者Baidu寻找提示或者思路，人人都能及格甚至优秀，奈何你连翻书都不会 承认自己的渺小和无知：一个人说出【我不知道】【我不了解】可能会很难，但是正因为你不知道，所以你才要去不断的学习，只有这样或许才能不断的进步，如果连这种勇气都没有，成功？恐怕只是一个梦 信息要读Carefully：接到通知或者公告，要自己阅读，不能看到活动通知就说什么时候开始，什么形式，举办方花费精力做的文案可不是白纸，还有黑字呢 学好英语：学好英语更好的利用谷歌工具，更好的看懂论文文献，更好的交流和学习，这里检讨一下自己，曾经英语不努力，现在交流mmp。 做好自己的人生规划吧！ 本内容不针对任何人，只是提醒自己不要做伸手党","categories":[{"name":"Waring","slug":"Waring","permalink":"https://albert-5.cn/categories/Waring/"}],"tags":[{"name":"伸手er","slug":"伸手er","permalink":"https://albert-5.cn/tags/伸手er/"},{"name":"自我警告","slug":"自我警告","permalink":"https://albert-5.cn/tags/自我警告/"}]},{"title":"Wechat爬取好友信息","slug":"Wechat爬取好友信息","date":"2019-06-12T13:49:31.000Z","updated":"2019-06-13T17:13:01.126Z","comments":true,"path":"2019/06/12/Wechat爬取好友信息/","link":"","permalink":"https://albert-5.cn/2019/06/12/Wechat爬取好友信息/","excerpt":"","text":"微信好友 一览无余【itchat】一个微信的开源API，微信是一种常用的社交网络应用程序。 通过python中的聊天访问个人微信账户，然后通过微信机器人进行处理个人所有基本信息。 安装itchat模块1pip install itchat 简单使用123import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 详情见itchat官方网站 主要用到的方法有： itchat.login()微信扫码登录 itchat.get_friends()返回完整的列表好友，每个好友为一个字典，其中第一项为自己的账号基本信息，带入参数update=True，将更新好友列表并返回，具体使用itchat.get_friends(update=True) 技巧：使用itchat.login()进行登录微信会有一个问题，就是每运行一次就会生成一个二维码，叮··· 扫描登录，是不是过于麻烦了？ 直接采用itchat.auto_login()，在一定时间内，可以不用扫码登录，只需要在手机移动端确定登录就行了，毕竟是在模拟网页登录 开始操作12345678# 导入所需要的库import itchatimport csvimport pandas as pd# 启用热键扫码登录微信itchat.auto_login(hotReload=True)# 抓取好友信息friends = itchat.get_friends(update=True)[0:] 这时，好友信息已经在存储在friends里面了。 定义函数抓取个字段信息get_var(var) 1234567891011121314151617def get_var(var): variable = [] for i in friends: value = i[var] variable.append(value) return variable# 调用函数得到各个变量,存在csv文件中NickName = get_var('NickName')Sex = get_var('Sex')Province = get_var('Province')City = get_var('City')Signature = get_var('Signature')Username = get_var('UserName')ContactFlag = get_var('ContactFlag')SnsFlag = get_var('SnsFlag') 定义函数parse_friends()，将得到的好友数据存储在txt文本中 1234567891011121314# 收集并保存好友信息数据def parse_friends(): # 设置需要爬取的信息字段,使用字典形式,参考官网以及个人需求设置字段信息 result = &#123;'NickName': NickName, 'Sex': Sex, 'Province': Province, 'City': City, 'UserName': Username, 'ContactFlag': ContactFlag, 'SnsFlag': SnsFlag, 'Signature': Signature, &#125; for user in friends: with open('myfriends.txt', 'a', encoding='utf8') as fh: fh.write('-------------------------\\n') for r in result: with open('myfriends.txt', 'a', encoding='utf8') as fh: fh.write(str(r) + \":\" + str(user.get(r))+\"\\n\") print(\"分析完毕！\") 设置最后打印标识，提醒已完成信息存储；同时当前文件夹中出现一个文件myfriends.txt 信息文件 定义函数male_female()统计男女以及其他人数和比例 统计 然后利用pandas模块将文件信息保存在csv文件中 12345678data = &#123;'NickName': NickName, 'Sex': Sex, 'Province': Province, 'City': City, 'UserName': Username, 'ContactFlag': ContactFlag, 'SnsFlag':SnsFlag, 'Signature':Signature, &#125;frame = DataFrame(data)frame.to_csv('data2.csv', index=True, encoding='utf-8')with open('data2.csv', 'r', encoding='utf-8') as myfile: reader = csv.reader(myfile) for row in reader: print(row) 便于后续采用pandas中的 value_counts 进行计数可视化处理 简单可视化操作 采用pyecharts中的Pie绘制饼图 12# 导入模块from pyecharts.charts import Pie 123456configure(output_image=True)pie = Pie(\"性别比例\", background_color='white', title_text_size=25)attr = ['male', 'female', 'other']v1 = [57.14, 27.04, 15.82] # 好友男女百分比pie.add('', attr, v1, is_label_show=True)pie.render() # render渲染，默认在当前文件夹中的render.html 再使用pyecharts时，可能会出现一些错误，比如不存在Pie或者无法导入Pie等 看了一些博客之后，我采用的方法是降级，即降低库的版本，可能是与python版本有冲突 效果 比例.png 或许这就是你Single的原因吧 –苦笑–","categories":[{"name":"Wechat爬虫","slug":"Wechat爬虫","permalink":"https://albert-5.cn/categories/Wechat爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://albert-5.cn/tags/爬虫/"},{"name":"微信","slug":"微信","permalink":"https://albert-5.cn/tags/微信/"}]},{"title":"算法导论复习","slug":"算法导论复习","date":"2019-06-02T06:22:04.000Z","updated":"2019-06-02T06:25:44.880Z","comments":true,"path":"2019/06/02/算法导论复习/","link":"","permalink":"https://albert-5.cn/2019/06/02/算法导论复习/","excerpt":"","text":"算法复习 1 插入排序思想： 通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 •Sorting problem: –Input: A sequence of n numbers a~1~, a~2~, …, a~n~ –Output: A permutation (reordering) a’~1~, a’~2~, …, a’~n~ of the input sequence such that a’~1~&lt;=a’~2~ &lt;= … &lt;=a’~n~ •An instance of the sorting problem –Input: 8 2 4 9 3 6 –Output: 2 3 4 6 8 9 •Notation: –Sorting is a fundamental operation in CS –A large number of good sorting algorithms have been D&amp;R 算法描述 伪代码 具体python代码实现参考博客文章 时间复杂度的问题： •Worst-case: (usually) –T(n) = maximum time of algorithm on any input of size n. T(n)=maxI {T(n,I)} –Time Complexity (Default ) •Average-case: (sometimes) –T(n) = expected time of algorithm over all inputs of size n. –Need assumption of statistical distribution of inputs. ? •Best-case: (bogus虚假) –Cheat with a slow algorithm that works fast on some input. ? 2 时间复杂度描述$$\\Theta(n) \\quad既有上界又有下界$$ •Engineering: –Drop low-order terms; ignore leading constants. example:$$3n^3 + 90n^2 –5n + 6046 = Θ(n3)$$ $$O(n)\\quad 只有上界$$ $$Ω(n)\\quad 只有下界$$ 3 分治思想recursively 递归 subproblems 子问题 median 中位数 Merge sort •Problem: –Input: A[1,n] –Output: A[1,n] in sorted order •Divide-and-conquer paradigm –Divide: Divide the n-element sequence to be sorted into two subsequences of n/2 elements each. –Conquer: Sort the two subsequences recursively using merge sort. –Combine: Merge the two sorted subsequences to produce the sorted answer. Recursion tree递归树解决递归式问题 例子：$$Solve \\quad T(n)=2T(n)+cn,\\quad where c&gt;0\\quad is \\quad constant$$ 1558947965911 4 快速排序思想: ​ 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 前言介绍 1558947965911 123456789PARTITION (A, p, r) # A是待排序数组 x ← A[r] i ← p-1 FOR j ← p TO r-1 IF A[ j] ≤ x THEN i ← i + 1 exchange A[i] ↔ A[ j] exchange A[i+1] ↔ A[r] RETURN i+1 1558947965911 ​ the run time drops from Ω(n log n) to Ω(n^2^) 提高快速排序的方法 Median-of-three(三平均分区法) 关于这一改进的最简单的描述大概是这样的：与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势： （1） 首先，它使得最坏情况发生的几率减小了。 （2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。 提高的方法可以说是这样的： 首先对整个列表的元素进行选取，第一个位置first，中间位置middle，最后一个位置的元素last，然后以这三个数的中位数（以middle）为基准，对列表剩余的元素进行比较采用插入排序进行sort，这样一来，左边的元素都是小于middle的元素，右边的元素都是大于middle的元素； 然后在对middle左边的元素进行上述操作，对右边进行上述操作，直至待排的元素个数为1。 至此，整个排序也就完成了； 5 Dynamic programming 动态规划Rod cutting Given a rod of length n inches and a table of prices pi for i = 1,2,3,…,n, determine the maximum revenue(收入) r(n) obtainable by cutting up the rod andselling the pieces. 给定长度为n英寸的杆和i = 1,2,3，…，n的价格表p~i~，确定通过切割杆和杆可获得的最大收入r(n)来销售。 问题描述 拓展阅读 6 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法；比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 贪心算法在有最优子结构的问题中尤为有效； 通常情况下，贪心算法采用自顶向下的设计，因为不需要作出过多的选择求解所有子问题； 找零钱问题 123456789101112131415Change-Making ProblemFinding the number of ways of making changesfor a particular amount of cents, n, using a givenset of denominations C=&#123;c1…cd&#125; (e.g, the UScoin system: &#123;1, 5, 10, 25, 50, 100&#125;)– An example: n = 4,C = &#123;1,2,3&#125;, solutions: &#123;1,1,1,1&#125;,&#123;1,1,2&#125;,&#123;2,2&#125;,&#123;1,3&#125;. Minimizing the number of coins returned for aparticular quantity of change (available coins&#123;1, 5, 10, 25&#125;)– 30 Cents (solution: 25 + 5, two coins)– 67 Cents ? 17 cents given denominations = &#123;1, 2, 3, 4&#125;? 算法 活动选择 有一个需要使用每个资源的N个活动组成的集合S ={a1, a2, ···, an},资源每次只能由一个活动使用。每个活动都有一个开始时间和si和结束时间fi，且0=&lt;si&lt;=fi&lt;∞，一旦被选择后，活动ai就只占据时间[si, fi]，如果[si,fi]和[sj,fi]不重叠，则称ai、aj兼容。 12345678910# 活动选取的贪心算法Greedy-Activity-Selector(s, f) n = s.length A = &#123;a1&#125; k = 1 for m = 2 to n if s[m] &gt;= f[k] # 时间的比较 A = A U &#123;am&#125; k = m return A 最优子结构 如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。贪心算法要做的就是逐步求取局部最优解，以致达到全局整体最优。 赫夫曼编码 讨论赫夫曼编码问题，赫夫曼编码的思想就是变长编码；也就是说让字符表中出现概率高的字符的编码长度尽可能的小，而出现概率高的字符的编码相对较长；然后遵循前缀码的要求，即是任意一个编码都不是其他编码的前缀，便于解码。 作者：JeffCoding原文：https://blog.csdn.net/jeffleo/article/details/53557143 赫夫曼编码是一种广泛用于数据压缩的问题，该算法的主要优势在于节约了存储和传输成本。举一个例子：假设要传输的数据为 Figure 0 那么传输成本就是：453 + 30 3 + 29 3 + 10 3 + 8 3 + 5 3 = 381个字符 我们可以使用赫夫曼编码思想来解决先合并最小频率的2个字符对应的子树，计算合并后的子树的频率；重新排序各个子树；重复步骤1重复步骤2对二叉树中的边赋予0、1，得到各字符的变长编码。对于上举的例子而言就是：EF最小，首先构造EF的生成树，重新排序 Figure 1 构造EF 和 D的生成树，重新排序 Figure 2 构造EFD 和 C 的生成树, 重新排序 Figure 3 构造EFDC 和 B 的生成树，重新排序 Figure 4 构造EFDCB 和 A 的生成树，重新排序 Figure 5 赫夫曼编码后的二进制数据为： Figure 6 可以看见，利用赫夫曼思想设计之后，频率高的字符，二进制码短了，频率低的字符，二进制码长了，这样就有效得减少了总得二进制码数。 那么传输成本就是：451 + 30 2 + 29 3 + 10 4 + 8 5 + 5 5 = 292个字符，节约了23%的成本！ End 7 最大流问题流网络 digraph G=(V,E) weights, called capacities on edge c(u,v)边缘容量 two distinct vertices (不同的顶点) source, ‘s’; sink ‘t’ 流网络 The value of a flow is the net flow out of the source:$$\\sum p(s,v)-\\sum p(v,s)$$流网络流出的值是净网络 网络的值 The value of this flow is 1-0+2=3 残存网络 假定有一个流网络G=（V，E），其源点为s，汇点为t，f为G中的一个流。对即诶点对u，v，定义残存容量（residual capacity） img ，有： img 残存网络可能包含图G中不存在的边，残存网络中的反向边允许算法将已经发送出来的流量发送回去。一个残存网络示例图如下： Rabin-KarpRabin-Karp img 图a是一个流网络，b是a对应的残存网络，注意每条边上的值，残存网络中针对每条正向边计算出该条边在存在流的情况下的剩余容量，并画出一条反向边，反向边的容量即是发出流的大小，方便将发出的流运输回发送地，并将权重为0的边省略。 8 字符串匹配Rabin-Karp算法 在实际应用中，Rabin-Karp算法的预处理时间为O（m）,并且在最坏的情况下的时间复杂度为O((n-m+1)m),相对于朴素字符串，它的运行时是比较好的。 整个算法思想介绍如下： 数学中有霍纳法则,我们运用霍纳法则在O(m)内计算p： p=P[m]+10(P[m-1]+10(P[m-2]+…+10(P[2]+10P1)…))) 霍纳法则的解释如下： 运用霍纳法则，类似的我们也可以根据T[s+1…s+m]计算出t. 但为了节约时间，我们可以利用一下方法在常数时间内根据ts,计算出ts+1.具体过程如下图解: 如图所示，ts=31415,ts+1=14152,则 ts+1=(ts-(T[s+1]=3)10^(m=4))10+(T[s+m+1]=2) 注：(ts-(T[s+1]=3)*10^(m=4))=31415-30000=1415 即 ts+1=10(ts-10^(m-1)T[s+1])+T[s+m+1] 在计算过程中，可能会出现p与t的值过大，可以取模运算 确定优先状态自动机 有限自动状态机 上面这个图描述的就叫一个有限状态自动机，图中两个圆圈，也叫节点，用于表示状态，从图中可以看成，它有两个状态，分别叫0和1. 从每个节点出发，都会有若干条边，当处于某个状态时，如果输入的字符跟该节点出发的某条边的内容一样，那么就会引起状态的转换。例如，如果当前状态处于0，输入是字符a,那么状态机就会从状态0进入状态1.如果当前状态是1，输入字符是b或a,那么，状态机就会从状态1进入状态0.如果当前所处的状态，没有出去的边可以应对输入的字符，那么状态机便会进入到错误状态。例如，如果当前处于状态0，输入字符是c,那么状态机就会出错，因为从状态0开始，没有哪条边对应的字符是c。 状态机会有一个初始节点，和一个接收节点，以上图为例，我们可以设置初始节点为0，接收节点为1，当进行一系列的输入，使得状态机的状态不断变化，只要最后一个输入使得状态机处于接收节点，那么就表明当前输入可以被状态机接收。例如对应字符串”abaaa”, 从初始节点0开始，状态机根据该字符串的输入所形成的状态变化序列为：{0，1，0，1，0，1}。由于最后状态机处于状态1，所以该字符串可以被状态机接收。如果输入的字符串是:abbaa, 那么状态机的变化序列为：{0，1，0，0，1，0}， 由于最后状态机处于非接收状态，因此这个字符串被状态机拒绝。 在程序中，使用二维表表示一个状态机： 输入 a b 状态0 1 0 状态1 0 0 接下来我们看看一个文本的匹配流程，假定要查找的字符串为P=”ababaca”, 被查找的文本为T=”abababacaba”. 一次读入T的一个字符，用S表示当前读入的T的字符，一开始读入一个字符，于是S=a.然后看看，从P开始，连续几个字符所构成的字符串可以成为S的后缀，由于当前S只有一个字符a,于是从P开始，连续1个字符所形成的字符串”a”,可以作为S的后缀。把这个字符串的长度记为k,于是此时k 等于1. 继续从T中读入字符，于是S=”ab”, 此时，从P开始，连续两个字符所构成的字符串”ab”可以作为S的后缀，于是k = 2.反复这么操作，于是便有以下序列： 1234567891011S=a, k = 1, P[1] 是S的后缀S=ab, k = 2, P[1,2] 是S的后缀S=aba, k = 3, P[1,2,3]是S的后缀S=abab, k= 4, P[1,2,3,4]是S的后缀S=ababa, k = 5, P[1,2,3,4,5]是S的后缀S=ababab, k = 4, P[1,2,3,4]是S的后缀S=abababa, k = 5, P[1,2,3,4,5]是S的后缀S=abababac, k = 6, P[1,2,3,4,5,6]是S的后缀S=abababaca, k = 7, P[1,2,3,4,5,6,7]是S的后缀S=abababacab, k =2, P[1,2] 是S的后缀S=abababacaba, k = 3, P[1,2,3] 是S的后缀。 从上述过程中，我们可以看到第九步的时候字符串P已经成为了S的后缀，此时的S是文本T的前缀，因此可以说明在字符串T中找到了模式串P。 如果问题变化，构造一个方法，使得一次运行便能知道从P开始，连续读取几个字符能使得这几个字符构成的字符串是S的后缀。这个方法，就需要上面我们提到的有限状态自动机了 用于字符串匹配的自动机 假定字符串P和文本T只由a,b两个字符组成，也就是字符集为∑={a,b,c}, P含有m个字母，于是，我们要构造的自动机就含有m个状态节点。假设我们当前处于状态节点q, 那么当下一个输入字符是a和b时，从当前节点q该跳转到哪一个节点呢？ 如果用$P_q$来表示长度为q的P的前缀，以q=4, p=”ababaca”, $P_q$ =”abab”, 那么当处于状态4, 当输入为a时，我们构造字符串 S = $P_q$ + ‘a’ = “ababa”, 然后看看字符串P从第一个字符开始，连续几个字符所构成的字符串可以成为S的后缀，就当前S为例，从第一个字符开始，连续5个字符，也就是P[1,2,3,4,5]可以作为S的后缀，于是，我们就有，当状态机处于节点4，输入为a时，跳转的下个状态就是5. 同理，当处于状态q=4,输入为字符b时，S = $P_q$ + ‘b’ = “ababb”,此时从P开始，连续读取0个字符才能形成S的后缀，于是当状态机处于状态4，如果读入字符是b, 那么跳转的下一个状态是0，同理，如果输入字符是c, 那么S = $P_q$ + ‘c’ = “ababc”, 此时从P开始，连续读取0个字符所形成的空字符串才能作为S的后缀，于是当状态机处于状态节点4，输入字符为c时，跳转到节点0. 如果q从0开始，一直到m,反复运用刚才提到的步骤，便会产生下面这个跳转表： 输入 a b c 状态0 1 0 0 状态1 1 2 0 状态2 3 0 0 状态3 1 4 0 状态4 5 0 0 状态5 1 4 0 状态6 7 0 0 状态7 1 2 0 状态I就是上面介绍的K的值，也就是P中形成的字符串可以构成S的后缀的长度； KMP算法 算法流程 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 next数组的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀，例如如果next[j]=k,代表j之前的字符串中有最大长度为k的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符； 步骤 ① 寻找前缀后缀的最大公共元素长度 对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示： 比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k+1 = 2）。 ② 求next数组 next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示 比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1） 补充 寻找最长前缀后缀 如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示： img 也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）： img 而且，根据这个表可以得出下述结论 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 给定字符串“ABCDABD”，可求得它的next 数组如下： img 把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。 kmp算法的复杂度是O(n+m) 参考文章 https://blog.csdn.net/tyler_download/article/details/52549315 https://blog.csdn.net/v_july_v/article/details/7041827#t5","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"插入排序","slug":"插入排序","permalink":"https://albert-5.cn/tags/插入排序/"},{"name":"算法导论","slug":"算法导论","permalink":"https://albert-5.cn/tags/算法导论/"},{"name":"最大流问题","slug":"最大流问题","permalink":"https://albert-5.cn/tags/最大流问题/"},{"name":"KMP算法","slug":"KMP算法","permalink":"https://albert-5.cn/tags/KMP算法/"}]},{"title":"网络流Network_Flow","slug":"网络流Network-Flow","date":"2019-06-01T04:44:08.000Z","updated":"2019-06-01T04:45:35.097Z","comments":true,"path":"2019/06/01/网络流Network-Flow/","link":"","permalink":"https://albert-5.cn/2019/06/01/网络流Network-Flow/","excerpt":"","text":"内容来源于爱美工的程序员 网络流（Network Flow）网络流和线性规划、动态规划是有关系的。它们都属于数学规划，也就是用数学的方法来帮助决策。（详情参考清华大学《数学规划》）这样来看，就没有神秘可言了。小样，换个马甲我还认识你。所以，网络流也是一个解决极值问题的数学方法。 要解决问题，总得先有个靠谱的模型吧。动态规划和线性规划里边都有公式啥的。总之，要先形式化（建模），再解决。所以，就有了流网络。 流网络（Flow Network）顾名思义，流网络是一种用流构成的网络，如下图。 img 可以把边想象成自来水的管道，把节点想象成管道的连接组件。其中，管道的容量不一定相同，所以就有了不同的边的权重（管道容量是一个大于等于0的常量）。流网络是一个有向图，所以，管道是有方向的（水的流向只能按照管道的方向流）。注意图中两个特殊的连接组件，s代表源，也就是水的入口，t代表汇，也就是水的出口。也就是说，水从s点灌入，从t点流出，具体有多少水流入s，我们不用管，反正是源源不断；从t流出的水去哪，我们也不用操心。 这样，我们就得到了一个流网络，s是流的入口，t是流的出口，s和t之间有若干个管道连接。要谨记这个流网络中管道的容量限制和方向限制，若是没有它，又何必来学网络流。 流（Flow）流网络可以看成是一张线路图，这里是自来水管道的线路图，相当于硬件基础设施。 我们现在要做的是使用这个基础设施，也就是往管道里灌水，确保每个管道里的流量不超过容量限制。比如，我们可以这样灌，如下图。边的权重增加了流量参数，使用斜线与容量进行分隔。 注意：这里的所有图中，如果有斜线标识，则左侧表示流，右侧表示容量。如果没有斜线，则只是表示容量。 img 对流网络灌水得到的就是“流”。当然，这只是其中一种满足流量不超过容量限制的灌水方法。还可以有很多种灌水的方法。但是都要遵循以下两个原则： 容量限制：管道的流量不能超过容量。 流量守恒：流入管道连接组件的流量等于流出的流量。 至此，我们成功的得到了“流”。 s-t流（s-t Flow）现实往往是不按套路出牌的。比如，连接的地方（节点）可能有权重，能够蓄水。比如，有多个源多个汇。比如，有多个管道连接两个节点。 总之，现实的种种迹象表明，我们需要设计一个兼容并包的模型，考虑种种情况。 但是，我们不想考虑那么多情况。 于是，就有了一个小伙想了个点子，定义一种标准模型，我们只研究这个标准的模型。其它的情况通过一些方法转化成这个标准模型。 是的，这个标准模型就是s-t流。一些转化方法如下图。 img 最大流（Maximum Flow）费尽心思，从初步的流网络，到我们比较喜欢的标准形式s-t流，是时候考虑正事儿了。 流网络是固定的，但是流是不确定的。所以，我们想在多种灌水的方法中寻找最佳。 何为最佳？ 在源灌入大量的水，通过选择最好的管道流量和流向，使得汇流出的流量最大。但是，最大流不是想找就能找到的，所以这是个问题，即最大流问题。 Trial 1: Dynamic programming既然是数学规划，首先想到的是能不能使用动态规划。 现实情况是，目前还没有解决最大流问题的动态规划算法。 Trial 2: Iteration想到的另外一种方法是迭代法，伪代码表示如下。 12345678x = x0;while true do x = improve(x); if stopping(x) then break end ifend whilereturn x 主要是思想是从某个流开始，不断的改进这个流，直到到达我们想要的最大流。 不得不说，这想法太粗略了。一些问题没有解决，比如，如何选择开始的流，如何改进，何时停止算法。 为了解决这些问题，我们需要继续补充一些基础知识。这样才能干掉这个问题。 （为什么不试试线性规划？线性规划是可以解决的，但是对于这种网络的结构，并不能很高效。） 割（Cut）对于一个流网络，在若干个管道上切一刀，使这个网络分成两部分，这两部分将无法连通。所以，我们有很多种切割的方法，把这个网络分成两部分。每一种切割的方法对应于一个“割”。 s-t割（s-t Cut）s-t割是一种特殊的“割”，这种切割的方式需要保证在切割之后s和t不再连通，即s和t不属于同一部分了。 对于一个s-t割，必然会把s和t分到两个小网络中，并且切坏了若干个管道。这两个小网络之间的管道容量之和就是割的值，只计算从包含s的小网络流向包含t的小网络的管道容量之和，反方向不考虑。一个s-t割如下图。 img 可以计算出，割的值为12+14=26。可以看到，割的值只与流网络有关，和流无关。对于一个确定的流网络，一刀切下去，割的值就确定了。 最小割（Minimum Cut）对于一个流网络，我们可以得到多个割的值，因为切的方法有很多种，如下图。 img 在这里，我们更关心割值最小的情况，即最小割。为什么更关心最小割？下面会说~ 净流量（Net Flow）注意到，割的值是和流无关的，只与流网络有关。也就是说，割的值只是取决于管道的容量和方向，以及切的方法。 如果我们观察一下流，发现了一个规律，如下图。 img 真的是固定值有木有！这个固定值就是净流量。之所以有这个规律，是因为流量守恒。 需要注意，在计算净流量时，需要考虑两个方向的值，并求代数和。从s流向t记为正，从t流向s记为负。对于割值的计算，则无需考虑从t流向s的。因为割值实际计算的是管道容量，净流量考虑的是真实的流量。 残留网络（Residual Network）残留网络，顾名思义，就是流网络中去掉流剩下的网络。对于某条管道，其容量减去流以后剩下的流构成的网络，就形成了残留网络。每一个流会对应一个残留网络，残留网络 = 流网络 - 流，如下图。 img 需要说明的是，蓝色的边称作反向边，方向与原来的方向相反，数值为原来流量的值。 为什么要加上这个看似多余的反向边？ 反向边的作用就是给程序一个可以后悔的机会。（来自这里)） 也就是说，加这个边是为了寻找最大流的程序的执行。 增广路径（Augmenting Path）扯这么多，主要是为了引出这个增广路径。因为增广路径能帮我们找到最大流。 增广路径就是残余网络中的一条s到t方向的路径，如下图。 img 如果我们找到了这样一条路径，说明原来的流不够大，还可以在这条路径上压入一些流量，在这里是3，取11、12、3中最小值。 这样，我们就可以得到更大的流。 思考从流（我们更关心最大流），到割（我们更关心最小割），到残留网络，再到增广路径，我们在做啥子吗？ 我的理解是，这些流呀割呀都是理论储备，最终是想证明一句话：残留网络$G_f$中不包含增广路径时，f就是G的最大流。 而残留网络、增广路径是解决这个最大流问题的手段，通过寻找增广路径的方法来改进当前的流，朝最大流逼近。但是，问题是何时停止算法呢？这就是理论储备部分告诉我们的，如下图。 img 最大流最小割定理（Max-Flow Min-Cut Theorem）重述一遍，残留网络$G_f$中不包含增广路径时，f就是G的最大流（或者说，最大流的流量等于最小割的容量）。 这就是传说中的最大流最小割定理。 这个可以用反证法证明，假设当不包含增广路径时没有达到最大流，那么就会找到一条路径来增大流，也就找到了增广路径，所以矛盾。大致是这样证明。 Ford-Fulkerson方法Ford-Fulkerson是一种求解最大流的方法，依赖于上面积淀的基础知识（主要是残留网络、增广路径、割的功劳），也称作“扩充路径方法”。之所以称之为方法而不是算法，是因为这个只是一种指导思想，在此指导之下，有很多种实现方式。 Ford-Fulkerson是一种迭代法，过程如下： 流网络中所有顶点对的流大小清零（此时，网络流为零） 每次迭代，通过寻找一条增广路径来增加流的值 无法找到增广路径时，迭代结束 可以看到，最关键问题是如何寻找增广路径，而Ford-Fulkerson方法的效率正取决于此。如果选择方法不好，就有可能每次增加的流非常少，而算法运行时间非常长，甚至无法终止。 但是，Ford-Fulkerson并没有告诉我们如何寻找增广路径。所以，它是个方法，而不是算法，伪代码如下。 1234567891011121314 initialize f(e) = 0 for all ewhile there is a s-t path in residual graph Gf do arbitrarily choose an s-t path P in Gf f = augment(P, f)end whileaugment(P, f) let b = bottleneck(P) for each edge e = (u, v) ∈ P do if (u, v) is a forward edge then increase f(u, v) by b else decrease f(u, v) by b end if end for 其中，augment是一个改变当前流的函数，即使用找到的增广路径P来压入流，增大当前的流f。而bottleneck从当前的增广路径P中找到瓶颈边（残留网络中，路径上流量最小的边），把这个流量压入。 正是因为在选择增广路径时是arbitrarily，所以Ford-Fulkerson方法有多种实现。 Scaling technique第一种是scaling的方法，通过伪代码更好解释。 123456789initialize f(e) = 0 for all elet △ = Cwhile △ ≥ 1 do while there is a s-t path in Gf(△) do choose a s-t path f&apos; = augment(P, f) f = f&apos; end while △ = △ / 2 可以看到，通过定义一个△来调节增广路径的选择顺序。C是一个定义的常熟。如果残留网络中的边（流量值）小于C，则“删除”该边，在新的网络中选择增广路径。如果这样的网络中找不到增广路径（也就是说，所有的边都不符合△的限制），则把△缩放为原来的一半，继续寻找增广路径。直到△不满足大于等于1时，算法结束。 例子来自卜老师的课件，△初始化为96。第一次的时候，残留网络的所有边被“删除”（标记为蓝色），因为都小于96。然后△调整为96/2=48，这样就获得了一条增广路径，并压入流。直到找不到增广路径，算法结束，如下图。 img 可以看到，scaling方法是通过加一个△（阈值）来选择增广路径的。通过这个阈值，可以尽可能的一次压入多一些的流。我们的目标是迭代的次数少且每次压入的流要多。 Edmonds-KarpEdmonds-Karp算法是使用BFS（广度优先搜索）的方式，选择最近的路径作为增广路径，伪代码如下。 123456initialize f(e) = 0 for all ewhile there is a s-t path in Gf do choose a shortest s-t path in Gf using BFS f&apos; = augment(P, f) f = f&apos;end while 补充走了好久终于等到现在… 总结来说，前面一直在铺垫，积累些基础知识，为了得到最大流最小割定理，然后证明Ford-Fulkerson方法能够获得最大流。 但是，这终归是个方法。方法没有告诉我们哪一种寻找增广路径的算法是最好的。于是就有人搞了各种算法，进行了各种测试，性能也就各不相同了，如下图。 img 总之，是为了算法实现的更好，终极目标是高效的找到最大流，也就是解决最大流问题咯。 一些参考： http://www.csie.ntnu.edu.tw/~u91029/Cut.html#2 http://blog.csdn.net/leolin_/article/details/7202691 http://blog.csdn.net/smartxxyx/article/details/9293665 http://blog.csdn.net/kk303/article/details/6728400 http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591573.html http://chhaj5236.blog.163.com/blog/static/112881081200982835124243/ http://xpgc.vicp.net/course/ada4ia/TechDoc/ch09/ia-09-maxflow.pdf 1-- EOF --","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://albert-5.cn/tags/算法导论/"},{"name":"网络流","slug":"网络流","permalink":"https://albert-5.cn/tags/网络流/"},{"name":"最大流问题","slug":"最大流问题","permalink":"https://albert-5.cn/tags/最大流问题/"}]},{"title":"Typora语法","slug":"Typora语法","date":"2019-05-31T08:35:16.000Z","updated":"2019-05-31T08:47:44.970Z","comments":true,"path":"2019/05/31/Typora语法/","link":"","permalink":"https://albert-5.cn/2019/05/31/Typora语法/","excerpt":"","text":"Typora 语法数学表达式要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令，例如：$lim_{x \\to \\infty} \\ exp(-x)=0$将产生如下的数学表达式： $\\lim_{x \\to \\infty} \\exp(-x)=0$ 下标下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 上标上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 插入表情:happy:使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线Underline. 删除线GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 代码 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生printf()样式。 输入~~~或者12- ​1234public Class HelloWorld&#123; System.out.println(\"Hello World!\");&#125;​ 1234567将会产生```javapublic Class HelloWorld&#123; System.out.println(&quot;Hello World!&quot;);&#125; 强调使用两个*号或者两个_包裹的内容将会被强调。例如 12**使用两个*号强调内容**__使用两个下划线强调内容__ 将会输出 使用两个*号强调内容使用两个下划线强调内容Typroa 推荐使用两个*号。 斜体在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\\* 插入图片我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 插入URL连接使用尖括号包裹的url将产生一个连接，例如：&lt;www.baidu.com&gt;将产生连接:&lt;www.baidu.com&gt;. 如果是标准的url，则会自动产生连接，例如:www.google.com 也可以借用HTML中的语法结构，使用标签 目录列表Table of Contents（TOC）输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 水平分割线使用***或者---，然后回车，来产生水平分割线。 标注我们可以对某一个词语进行标注。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 表格12345|姓名|性别|毕业学校||:---|:---:|:---:||1|男|1||2|男|1||3|女|1| 将产生: 姓名 性别 毕业学校 1 男 1 2 男 1 3 女 1 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个是居中，最后一个是右对齐。 数学表达式块输入两个美元符号，然后回车，就可以输入数学表达式块了。例如： 1$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$$ 将会产生: 123.png 任务列表使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。 1234- [ ] 吃饭- [ ] 逛街- [ ] 看电影- [ ] 约泡 吃饭 逛街 看电影 约泡 列表输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** tfboys* 杨洋* 我爱你 无序的列表 tfboys 杨洋 我爱你 1234**有序的列表**1. 苹果6. 香蕉10. 我都不喜欢 有序的列表 苹果 香蕉 我都不喜欢 块引用使用&gt;来插入块引用。例如： 1&gt;这是一个块引用！ 将产生： 这是一个块引用！ 标题使用#表示一级标题，##表示二级标题，以此类推，有6个标题。","categories":[{"name":"学习","slug":"学习","permalink":"https://albert-5.cn/categories/学习/"}],"tags":[{"name":"typora","slug":"typora","permalink":"https://albert-5.cn/tags/typora/"}]},{"title":"个人博客","slug":"个人博客","date":"2019-05-24T05:42:28.000Z","updated":"2019-05-24T06:12:12.653Z","comments":true,"path":"2019/05/24/个人博客/","link":"","permalink":"https://albert-5.cn/2019/05/24/个人博客/","excerpt":"","text":"一、什么是hexoHexo是一个快速，简单和强大的博客框架。您使用Markdown（或其他语言）撰写帖子，Hexo会在几秒钟内生成具有漂亮主题的静态文件。 也就是说，通过Hexo创建的博客是一个仅提供在线浏览功能的静态博客，不存在后台编辑功能，添加新博客时需要在自己开发机上编写新博客文章（.md文件），再次生成一个新版本网站，上传并替换，从而实现新文章发布 二、什么是node.js度娘这样说Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 img 三、什么是githubpagesGitHub Pages 是GitHub提供的个人静态主页网站托管服务，原目的是用于提供你在GitHub上托管的所有开源项目介绍，后来也推荐作为个人博客之类的用途 优势是使用简单方便，免费高效实时，可用空间高达1G，可绑定自定义域名，原生自带GitHub级别防护 四、下面开始安装操作首先安装Git 具体教程可参见 教程 安装node.js 在官网上可下载Windows以及Mac的安装包，安装完成后将自带npm工具（Node Package Manage，node包管理器） 安装hexo Windows ctrl+r 打开命令行，键入cmd进入界面 然后进入某个文件夹（就是要下载的文件位置）输入以下命令 1npm install -g hexo-cli 等待下载 loading 安装hexo-cli 下载完成后键入下列命令 1hexo -v 下载hexo效果图 为了便于发布到GitHub上，建议同时安装hexo-deployer-git 1npm install hexo-deployer-git --save Hexo安装文档 初始化，建立博客项目 选定网站项目程序文件的存放位置，比如~/develop/hexo/github/，bash中cd进入该目录中，执行下列命令 1hexo init 完毕后该命令将在当前目录下生成一套标准的hexo博客项目模板 网站生成 虽然有了生成一套网站构成的“源代码”，实际发布的时候需要根据这些“源代码”当中的配置文件、博客文档（后缀为.md）、主题模板等进行配置，生成服务器可以识别的标准HTML网站目录，此时可以使用一下命令： 1hexo g 执行完毕后，在public目录下可看到我们自己书写的博客文档（.md文件）与所选的博客主题模板链接组合，生成的最终静态网站文件，该目录也差不多就是之后发布到GitHub上的实际文件（实际发布到GitHub的是.deploy_git目录），外部的网站“源代码”不会上传到github.io库 hexo g 刚开始一直显示有个错误 123&gt; ERROR Local hexo not found in G:\\NewBlog\\github&gt; ERROR Try running: &apos;npm install hexo --save&apos;&gt; 哎呦，hmp，可急死我了，度娘，谷哥都不行，无奈之下，急中生智，刚开始下载的node.js太jier老了，我急忙连上手机热点（本想着网速更快一点，实者然并卵），一直在那慢慢悠悠的下载。。。。。 这才解决了上面的那个问题，perfect！！！ 之后启动本地服务器查看网站运行效果 1hexo s 默认地址是[localhost:4000][] 五、选择主题hexo可以随时使用更换博客主题 Hexo可随时使用、更换博客主题 主题文件可在Hexo官方主题网页中下载，以Conci为例，点击主题预览图下方的主题名称链接即可进入该主题的源码发布页面https://github.com/cspp01/concise 随后根据主题安装指导，下载项目至博客项目下的themes目录中，文件夹命名为material，并在博客配置文件_config.yml中指定使用该主题： 1theme：你的主题名 然后将主题名目录下的_config.template.yaml重命名为_config.yaml，如果已经自动更改，则就不用更改了。 参考你的主题文档进行必要配置 再次执行hexo g将会重新根据主题构建整个博客。 六、发布博客创建github.io仓库 在自己的GitHub中，创建新仓库，标准命名为GitHub用户名.github.io 七、修改博客配置文件_config.yml1234deploy: type: git repo: GitHub上传仓库的完整路径 branch: master 发布到GitHub 在hexo g生成完毕后，可执行该命令发布博客到GitHub上： 1hexo d 或在生成网站的同时进行发布： 1hexo g -d 查看效果 点击仓库页面中的GH Pages按钮，应该可以看到真正发布在互联网上的效果 但是有时候并不是你想象的那种顺利啊 :cry: 总有刁民想害朕，比如这位 hexo d 错误 显示出本地无法找到Hexo之类的，这种情况下按照提示做一下就可以的。 还有就是搭建Github托管的时候的错误 教程可以点击这里查看官方文档：[教程][https://hexo.io/zh-cn/docs/deployment.html] 1、生成ssh key(下载了Windows版的Git就可以使用的) 首先检查本机是否安装了ssh: 在git中，使用 12&gt; $ ssh&gt; 2、输入命令 12&gt; $ ssh-keygen -t rsa&gt; 这表示我们指定RSA算法生成密钥，然后敲三次回车，期间不需要输入密码，当然也可以输入的，之后会生成两个文件，id_rsa和id_rsa.pub,也就是对应着密钥和公钥。这两个文件在C盘下的.ssh文件夹中 密钥和公钥生成之后，我们要做的事情就是把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！ &lt;点击个人github主页–倒三角–settings–SSH keys&gt;，将id_rsa.pub用记事本打开后并复制里面的字符粘贴到ssh keys下即可。 3、添加玩公钥之后，运行一下命令 12&gt; $ ssh -T git@github.com &gt; 当出现Hi！You’ve successfully authenticated,but github does not provide shell access.的时候表示成功啦~~ 当然也会有很多问题出现的 Could not open a connection to your authentication agent 其实是未启动ssh agent Git for Windows 中输入 12&gt; eval &apos;ssh-agent -s&apos;&gt; 如果出现 Agent pid 数字，说明已经启动。 另外也有*git@github.com permission denied(pubkuckey)权限被拒绝的问题* 解决方案： here!!! 然后还要配置身份信息 12git config --global user.name \"\"git config --global user.email \"\" 之后打开_config.yml文件做如下设置： 12345deploy: type: git //非git请参考官方文档中的设置 repo: &lt;repository 参考 ：url&gt;git@github.com:yourname/yourname.github.io.git branch: [branch] master message: [message] 特别注意：一定要用诸如sunlime text的编辑器打开修改，格式是冒号后有空格，冒号后有一个空格，冒号后有一个空格~~ 经历了种种困难，终于迎来了胜利的时刻 在项目文件夹下： 12hexo ghexo d 登录页面 :happy: 舒服的一批！！！ 这其中也遇到了一些问题 1hexo d 之后无反应，无反应，无反应！！！ 就是上述提到的空格问题，注意下就行了。。。 hexo d之后遇到fatal: unable to access ‘http://github.com/ab/ab.github.io.git 的问题 这是配置github的问题，在.yml文件下找到repo和url,前者的github仓库格式是 https://github.com/username/username.github.io.git，后者的就是你的https://username.github.io/··· 还有一个捷径 关于下载npm过慢的问题，借用淘宝npm镜像的方法 临时使用 1npm --resgistry https://registry.npm.taobao.org install express 持久使用 1npm config set registry https://registry.npm.taobao.org 下载后可以通过以下方式检验是否成功。 123npm config get registry或者 npm info express 功能添加： 添加点击特效 在主题下的source/indigo/source/js目录下新建文件click.js，并复制下列代码 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在文件夹themes/indigo/layout/layout.ejs中添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/clicklove.js&quot;&gt;&lt;/script&gt; OK 关于社会主义核心价值观的特效更为简单 只需要在layout.ejs中加入下列代码，可以紧跟着爱心特效 123456&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 鼠标点击特效 - 7Core.CN */ var a_idx = 0;jQuery(document).ready(function($) &#123;$(&quot;body&quot;).click(function(e) &#123;var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot; ,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length;var x = e.pageX,y = e.pageY;$i.css(&#123;&quot;z-index&quot;: 100000000,&quot;top&quot;: y - 20,&quot;left&quot;: x,&quot;position&quot;: &quot;absolute&quot;,&quot;font-weight&quot;: &quot;bold&quot;,&quot;color&quot;: &quot;#ff6651&quot;&#125;);$(&quot;body&quot;).append($i);$i.animate(&#123;&quot;top&quot;: y - 180,&quot;opacity&quot;: 0&#125;,1500,function() &#123;$i.remove();&#125;);&#125;);&#125;);&lt;/script&gt; Perfect 接下来添加博客姐姐 git中输入下列代码 npm install –save hexo-helper-live2d下载 当出现下列显示时表明已经下载完成 1Thank you for using hexo-helper-live2d! 然后点击此处选择自己喜欢的镇站之宝 我暂时选择了这个 命令行中输入 1npm install live2d-widget-model-***（模型名称） 文件_config.yml进行配置 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-名称 display: position: right width: 150 height: 300 mobile: show: true 关于添加博客评论的事项 参见教程[here][https://www.whereareyou.site/article/2018-4-20%20%E5%9C%A8%E7%AB%99%E7%82%B9%E4%B8%AD%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BF%AE%E6%94%B9%E8%AF%84%E8%AE%BA%E6%A0%B7%E5%BC%8F.html] 关于添加网站logo图标问题 不同的浏览器有不同的要求 对于IE，Microsoft建议在favicon.ico文件中打包16x16,32x32和48x48。 对于iOS，Apple建议使用特定的文件名和分辨率，对于运行iOS 8的最新设备，最多为180x180。 Android Chrome主要使用清单，也依赖于Apple touch图标。 Windows 8.0上的IE 10需要PNG图片和背景颜色，Windows 8.1和10上的IE 11接受在称为专用XML文件中声明的几张PNG图片browserconfig.xml.aspx)。 用于Mac OS X的Safari El Capitan为固定标签引入了SVG图标。 其他一些平台寻找具有各种分辨率的PNG文件，例如Google TV的96x96图片或Opera Coast的228x228图片。 16 x 16 - 浏览器的标准尺寸24 x 24 - 用户界面的IE9固定网站尺寸32 x 32 - IE新页面选项卡，Windows 7+任务栏按钮，Safari阅读列表侧栏48 x 48 - Windows站点57 x 57 - iPod touch ，iPhone高达3G60 x 60 - iPhone触控至iOS764 x 64 - Windows网站，Safari阅读器列表侧边栏，HiDPI / Retina70 x 70 - Win 8.1 Metro tile72 x 72 - iPad触控至iOS676 x 76 - iOS796 x 96 - GoogleTV114 x 114 - iPhone视网膜触控至iOS6120 x 120 - iPhone视网膜触控iOS7128 x 128 - Chrome网上应用店应用程序，Android144 x 144 - IE10 Metro图块适用于固定网站，iPad视网膜可达iOS6150 x 150 - 赢得8.1 Metro地铁152 x 152 - iPad视网膜触摸iOS7196 x 196 - Android Chrome310 x 150 - Win 8.1宽地铁瓷砖310 x 310 - Win 8.1 Metro瓷砖 这里有很多图标的，选择自己喜欢的，然后下载，添加到指定文件夹，最后在配置文件中配置一下就行的 文章 配置信息 在scaffolds/post.md文件下，让它生成默认的categories和tags： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: default techtags: [hexo1,hexo2]--- 八、修改修改站点文件夹下node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。 九、增加代码12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 完整文件代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;;&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 以上便是有关配置方面的问题 小功能添加 1、置顶排序 在文章中，增加top值定义，值越大，文章排序越靠前。top值默认为0，若不设置top，则不参与排序。示例： 123456789title: 为Hexo添加文章置顶功能（三）categories: Techtags: [Hexo,文章置顶]top: 1date: 2016-07-20 11:44:40## 标题正文 2、添加谷歌site 怎么让百度和google搜到你的文章呢参照这两篇文章可以解决google搜到文章的问题，但我向百度引擎入口提交了很多次还是没有搜到，也不明缘由，其中第二篇参考文献的作者也遇到了同样的问题，这个就代跟进把。 文章如下： “｜Hexo优化｜如何向google提交sitemap（详细）” “博客推广——提交搜索引擎” 3、为主题安装 MetingJS和插入音乐 注：以下部分根据 MetingJS 中 README.md 配置，可同理应用于其他主题。 修改文件 在themes\\indigo\\layout\\_partial\\head.ejs中插入在&lt;/head&gt;前： 123 &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 在themes\\indigo\\layout\\_partial\\script.ejs中结尾插入： 1&lt;script src=\"//cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js\"&gt;&lt;/script&gt; 然后就可以在任何地方随时插入音乐了，例如： 123文章内容1&lt;div class=\"aplayer\" data-id=\"60198\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"random\"&gt;&lt;/div&gt;文章内容2 具体见参考 特别感谢 博主文章 一些问题 能够生成md文件但是无法渲染成网页页面 解决分析 [异常]npm ERR! peer dep missing: acorn@^6.0.0, required by acorn-dynamic-import@4.0.0 12&gt; npm install acorn&gt; npm ERR! peer dep missing: webpack@^4.4.0, required by mini-css-extract-plugin@0.4.0 12&gt; npm install --save-dev webpack&gt; 4、加入站点地图 安装：hexo下载sitemap插件 1npm install hexo-generator-sitemap --save 选项，在配置此插件_config.yml 123sitemap: path: sitemap.xml template: ./sitemap_template.xml path - 站点地图路径。（默认：sitemap.xml） 模板 - 自定义模板路径。此文件将用于生成sitemap.xml（请参阅默认模板默认模板） Excluding Posts Add sitemap: false to the post’s front matter. Sitemap即网站地图，它的作用在于便于搜索引擎更加智能地抓取网站。最简单和常见的sitemap形式，是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据 参考文章 5、标签、分类追加 资料： [点击][http://ijiaober.github.io/2014/08/05/hexo/hexo-04/?spm=5176.7935156.0.0.5a3c3a09B5NXeC] 标签分类参考 官方分类 更改页面宽度https://tianwenyu.github.io/hexo-indigo/ 6、增加文章图片显示标题和大图预览模式。 1.26版本加入图片显示标题，需要使用插件语法格式： 1&#123;% image http://img.bizhi.sogou.com/images/2015/06/26/1214911.jpg 测试图片 %&#125; 这样就产生一个问题：旧文章中的图片需要手动修改格式以支持显示标题。 1.3版本在集成大图预览功能的前提下，对图片标题显示的实现作了变动，现在你只需要按 Markdown 格式插入图片就可生成具有标题和大图预览功能的图片; 如果文章对您有那么一丢丢用，还请赏一下喽","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://albert-5.cn/categories/学习笔记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://albert-5.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://albert-5.cn/tags/github/"},{"name":"学习记录","slug":"学习记录","permalink":"https://albert-5.cn/tags/学习记录/"}]},{"title":"模拟退火算法","slug":"模拟退火算法","date":"2019-05-23T15:51:26.000Z","updated":"2019-05-24T11:56:46.207Z","comments":true,"path":"2019/05/23/模拟退火算法/","link":"","permalink":"https://albert-5.cn/2019/05/23/模拟退火算法/","excerpt":"","text":"模拟退火算法 模拟退火算法(SimulatedAnnealing)是基于Monte-Carlo迭代求解策略的一种随机寻优算法,主要用于组合优化问题的求解。 假设现在有这么一个函数：$$f(x) = x^3-72x^2+4x+5$$现要求其在[0,100]范围内的最小值，如果不求导计算，可能第一反应都是穷举法，把范围内每个值都算一遍再比较大小。如果求的是整数范围，那么要算100遍，但是如果要精确到小数后8位，则要算10000000000次，即便使用计算机依然是一个庞大的运算过程。而优化问题中很多都类似于问题，无法用穷举法解出答案，我们叫这类问题为NP难问题（可查看维基百科：NP-hard），于是，有人提出了爬山法 也可以参考下争取几句话描述一下爬山法，模拟退火，遗传算法他的博客文章博客文章 但是这个方法的缺点在于最优解的产生依赖于最初值的选取，无法解决非凸函数，即容易收敛于局部最优解；同时，也无法解决有平台的函数的问题 于是，Kirkpatrick等提出了模拟退火算法，它是一种启发式搜索算法，即按照预定的控制策略进行搜索，在搜索过程中获取的中间信息将用来改进控制策略 1. 模拟退火算法的原理 1.1 概念 模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。 模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以一定的概率准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果。 1.2 状态空间与邻域函数 状态空间也称为搜索空间，它由经过编码的可行解的集合所组成。而邻域函数应尽可能满足产生的候选解遍布全部状态空间。其通常由产生候选解的方式和候选解产生的概率分布组成。候选解一般按照某一概率密度函数对解空间进行随机采样获得，而概率分布可以为均匀分布、正态分布、指数分布等。 1.3 状态转移概率（Metropolis准则） 状态转移概率是指从一个状态转换成另一个状态的概率，模拟退火算法中一般采用Metropolis准则，具体如下：$$P = \\begin{cases}1 &amp; E(x_{new})&lt;E(x_{old}) \\exp(-E(x_{new})&lt;E(x_{old})\\over{T} &amp; E(x_{new})\\geq E(x_{old})\\end{cases}$$其与当前温度参数T有关，随温度的下降而减小。 1.4 冷却进度表 冷却进度表是指从某一高温状态T向低温状态冷却时的降温函数,设时刻的温度为T(t)，则经典模拟退火算法的降温方式为：$$T(t)={T_0\\over{lg(t+1)}}$$快速模拟退火算法的降温方式为：$$T(t) = {T_0\\over{t+1}}$$另外还有其他的降温函数，其实只是收敛的速度不同罢了。 1.5 初始温度 一般来说，初始温度越大，获得高质量解的几率越大，但是花费的时间也会随之增加，因此，初温的确定应该同时考虑计算效率与优化质量，常用的方法包括： (1)均匀抽样一组状态，以各状态目标值的方差为初温。 (2)随机产生一组状态，确定亮亮状态间的最大目标值差，然后根据差值，利用一定的函数确定初温，如：$$T_0 = -{\\Delta_{max}\\over P_r}$$其中Pr为初始接受概率。 (3)根据经验公式给出 1.6 循环终止准则 内循环终止准则： （1）检验目标函数的均值是否稳定 （2）连续若干步的目标值变化较小 （3）按一定的步数进行抽样 外循环终止准则 （1）设置终止温度 （2）设置外循环迭代次数 （3）算法搜索到的最优值连续若干步保持不变 （4）检验系统熵是否稳定 Python实现过程： 下面便通过python求解开头提到的问题，首先定义函数，然后通过pyplot看看函数在[0,100]上的大致图像： 12345678910111213141516from __future__ import divisionimport numpy as npimport matplotlib.pyplot as pltimport math#define aim functiondef aimFunction(x): y=x**3-60*x**2-4*x+6 return yx=[i/10 for i in range(1000)]y=[0 for i in range(1000)]for i in range(1000): y[i]=aimFunction(x[i])plt.plot(x,y)plt.show() img 可以看到最小值大概在48左右，通过求导计算得到最小值为48.45。 接下来便构造SA模型： 定义初温、低温阈值并通过随机得到初始x，同时定义时刻t。通过均匀分布构造邻域函数，同时设定内循环次数为50次，降温函数使用$$T(t) = {T_0\\over{t+1}}$$代码实现如下： 12345678910111213141516171819202122232425262728T=1000 #initiate temperatureTmin=10 #minimum value of terperaturex=np.random.uniform(low=0,high=100)#initiate xk=50 #times of internal circulation y=0 #initiate resultt=0 #timewhile T&gt;=Tmin: for i in range(k): #calculate y y=aimFunction(x) #generate a new x in the neighboorhood of x by transform function xNew=x+np.random.uniform(low=-0.055,high=0.055)*T if (0&lt;=xNew and xNew&lt;=100): yNew=aimFunction(xNew) if yNew-y&lt;0: x=xNew else: #metropolis principle p=math.exp(-(yNew-y)/T) r=np.random.uniform(low=0,high=1) if r&lt;p: x=xNew t+=1 print(t) T=1000/(1+t) print (x)print(aimFunction(x)) 经过循环输出x与y，结果如下： ​ 48.45411386249023 -55082.24210065413 可以看到SA算法很好的逼近了最优解。 参考文章 模拟退火算法与python实现","categories":[{"name":"智能算法","slug":"智能算法","permalink":"https://albert-5.cn/categories/智能算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/tags/算法/"},{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://albert-5.cn/tags/模拟退火/"}]},{"title":"Leetcode","slug":"Leetcode","date":"2019-05-16T08:29:30.000Z","updated":"2019-05-16T08:31:51.397Z","comments":true,"path":"2019/05/16/Leetcode/","link":"","permalink":"https://albert-5.cn/2019/05/16/Leetcode/","excerpt":"","text":"领扣–引领新时尚 1、两数之和问题给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法1–暴力解法 思路： 给定一个数组和一个特定的目标值，对每一个数进行遍历，然后利用两层循环遍历的值进行if条件判断，如果相等，则返回下标；否则返回None. 具体实现： class Solution:def twoSum(self, nums,target): for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] == target: return [i, j] else: continue nums = [2,7,11,15]target = 9solution = Solution()print(solution.twoSum(nums,target)) 缺点：过于暴力，两层循环使得时间代价过高。 时间复杂度：O(n^2^) 解法2–较优化算法 思路： 相比于暴力解法，此法优化了双层循环 一次循环遍历，然后用目标值减去数组中的每一个值，然后判断减去得到的值是否在数组中，进而再判断小标问题； 具体实现： 1234567891011121314&gt; class Solution:&gt; def twoSum(self, nums, target):&gt; for i in range(0, len(nums)):&gt; a = target - nums[i]&gt; if a in nums:&gt; b = nums.index(a)&gt; if b != i:&gt; return [i, b]&gt; &gt; nums = [2, 7, 11, 15]&gt; target = 9&gt; solution = Solution()&gt; print(solution.twoSum(nums, target))&gt; 解法3–优化算法 &lt;来源于网络，怪自己 :sweat:···&gt; 思路： 优解:创建一个字典，通过循环把 target - nums[x]作为键，x作为值存入字典，边存边检查当前正在处理的nums[x]是否存在于字典中，存在：返回字典中nums[x]的值，和当前正在使用的x的值。 具体实现： 1234567891011121314&gt; class Solution:&gt; def twoSum(self, nums, target):&gt; dic = &#123;&#125;&gt; for x in range(len(nums)):&gt; if target - nums[x] in dic:&gt; result = [dic[target - nums[x]], x]&gt; return result&gt; dic[nums[x]] = x&gt; &gt; nums = [2, 7, 11, 15]&gt; target = 9&gt; solution = Solution()&gt; print(solution.twoSum(nums, target))&gt; 2、回文数问题判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 解法1–较优化解法 思路： 将所给数字转化为字符串，因为回文数是具有对称性的，所以比较字符串的第一位和最后一位、第一次位和末尾次位 ······但是由于一位数以及负数和末尾为0的数的特殊性，应该加以判断。 由于对称性，所以考虑字符长度，奇偶数：通过模2判断只需要判断一般就可以了。 实现： 12345678910111213141516171819202122232425262728293031&gt; class Solution(object):&gt; &gt; def isPalindrome(self, x):&gt; n = str(x)&gt; print(n)&gt; m = len(n)&gt; count = 0&gt; if m == 1:&gt; return True&gt; elif n[0] == \"-\" or n[m-1] == '0':&gt; return False&gt; elif m % 2 == 0:&gt; for i in range(int(m/2)):&gt; if n[i] == n[m-1-i]:&gt; count += 1&gt; else:&gt; return False&gt; else:&gt; for i in range(int((m+1)/2)):&gt; if n[i] == n[m-1-i]:&gt; count += 1&gt; else:&gt; return False&gt; if count == int(m/2) or count == int((m+1)/2):&gt; return True&gt; &gt; &gt; X = 0&gt; solution = Solution()&gt; print(solution.isPalindrome(X))&gt; 时间复杂度为 O(n) 执行代码，运行时间108 ms","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://albert-5.cn/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/tags/算法/"},{"name":"两数之和","slug":"两数之和","permalink":"https://albert-5.cn/tags/两数之和/"},{"name":"回文数","slug":"回文数","permalink":"https://albert-5.cn/tags/回文数/"}]},{"title":"sublime配置有关问题","slug":"sublime配置有关问题","date":"2019-05-06T07:42:54.000Z","updated":"2019-05-06T07:46:34.288Z","comments":true,"path":"2019/05/06/sublime配置有关问题/","link":"","permalink":"https://albert-5.cn/2019/05/06/sublime配置有关问题/","excerpt":"","text":"Answer &amp;&amp; Question安装Package Control安装Package Control有两种方式，第一种方式为：在控制台中输入安装命令。调出控制的方式为：Ctrl+`。Sublime Text2和Sublime Text 3的命令如下： sublime text 2 1import urllib2,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation') sublime text 3 1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 这一种方法我试了，好像没有卵用，打开console时会出现错误—由于连接方在一段时间后没有正确答复或者连接的主机没有反应，连接尝试失败 So, 失败告终，唯能另寻别发 后来在网上找了大量文章，看了好多解决方法，但大多无用，因为那个官网是无法访问的，好像是因为ip6什么的问题，但是除了······*^注释1这样可以下载得到package control压缩包 万事大吉？？？想的可真多啊 ^-^ 下载之后在指定的preferences/browser packages进行拖放下载好且解压好的文件，之后看是否出现package setting，如果出现，Ctrl+shift+P，输入install package，你就会看到这个包 也就说明 You are ok 但是不可避免出现 there are no packagesa avaliable for installation的错误。 怎么办？？？？ 可愁死我了······· 找了资料发现是这个原因 在利用sublime进行插件下载时，sublime会调用channel_v3.json文件，点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default，可以看到该文件是放置在网络中进行读取的，而由于GFW的原因，导致无法读取该文件（但是竟然可以直接访问？？），这也就是导致插件无法下载的原因 所以只需要修改这个json文件即可 方法也有很多，这是我在知乎上看到的https://www.zhihu.com/question/26373122/answer/156739767 但是我没有成功，嘤嘤嘤，主要是因为json文件没法下载 后来找到了,给你 添加到本地文件夹，然后在点击Preferences-&gt;Package Setting-&gt;Package Control -&gt;Setting Default看到一个channels，后面的路径修改下就可以了 别慌！！ 记得试一下哦，老方法， Ctrl+shift+P，输入install package，你就可以开始玩耍啦~~ 学习之中遇到的问题就记录下来了，小白上路，若有问题可联系me^contact me,欢迎指正。","categories":[{"name":"sublime","slug":"sublime","permalink":"https://albert-5.cn/categories/sublime/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://albert-5.cn/tags/sublime/"},{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"}]},{"title":"摄影理论篇","slug":"摄影","date":"2019-05-03T03:00:03.000Z","updated":"2019-05-03T03:02:19.811Z","comments":true,"path":"2019/05/03/摄影/","link":"","permalink":"https://albert-5.cn/2019/05/03/摄影/","excerpt":"","text":"[TOC] 一、人像摄影1、概念所谓人像摄影，是指通过摄影的形式，在照 片上用鲜明突出的形象描绘和表现被摄者相 貌和神态的作品，它是被摄者的影像写真。 • 一幅优秀的人像摄影作品，是许多成功因 素的总和：神情、姿态、构图、照明、曝 光、制作均要达到较高的境界，它们是一 个总体的各组成部分。 • 不管是在现场中抓拍的还是在照相室里摆 拍的，不管是否带有情节，只要是以表现 被摄者具体的外貌和精神状态为主的照片， 都属于人像摄影的范畴。 • 人像摄影的景别，主要有以下几种： （1）特写 以表现被摄者的面部特征为 主要目的 （2）近景 它以表现人物的面部相貌为主 背景环境在画面中只占极少部分 （3）半身 以脸部面貌为主要表现对象以外 还常常包括手的动作。 （4）全身 使人物的形象与背景环境的特点 互相结合，都能得到适当的表现 • 拍摄方向大体上分作: • 正面人像 • 七分面人像 • 三分面人像 • 侧面人像 • 调子影响视觉和情感。人像摄影可以分作高调、低调、一股影调、软调、硬调五种 影调。 高调：画面的影调构成以亮调子为主，尽量避免或者少用暗调子。 人像照片的背景要明亮、干净、均匀，但最好又保留一点淡淡的层次，以便衬托出被摄者更亮的部位。 • 夜景人像 1）直接使用相机的夜景人像模式2）使用AV档，曝光组合主要以夜景的背景 为参考，第二张开启闪光灯，照亮人像， 难点在于前后用光均衡。 2、技巧人像焦段的选择 • 1)镜头焦段选择：28-180 毫米皆可以，但是 50-135毫米最常用。尤其推荐85mm定焦镜 头。• 2）光圈控制，适度虚化背景，突出人物主 体。F2.0-F5.6常用 拍摄人像小诀窍 • 1）相机的测光模式为点测，点测人像的脸 部，曝光增加0.5-1档，使得皮肤美白； • 2）相机有人像和美肌美肤模式请设置 • 3）化妆，服装，饰物非常重要； • 4）反光板或者外置闪光灯补光要常用，减 弱脸部阴暗，另外使得眼睛有眼神光； • 5）多和模特交流，减少她的紧张； • 6）尝试多种拍摄视角和运光方式，身体可 以尝试多种POSE； • 7）事先应该确定风格。 二、新闻摄影1、要求 1新闻摄影 : “新” :首先是个新字。应该是 新鲜事、新闻，别人不知道的、没见过的。 2纪实:反映真实的现场，让未能身临其境者 如同亲历。 3具备这两点后，新闻还要有社会价值。 2、新闻摄影5W  何时（when）；  何地(where)；  何人(who)；  何事(what)；  为何(why)。 瞬间成为永恒，成为历史的见证 不要细细追求技术完美，抓住瞬间才是关键 3、会场类相片 相机参数： 1.档位选择：首先考虑使用A档 若光线较差，使用A档则会出现曝光时间过长，照片模 糊，此时考虑换成M档，将快门速度设置在1/15至1/60 之间 2.光圈：合理，F2.8-F5.6拍摄人物，F8拍摄全 3.ISO感光度：灯光较亮—100-800 灯光一般—800-1600 灯光较暗—1600以上 4.白平衡：自动白平衡 日光灯 荧光灯 拍摄曝光和器材要求 会议拍摄曝光和器材要点：1）大功率外置闪光灯必备，最 好套好小型柔光罩；2）镜头折合后焦距24-105mm；3）充分利用会场内的现场光；4）ISO设置到 800-1600；5）控制光圈，使得闪光灯和现 场光平衡。 1.正面全景 2.近景特写 3.角落全景 4.台上全景 5.颁奖合 三、建筑、红外、LOMO、针孔摄影、延时摄影、超现实摄影1、建筑摄影1、要点• 建筑的形体（体现建筑空间的深度，感受到三维空间的真实世界，其表现在运用视觉透视和利用阴影来提高建筑的空间感）、轮廓（当建筑处在背光面时，光线从建筑的背面射来，在强光的烘托下，轮廓剪影成了建筑的主要视觉要素，而空间、质感、色彩等等其它要素统统都被隐没在阴影之中。）、线条、尺度比例、质感和色 彩是建筑摄影中视觉要素的主要成分。• 在大多数情况下，上述要素并不是以相同 的地位在画面上同时出现，特别是当摄影 师需要突出表现建筑的某一特征时更是如 此。在画面中需要重点突出那些视觉要素 取决于照片的用途，也取决于摄影师的创 作意图和创作风格。 • 点 线 面 立体空间是建筑摄影最主要观察的 2、失真方法普通135相机和镜头，站在地面拍摄，产生透视失真，图像有 汇聚效应，头小脚大。但是，大画幅或者技术相机通过，前镜头板的上升，完美解决该问题。 3、控制建筑透视失真方法 • 35mm相机及其透视调整镜头 • 目前尼康、佳能、徕卡、美能达等相机厂 均生产透视调整镜头，如佳能相机的TS-E 24mm、45mm和90mm透视调整镜头，徕卡 R系列相机的28mm透视调整镜头，美能达 相机的35mm透视调整镜头，尼康相机的 28mm、35mm 和 85mm透视调整镜头。 建筑摄影顾名思 义，其主要记录 和表现对象为各 种建筑以及由于 建筑物的存在而 产生的空间关系 和状态。 4、透视最初研究透视是 采取通过一块透明的平面去看景物的方法 ，将所见景物准确描画在这块平面上，即 成该景物的透视图。后遂将在平面画幅上 根据一定原理，用线条来显示物体的空间 位置、轮廓和投影的科学称为透视学 使用中等焦距镜头在一定距离上拍摄建筑标志性雕塑可以避免近距离拍摄是因透视加剧而 产生的比例失真，这时建筑、雕塑、人的比例关系更为客观 5、建筑摄影的6个使用拍摄建议 1、利用反射或倒影增加美 2、利用好几何线条 3、利用人工光源衬托 4、寻找兴趣点 5、俯视营造纵深感 6、HDR、移轴效果、全景拼接、鱼眼扭曲…… • 建筑摄影八要素：角度、光线、线条、云 彩、框架的运用、影子、景观、人物； • 视觉要素：形体、轮廓、线条、尺度比例 、质感、色彩…… 2、LOMO摄影 Lomo有了新含义，Lomo是Let Our lives be Magic and Open lomo是缩写形式，原英文是Let our life be magic and open（意即让我们的生活开放、 有魔力）。在相机里指简单、随意的风格 关于LOMO的十大原则 1.Take your Lomo every-where you go .走到哪儿,就把Lomo带到哪儿。 2.Use it anytime-day and night .Lomo不分昼夜。 3.Lomography is not an interference in your life, but a part of it.不用担心Lomo打扰 你的生活,它就是生活的一部分。 4.Shoot from the hip. 想拍哪儿就拍哪儿。 5.Approach the objects of your lomographic desireas close as possible.近点儿,再近 点儿。 6.Don’t think.什么都不用想。 7.Be fast.还要快。 8.You don’t have to know beforehand what you’ve captured on film. 不必了解你要拍 什么。 9.You don’t have to know beforehand what you’ve cap-tured on film…and afterward seither.更不必了解你拍到了什么。 10.Don’t worry about the rules.把以上的9条都忘掉。 3、红外摄影红外摄影是一种较为另类的拍摄方式，利 用红外感光设备与红外滤镜配合，有别于 传统的黑白彩色照片，拍出的画面给人以 强烈的震撼让人爱不释手；同时红外线相 对可见光对一些材料及衣料具有穿透能力 （薄化纤、烟雾、水气…），能拍出神奇的 透视效果 红外摄影技术的获得 • 1）将价格很低的数码相机CMOS或者CCD传 感器前的低通滤镜拆除，镜头前加红外滤 镜。改造后只能用于红外摄影。 1.改装F828作为红外相机是极为正确 1.28-200mm简直是红外版的一镜走天下，何况还有2.0-2.8的大光圈！ 2.EVF让你时刻都能观察不一样的红外世界（单反相机怎么改也不行，光学取 景器就是光学取景器），而且F828除了EVF外还有个液晶屏也能取景（废话）， EVF和液晶屏能随机背一起进行上下旋转，极大扩展了构图的可能性！ 3.不像单反相机是对焦和感光元件相互分离的设计，F828的感光元件即对焦 元件，因此改成红外机后没有跑焦问题！4.镜头前是58mm螺纹，不需拆机即可随意更换各种波段的红外滤镜！（改红 外的单反这条最悲剧）5.在液晶屏中实时电子测光，红外线下曝光准确，所拍即所见！ • 2）不破坏现有相机的功能，镜头前直接加 红外滤镜。 • 1. 喜欢浓烈色彩的, 可以选择630nm 或者更低波长的590滤镜, 自定义 白平衡后, 原片一般天空呈亮红偏棕色,或者说是琥珀色, 植物树叶呈蓝 色. 红蓝通道调换后(后文有说明)天空蓝色饱和度高, 树叶黄色或者金 黄色.• 2. 喜欢适中的, 可以选择680, 原片天空呈棕红色, 树叶浅蓝, 通道调换 后天空比较接近正常天空的蓝色, 树叶呈浅黄色.• 3. 喜欢较为纯正红外但又希望带有色彩的, 可以选择720滤镜, 原片天 空呈暗棕红色, 饱和度较低, 树叶白, 通道调换后天空暗浅蓝色, 树叶白. 760滤镜理论上来说有是有颜色的,实际颜色很浅, 几乎是黑白的.• 4. 喜欢纯红外的可以选择850nm滤镜, 无色彩, 天气好时, 天空深暗, 可以得到反差较高的图片, 对于雾霾有更好的穿透力. 4、针孔摄影• 1）利用小孔成像的原理，抛弃我们已经使 用习惯的光学镜头；• 2）可以得到四周有暗角的、中心稍微清晰 的图像；• 3）一般来说，针孔的透视关系和广角镜头 接近； 特点 • 模糊、变形、色彩诡异的影像• 拍摄风景也有朦胧美感• 具有超现实主义的图像风格 针孔摄影实现的方法• 1）购买专门的针孔相机，一般使用胶卷• 2）利用数码单反改造 5、延时摄影延时摄影是以一种较低的帧率拍下图像或者视频，然后用正常或者较快的速率播放画面的摄影技术 方法• 1）相机没有内置延时摄影的，按照间隔时 间逐张拍摄，可用电子定时快门自动触发 ，后期软件合成；• 2）直接使用相机内置延时摄影APP，例如 sony相机，设置好参数，主要是间隔时间和 总时长。 拍摄时间间隔参考• 1)在拍摄城市白天的车流和行人时，间隔时 间设置为 1秒，拍摄间隔小于1秒 • 2)在拍摄城市夜晚的车流时，间隔时间设置 为2秒到5秒之间，机身设置快门速度为间 隔时间减1秒。 • 3)在拍摄天空云层运动时，依云层运动速度 ，设置间隔时间为3秒到10秒不等，云层运 动速度越慢，间隔时间最越长。 延时摄影的分类• 1）固定场景延时摄影，相机固定不动，拍 摄内容部分移动；• 2）移轴延时摄影，相机适当缓慢匀速移动 ，同时拍摄内容部分运动，比1显得丰富有 趣。 四、纪实摄影摄影从诞生之日开始就赋予了“真实记录” 的使命 现代公认的摄影术的诞生是1893年，法国人画家 达盖尔银版摄影技术正式问世 把真实的瞬间保留下来，是摄影对历史记录的伟大贡献 摄影的最主要的美学特征也 是他的纪实性。 艺术摄影：所谓艺术摄影就是最大限度的 使用视觉形式和各种摄影手段，表达摄影 师的艺术思想和哲学理念。他不受真实性 的影响，不受摄影手段的限制，也不受时 间和空间的制约。 艺术摄影和纪实摄影是否真实这点上区别 很大 纪实性摄影：所谓纪实性摄影就是对任何真实事件、场景、物体的现实现场的记录。 纪实摄影归类为两个方面:1）关于自然和物;2）关于社会与人。 决定性瞬间是纪实摄影的根本 环境的决定性瞬间 前景的决定性瞬间， 背景的决定性瞬间， 光影的决定性瞬间所组成。 人物的决定性瞬间 神态的决定性瞬间， 交流决定性瞬间， 运动决定性瞬间所组成。 纪实摄影的拍摄方法纪实摄影不是艺术，画面的美和光影 的斑斓不是他的追求目标。 他的意义在于 是否真实的记录了历史，纪实摄影作品的好坏有 它自己的标准  照片所承载的信息要准确。就是使读者一看就明 白，照片说的是什么意思。表达的是什么观点和 立场。 纪实摄影的拍摄原则就是；真实的记录，不对正在发生的事件做任何干涉和影响。使事件按照自己的发展规律发展，不论事件是好是坏。 构图原则 1）照片所表现的事件真实而有现场感 短焦距镜头的使用，使得能较好的 保证现场感的体现 利用标准镜头的透视关系和视角最接近 人类的眼睛，所拍摄的作品符合人们的习 惯 28-50mm之间的焦距，比较符合纪实 摄影的要求 2）构图的形式要适合视觉的习惯 3）视觉中心构图，就是把主体安放在视觉中 心的位置上，利于读者注意画面主体，明确主 体，清楚事件的主体是在什么环境下运作的。 纪实摄影的拍摄方法 1）守株待兔法： 2）声东击西法 3）掩护法： 4）突然袭击法 5）逼迫法： 6）盲拍法 7）最合理的做法是，和被拍摄对 象沟通聊天，乃至和他一起生活 很长时间，深入了解他并记录他 适当 提高ISO，ISO400-1600，ISO自动最 合理了。光圈适当缩小，F2.8、 F4 快门 保持高速。 拍摄经验 1）置于AV光圈优先档；  2）光圈 F2.0-F4.0（35mm-50mm镜头）；  3）矩阵测光，80%的照片能够合适曝光。只要 不过曝光，后期可以处理；  4）ISO随时设置，注意快门是否低于安全快门 速度（镜头焦距的倒数），尽量不低于1/125S. 如果图简单，ISO设置成AUTO  5）触摸屏相机极大的优势，对焦点所摸所得。  6）看准时机，连拍多张。 纪实摄影三个关键点 1）寻求题材：关注普通人的生活，但是关 注的题材带有社会的共性。对社会现象记 录和深度发掘； 2）观察：带着探究本质的精神去观察现象 3）思考：深入题材，独特的现象记录，思 考所记录的表现和题材背后的内在本质联 系·。 纪实摄影前期选题思考  1）人文纪实的最大的难题不是如何拍，而是拍什 么？  2）宏观观察社会，微观记录。从社会具体现象来 表达社会特征；  3)走出猎奇误区，不要觉得拍摄一些旅游中不常见 的少数民族生活就肯定是好作品，拍摄你最熟悉的 生活；  4）唯美误区，形式至上的误区；  5）影赛的误区，那是极大的误导；  6）突出时代，远离抽象，眼下习以为常的现象十 年后说不定觉得好有趣味好有意义；","categories":[{"name":"摄影","slug":"摄影","permalink":"https://albert-5.cn/categories/摄影/"}],"tags":[{"name":"人像摄影","slug":"人像摄影","permalink":"https://albert-5.cn/tags/人像摄影/"},{"name":"LOMO摄影","slug":"LOMO摄影","permalink":"https://albert-5.cn/tags/LOMO摄影/"},{"name":"红外摄影","slug":"红外摄影","permalink":"https://albert-5.cn/tags/红外摄影/"},{"name":"延时摄影","slug":"延时摄影","permalink":"https://albert-5.cn/tags/延时摄影/"}]},{"title":"toefl & ielts","slug":"toefl-ielts","date":"2019-04-28T03:50:51.000Z","updated":"2019-04-29T08:04:49.557Z","comments":true,"path":"2019/04/28/toefl-ielts/","link":"","permalink":"https://albert-5.cn/2019/04/28/toefl-ielts/","excerpt":"","text":"TOEFL托福是美国教育考试中心开发出来的给非英语国家学生的英语水平测试 1、认可国 北美国家（特别是美国）包括日本对托福成绩的接受度较高； 英联邦国家（英国、荷兰、加拿大、澳大利亚、新西兰、瑞士等）更接受甚至只接受托福成绩； 2、考试形式雅思和托福的考试内容也不相同，虽然都是对“听说读写”四种英语能力的测试，但是雅思更加注重生活应用，词汇量没有托福要求的那么多；而托福更加注重学术方面，对专业性的要求更高一点 托福是纯机考，也就是说不管是听力、阅读还是写作，甚至口语都是对着一台电脑，以“人机”的方式进行考核的。 3、分数分配托福是四项单项各30分，总计120分，最后几项分数加起来为总成绩；考试时间大概在4个小时左右，可能会有加试的情况； 其中，托福成绩在100分以上是不错的分数 有限期为两年 4、考试费用 项目 金额 托福网考考试费 1985 逾期报名附加费 310 转考费 620 恢复已取消的成绩 154 成绩赠送费（每份） 146 口语或写作单项复议 615 口语和写作双项复议 1229 托福复习套餐Prem(不包含考试费) 1086 托福复习套餐prep 395 折扣报名费 1716 考费差额 1 44 考费差额 2 224 考费差额 3 1104.5 IELTS1、认可国雅思是英国大使馆文化教育处来出题的 相对的英国目前大部分高校只认可雅思成绩 2、考试形式 雅思则是笔试 +面试的形式，口语环节是面对面直接和考官交流的，分数的弹性相对更大一点。对于喜欢交流的人而言考雅思更能会更加有利。 3、分数分配雅思的四项单项都是九分满分制，最后以四项平均分定为最终分数，一般情况下，雅思在7分以上是不错的成绩 有效期为两年","categories":[{"name":"English","slug":"English","permalink":"https://albert-5.cn/categories/English/"}],"tags":[{"name":"toefl","slug":"toefl","permalink":"https://albert-5.cn/tags/toefl/"},{"name":"ielts","slug":"ielts","permalink":"https://albert-5.cn/tags/ielts/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-22T15:42:22.451Z","updated":"2019-04-29T08:18:51.226Z","comments":true,"path":"2019/04/22/hello-world/","link":"","permalink":"https://albert-5.cn/2019/04/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://albert-5.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://albert-5.cn/tags/hexo/"}]},{"title":"sort_algorithm","slug":"sort-algorithm","date":"2019-03-28T09:47:54.000Z","updated":"2019-04-29T09:49:32.228Z","comments":true,"path":"2019/03/28/sort-algorithm/","link":"","permalink":"https://albert-5.cn/2019/03/28/sort-algorithm/","excerpt":"","text":"一、概念排序算法是一种能将一串数据按照特定顺序进行排列的一种算法 稳定性: 稳定排序算法会让原本有相等数值的记录维持相对顺序，也就说当有两个相等的数据A，B时，且原本A在B的前面，则在排序后A仍然是在B的前面，这就是稳定性的概念； 二、冒泡排序1、啥子叫冒泡排序 它是一种较为简单的排序算法，具体过程就是遍历所要排序的数列，每一次比较两个数，如果他们顺序错误则交换顺序，直至所有的数据交换完毕，也就是完成了数列的排序；由于在交换过程中，最小的元素会处于顶端的位置，所以叫做冒泡排序 。 2、过程分析 在实现冒泡排序的过程中，每次循环之后，数列中最大的元素移动到了最末端，然后在进行下一次的循环遍历，选出次大的元素，继续循环，直至排完序，则最小的处在顶端的位置 3、实现12345678910111213141516171819202122def bubble_sort(alist): for j in range(len(alist)-1): for i in range(0，len(alist)-1-j): # 操作下标而不是直接作用于元素上 if alist[i] &gt; alist[i+1]: alist[i],alist[i+1] = alist[i+1],alist[i] # 优化情况def bubble_sort(alist): for j in range(len(alist)-1): count = 0 # 记录交换的次数 for i in range(0,len(alist)-1-j): if alist[i] &gt; alist[i+1]: alist[i],alist[i+1] = alist[i+1],alist[i] count += 1 if count is 0: # 如果count为0，则说明没有进行交换 break if __name__ == \"__main__\": li = [1,2,6,4,12,9] bubble_sort(li) print(li) 说明： 最优时间复杂度为O(n) &lt;遍历一遍发现全都排好了&gt; 最坏时间复杂度为O(n^2) 稳定 三、选择排序1、思想一组数据相当于分成了两个部分，后一部分是待排数列，初始默认第一个元素是最小值，然后从这些待排的数列中进行遍历找到最小值并记录下标位置，然后与记录的初始最小值比较，如果找到的小于初始值则进行交换，然后继续遍历；也就是说,整个过程就是在找最小值。 2、实现123456789def select_sort(alist): '''选择排序''' n = len(alist) for j in range(n-1): min_index = j for i in range(j+1,n-1): if alist[min_index] &gt; alist[i]: min_index = i alist[j], alist[min_index] = alist[min_index], alist[j] 时间复杂度：O(n^2) 稳定性：简单的考虑这种情况，在一个乱序的列表中[11,23,12,23,6],排序时第一个23较大，则在排序时会由于交换而移动到最后面，则在排列第二个23时，因为它不比第一个23大，所以不变化，由此可见，二者交换了顺序，稳定性就是不稳定 四、插入排序1、思想通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 2、实现12345678910111213def insert_sort(alist): '''插入排序''' n = len(alist) # j表示循环次数，也即是有多少个元素执行此过程 for j in range(1, n): i = j # i是表示从从待排序列中取出第一个，然后进行扫描比较 while i &gt; 0: if alist[i] &lt; alist[i-1]: alist[i], alist[i-1] = alist[i-1], alist[i] i -= 1 else: break 3、时间复杂度最优时间复杂度: O(n) &lt;数列已按照升序排列，这个时间复杂度仅仅是遍历的时间&gt; 最坏时间复杂度: O(n^2) 稳定性:稳定 五、希尔排序1、概念它是插入排序的一种，也称为缩小增量排序，是直接插入排序算法的一种更为高效的改进版；但是它是不稳定的。具体思想就是把数据按照下标的一定增量进行分组，然后对每一个组进行插入排序，随着增量的一步步减少，每一组包含的数据越多，当增量为1时，整个排序完成！ 2、实现12345678910111213def shell_sort(alist): n = len(alist) gap = n // 2 # 确定步长 while gap &gt;= 1: for j in range(gap,n): i = j while i &gt; 0: if alist[i] &lt; alist[i-gap]: alist[i],alist[i-gap] = alist[i-gap],alist[i] i -= gap else: break gap //= 2 最优时间复杂度: 无法确定 最坏时间复杂度: O(n) 稳定性: 不稳定 六、快速排序1、思想 先从给定数列中取出一个基准数据值，记为x 排序过程中，小于x的数据全放在左边，大于x的数据全放在其右边 然后再次重复上述步骤即可 2、实现123456789101112131415161718192021def quick_sort(alist,first,last): if first &gt;= last: return mid_value = alist[0] low = first high = last while low &lt; high: # high左移 while low &lt; high and alist[high] &gt;= mid_value: high -= 1 alist[low] = alist[high] # low右移，在判断里面进行移动low的值以防它移动过度 while low &lt; high and alist[low] &lt; mid_value: low += 1 alist[high] = alist[low] alist[low] = mid_value # 此时low的位置就是初始的那个值 # 递归使用函数本身，快排左边 quick_sort(alist,first,low-1) # 递归快排右边 quick_sort(aliist,low+1,last) 最优时间复杂度： O(n*logn) 最坏时间复杂度： O(n^2) # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项 稳定性：不稳定 七、归并算法1、思想 &nbsp;&nbsp;分而治之，就是将一组待排序列向下均分、均分、均分······直至每一个小分组中只有一个元素，然后向上走进行合并操作，以致达到排序的目的 2、实现1234567891011121314151617181920212223def merge_sort(alist): '''归并排序''' # 分而治之，先进行分的操作 n = len(alist) if n &lt;= 1: return alist mid = n/2 # 分的结果为两个新的列表left 和 right;以下是递归操作 left = merge_sort(alist[:mid]) right = merge_sort(alist[mid+1:]) left_pointer, right_pointer = 0,0 result = [] while left[left_pointer] &lt; len(left) and right[right_pointer] &lt; len(right): if left[left_pointer] &lt;= right[right_pointer]: result.append(left[left_pointe]) left_pointer += 1 else: result.append(right[right_pointer]) right_pointer += 1 result += left[left_pointer:] result += right[right_pointer:] return result#----------------------------------------------------------- 最优时间复杂度：O(n*logn) 最坏时间复杂度：O(n*logn) # 这种情况下就是每次再分的时候都只能分为总是第一项和剩余项 稳定性：稳定","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://albert-5.cn/tags/排序算法/"},{"name":"插入排序","slug":"插入排序","permalink":"https://albert-5.cn/tags/插入排序/"},{"name":"归并排序","slug":"归并排序","permalink":"https://albert-5.cn/tags/归并排序/"},{"name":"快速排序","slug":"快速排序","permalink":"https://albert-5.cn/tags/快速排序/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2019-03-25T09:54:05.000Z","updated":"2019-04-29T09:56:46.195Z","comments":true,"path":"2019/03/25/栈和队列/","link":"","permalink":"https://albert-5.cn/2019/03/25/栈和队列/","excerpt":"","text":"一、python递归函数深度限制python使用递归函数会受到递归深度的限制，大概是900多点(因为100次的时候就会报错：maximum recursion depth exceeded in comparison)，嘿嘿嘿 解决方法 导入python中 sys模块，import sys 然后使用 sys 下的 setrecursionlimit去重新规定它的限制 **ps:但是要注意一点设置Python解释器堆栈的最大深度以限制。此限制可防止无限递归导致C堆栈溢出并导致Python崩溃。 最高可能的限制取决于平台。当用户需要深度递归的程序和支持更高限制的平台时，用户可能需要设置更高的限制。这应该小心，因为太高的限制可能导致崩溃 二、栈stack1、栈的操作**· stack()创建一个空栈 · push()添加一个新的元素item到栈顶 · pop()弹出栈顶元素 · peek()返回栈顶元素 · is_empty()判断栈是否为空 · size()返回栈的元素个数** 2、栈的代码实现123456789101112131415161718192021222324252627282930class Stack(object): '''栈''' def __init__(self): self.__list = [] # 建立私有容器 def push(self,item): ''添加一个新的元素到栈顶'' self.__list.append(item) # self.__list.insert(0,item) 在栈顶插入时复杂度为n,相反在尾部时复杂度就为1 def pop(self): '''弹出栈顶元素''' self.__list.pop() # self.__list.pop(0) return def peek(): '''返回栈顶元素''' if self.__list: return self.__list[-1] else: None def is_empty(self): '''判断栈是否为空''' return not self.__list def size(self): '''返回栈中元素的个数''' return len(self.__list if __name__ == \"__main__\": s = Stack() 三、队列queue1、只允许在一端进行插入操作，另一端进行删除操作的线性表2、队列的实现· queue()创建一个空的队列 · enqueue(item)添加一个新的元素item到队列中 · dequeue()从队头删除一个元素 · is_empty()判断队列是否为空 · size()返回队列中的元素个数 1234567891011121314151617181920212223class Queue(object): '''队列''' def __init__(self)： self.__list = [] def enqueue(self,item): '''往队列中添加一个item元素''' self.__list.append(item) # self.__list.insert(0,item) # 无论选择哪个总有一个的复杂度是O(1)，另一个是O(n)，具体选择根据自己功能哪个用的多 def dequeue(self): '''从队列中删除一个元素''' return self.__list.pop() def is_empty(self): '''判断一个队列是否为空''' return self.__list == [] def size(self): '''返回队列的大小''' return len(self.__list) if __init__ == \"__main__\": s = Queue() s.enqueue(1) s.enqueue(2) 四、双端队列**· deque创建一个空的双端队列 · add_front(item)从队头加入一个item元素 · add_rear(item)从队尾加入一个item元素 · remove_front()从队头删除一个item元素 · remove_rear()从队尾删除一个item元素 · is_empty()判断双端队列是否为空 · size()返回双端队列的大小** 123456789101112131415161718192021class Deque(object): '''双端队列''' def __init__(self)： self.__list = [] def add_front(self,item): '''往双端队列的头部添加一个item元素''' self.__list.insert(0,item) def add_rear(self): self.__list.append(item) def pop_front(self): '''从双端队列的头部删除一个元素''' return self.__list.pop(0) def pop_rear(self): '''从双端队列的尾部取出元素''' return self.__list.pop() def is_empty(self): '''判断一个双端队列是否为空''' return self.__list == [] def size(self): '''返回双端队列的大小''' return len(self.__list) 五、链表1、单向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Node(object): '''节点''' def __init__(self,elem): self.elem = elem self.next = None # 同样可以利用python的二元组进行操作(elem) class Single_LinkList(object): '''单链表''' def __init__(self,node=None): # 就是一个内部的使用，规定一个头结点，而且这个头结点应该是私有的，因为在封装后的SingleLinkList对象中，外部能够调用的就是以下的几个函数，其他的是无法使用的，所以私有化处理了，纯粹是自己的内部函数去使用； self.__head = node def is_empty(self): '''判断链表是否为空''' return self.__head = None def length(self): '''链表长度''' # cur游标，用来移动遍历节点 cur = self.__head # count 记录数量 count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): '''链表遍历''' cur = self.__head while cur != None: print(cur.elem) cur = cur.next print(\"\\n\") def add(self,item): '''链表头部添加元素,头插法''' node = Node(item) node.next = self.__head.next self.__head = node def append(self,item): # 这里的item仅仅是数据元素，而不是节点 '''链表尾部添加元素，尾插法''' node = Node(item) if self.is_empty(): # 判断链表是否为空 self.__head = node else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node def insert(self,pos,item): # 在任意位置添加元素，pos表示需要添加元素的位置，item表示要添加的数据 '''在某个位置插入元素''' if pos &lt;= 0: self.add(item) elif pos &gt; (self.length-1): self.append(item) else: pre = self.__head # pre的用法和cur一样 count = 0 while count &lt; pos-1: count += 1 pre = pre.next node = Node(item) node.next = pre.next pre.next = node def remove(self,item): '''删除节点''' cur = self.__head pre = None while cur != item: if cur.elem == item: # 要判断此节点是不是头节点 if cur == self.__head: self.__head = cur.next break else: pre.next = cur.next break else: pre = cur cur = cur.next def search(self,item): '''查找节点是否存在''' cur = self.__head while cur is not None: if cur.elem == item: return True else: cur = cur.next return False 链表和顺序表的比较 操作 链表 顺序表 访问元素 O(1) O(1) 头部插入 or 删除元素 O(1) O(n) 尾部插入 or 删除元素 O(n) O(1) 在中间插入 or 删除元素 O(n) O(n) 六、双向链表1、操作**· is_empty()链表是否为空 · length()链表长度 · travel()遍历整个链表 · add(item)链表头部添加信息 · append(item)链表尾部添加信息 · insert(pos, item)在特定位置添加元素 · remove(item)删除节点 · search(item)查找节点是否存在** 2、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Node(object): '''节点''' def __init__(self,item): self.elem = item self.next = None self.prev = Noneclass DoubleLinkList(object): '''双链表''' def __init__(self,node=None): self.__head = node def is_empty(self): '''判断双链表是否为空''' return self.__head is None def length(self): '''双链表长度''' cur = self.__head count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): '''遍历双链表''' cur = self.__head while cur != None: print(cur.elem) cur = cur.next print(\"\\n\") def add(self,item): '''头部添加元素''' node = Node(item) node.next = self.__head.next self.__head = node node.next.prev = node def append(self,item): '''双链表的尾部添加元素''' node = Node(item) if self.is_empty(): self.__head = node else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node node.prev = cur def insert(self,pos,item): '''在双向链表的某个位置插入元素''' if pos &lt;= 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: cur = self.__head count = 0 while count &lt; pos: count += 1 cur = cur.next # 退出循环之后，cur指向pos位置 node = Node(item) node.next = cur node.prev = cur.prev cur.prev = node cur.prev.next = node def remove(self,item): '''删除节点''' # cur 游标指向头结点的时候，pre指向空，相差一个单位的距离 cur = self.__head pre = None while cur != None: if cur.elem is item: # 判断当前游标cur指向是不是在1处 if cur is self.__head: self.__head = cur.next # 判断cur.next是否为空，因为空的元素是没有prev的 if cur.next: cur.next.prev = None else: cur.prev.next = cur.next if cur.next: cur.next.prev = cur.prev break else: cur = cur.next def serch(self,item): '''查找节点''' cur = self.__head whilt cur != None: if cur.elem is item: return True else: cur = cur.next return False","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"https://albert-5.cn/categories/算法/数据结构/"},{"name":"python","slug":"算法/数据结构/python","permalink":"https://albert-5.cn/categories/算法/数据结构/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://albert-5.cn/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"https://albert-5.cn/tags/栈/"},{"name":"队列","slug":"队列","permalink":"https://albert-5.cn/tags/队列/"},{"name":"链表","slug":"链表","permalink":"https://albert-5.cn/tags/链表/"}]},{"title":"查找算法","slug":"查找算法","date":"2019-03-20T09:56:30.000Z","updated":"2019-04-29T09:58:07.060Z","comments":true,"path":"2019/03/20/查找算法/","link":"","permalink":"https://albert-5.cn/2019/03/20/查找算法/","excerpt":"","text":"一、二分查找1、思想二分查找又被称为折半查找，优点就是比较次数少，查找速度快，平均性能好，但其缺点是要求待查表为有序表，假设表中的元素是按照升序排列的，将表中间位置记录的关键字与查找的关键字作比较，如果两者相等，则查找成功；否者就利用中间位置记录分为前、后两个子表，如果中间位置的关键字大于查找关键字，则进一步查找前一个子表，否者就查找后一个子表，然后重复即可 2、实现123456789101112def binary_search(alist,item): '''二分查找''' n = len(alist) if n &gt; 0: mid = n/2 if alist[mid] == item: return True elif item &lt; alist[mid]: binary_search(alist[:mid],item) else: binary_search(alist[mid+1:],item) return False 3、时间复杂度问题 关于时间复杂度的问题，首先讨论最坏的情况，就是进行到最后一步才找到元素item，在这种情况下因为是二分查找法，每次都是对半的，所以一共有O(log n) 最优时间复杂度：O(1) 二、树1、概念 它是另外一种数据结构，但元素之间的关系并不是线性结构，而是一种更为复杂的结构；但是它有以下特征： 1、如果他的结构不为空，则其中就存在着唯一的起始节点，称之为树根root；2、每个节点有零个或多个子节点；3、没有父节点的节点成为根节点；4、每一个非根节点有且只有一个父节点；5、除了根节点之外，每个子节点可以分为多个不相交的子树······ 2、常用术语名称 节点的度：一个节点含有的子树的个数称为该节点的度 树的度：一棵树中，最大的节点的度 叶子节点或终节点：度为零的节点 父节点：若一个节点含有子节点，则这个节点就称为该子节点的父节点 节点的层次：从根节点开始定义起，根为第一层，根的子节点为第二层，以此类推······ 树的高度或深度：树中节点的最大层次 3、树的分类 无序树：树中任意节点的子节点之间没有顺序关系，也叫做自由树 有序树：树中任意节点的子节点之间有顺序关系 二叉树：每个节点最多含有两个子树的树 完全二叉树：对于一颗二叉树，假设其深度为d，除了第d层外，其他各层的节点数目均已经达到最大值，且第d层所有节点从左向右连续的紧密排列；==满二叉树==的定义是所有叶节点都在最底层的完全二叉树; 平衡二叉树&lt;AVL树&gt;：当且仅当任何节点的两棵子树得到高度差不超过2的二叉树 排序二叉树（二叉查找树，binary search tree）：也称为二叉搜索树、有序二叉树 ![20190330](C:/Users/DELL/Desktop/markdown%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/20190330.jpg) ​ 霍夫曼树：用于信息编码，待权路径最短的二叉树称为哈夫曼树或者是最优二叉树 B树：一种对读写操作进行优化的自平衡的二叉查找树，能够爆出数据有序，拥有多余两个子树； 树的应用场景 1、xml、html等标签的关系 2、路由协议运用了树的算法 3、mysql数据库索引 4、文件系统的目录结构 5、AI算法，机器学习中的 decision tree等 三、二叉树1、性质 在二叉树的第i层最多有2 ^i-1^ 个节点 深度为k的二叉树最多有(2 ^k^ -1)个节点 对于任意一颗二叉树，如果叶子节点数为N ~0~ ，而度数为2的节点的总数为N ~2~ ，则有N ~0~ = N ~2~ + 1； 2、实现1234567891011121314151617181920212223242526272829303132class Node(object): '''构造节点''' def __init__(self,item): '''构造左右孩子''' self.elem = item self.lchild = None self.rchild = Noneclass Tree(object): '''二叉树''' def __init__(self): self.root = None def add(self,item): node = Node(item) queue = [self.root] if self.root is None: self.root = node return # 判断队列是否为空 while queue: # 取出当前节点 cur_node = queue.pop() # 判断当前节点的左右子树是否为空 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) if cur_node.right is None: cur_node.rchild = node return else: queue.append(cur_node.right) 四、广度遍历1、思想这种遍历方法就是按照路径长度由远及近地访问节点，也即是说按照二叉树的层次遍历访问层中的每一个节点；==这种遍历无法使用递归==；在这种宽度优先遍历中，只规定了逐层访问，并没有规同一层的节点访问顺序，但从算法的角度上，必须规定一个顺序，常见的是在每一层里都从左往右逐个访问；==实现这一算法是用队列作为缓存;== 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node(object): '''构造节点''' def __init__(self,item): '''构造左右孩子''' self.elem = item self.lchild = None self.rchild = Noneclass Tree(object): '''二叉树''' def __init__(self): self.root = None def add(self,item): node = Node(item) queue = [self.root] if self.root is None: self.root = node return # 判断队列是否为空 while queue: # 取出当前节点 cur_node = queue.pop(0) # 判断当前节点的左右子树是否为空 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) if cur_node.right is None: cur_node.rchild = node return else: queue.append(cur_node.right) def breath_travel(self): '''广度优先遍历''' if self.root is None: return queue = [self.root] while queue: cur_node = queue.pop(0) print(cur_node.elem) if cur_node.lchild is not None: queue.append(cur_node.lchild) if cur_node.rchild is not None: queue.append.rchild(cur_node.rchild) 五、深度优先遍历1、思想深度优先遍历不同于广度优先遍历，其遍历有三种不同的方式: 先序遍历[^脚注1]，中序遍历[^脚注2]，后序遍历[^脚注3] 2、实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(object): '''构造节点''' def __init__(self,item): '''构造左右孩子''' self.elem = item self.lchild = None self.rchild = Noneclass Tree(object): '''二叉树''' def __init__(self): self.root = None def add(self,item): node = Node(item) queue = [self.root] if self.root is None: self.root = node return # 判断队列是否为空 while queue: # 取出当前节点 cur_node = queue.pop(0) # 判断当前节点的左右子树是否为空 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) if cur_node.right is None: cur_node.rchild = node return else: queue.append(cur_node.right) def breath_travel(self): '''广度优先遍历''' if self.root is None: return queue = [self.root] while queue: cur_node = queue.pop(0) print(cur_node.elem) if cur_node.lchild is not None: queue.append(cur_node.lchild) if cur_node.rchild is not None: queue.append.rchild(cur_node.rchild) def preorder(self,node): '''先序遍历''' # 判断节点是否为空 if node is None: return print(node.elem) # 打印根节点 self.preorder(node.lchild) # 递归打印左子树 self.preorder(node.rchild) # 递归打印右子树 def inorder(self,node): '''中序遍历''' # 判断节点是否为空 if node is None: return self.inorder(node.lchild) # 递归打印左子树 print(node.elem) # 打印根节点 self.inorder(node.rchild) # 递归打印右子树 def postorder(self,node): '''后序遍历''' # 判断节点是否为空 if node is None: return self.postorder(node.lchild) # 递归打印左子树 self.postorder(node.rchild) # 递归打印右子树 print(node.elem) # 打印根节点 六、哈夫曼树1、思想 设有实数集$$W = {w_0,w_1,w_2,\\cdots,w_{m-1}}$$T是一颗扩充二叉树，其 m 个外部节点分别为以 w ~i~ 为权，而且T的带权外部路径长度 WPL在所有这样的扩充二叉树中达到最小，则称 T 为数据集 W 的 最优二叉树或者是哈夫曼树 Click Here and Learn More 2、实现12345678910111213141516171819202122232425class BinTNode(): def __init__(self,item,leftchild=None, rightchild=None): self.elem = item self.leftchild = leftchild self.rightchild = rightchildclass HTNode(BinTNode): # 这里继承了BinTNode类，定义了一个专门为构建哈夫曼树的节点类，特点就是增加了一个小于的比较操作 def __lt__(self,othernodes): return self.elem &lt; othernode.elem # 这里定义了一个专门为哈夫曼算法服务的优先队列类，其中增加了一个检查队列中元素个数的操作class HuffmanPrioQ(PrioQueue): def number(self): return len(self._elems) def HuffmanTree(weights): tree = HuffmanPrioQ() for w in weights: tree.enqueue(HTNode(w)) while tree.number() &gt; 1: t1 = tree.dequeue() t2 = tree.dequeue() x = t1.elem + t2.elem tree.enqueue(HTNode(x,t1,t2)) return tree.dequeue 算法复杂度： 第一个循环构造了m颗二叉树，并把他们加入大序列中，按照上面的写法则时间复杂度为O(m log m)，因为加入一个元素需要O(log m)次筛选 第二个循环需要m-1次，每次减少一颗树。其中构造一颗新树的时间与m是无关的，是O(1)复杂度的操作。每次迭代需要把一颗新的树加入到优先队列，需要O(log m)复杂度的时间，整个循环就是O(m log m)时间； 3、树、森林、二叉树的关系实际上是一种一一对应的关系，可以把任何一个（有序）树林映射到一颗二叉树上，而其逆映射把这颗二叉树映射回原来的树林，映射关系如下： 顺序连接同一节点的各个子节点（它们原来在原树林里的兄弟节点），作为这些节点的右分支的边（也就是说，将树/森林中下一兄弟最为二叉树的右分支） 保留每个节点到其第一个子节点的连接作为该节点的左分支，并删去这个节点到它节点的其他子节点的连接（即是说原森林里第一个子节点作为二叉树里的左分支） [^脚注1]: 先序遍历方式：根 —&gt;左—&gt;右[^脚注2]: 中序遍历方式：左 —&gt;根—&gt;右 [^脚注3]: 后序遍历方式：左 —&gt;右—&gt;根","categories":[{"name":"算法","slug":"算法","permalink":"https://albert-5.cn/categories/算法/"},{"name":"python","slug":"算法/python","permalink":"https://albert-5.cn/categories/算法/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://albert-5.cn/tags/python/"},{"name":"查找算法","slug":"查找算法","permalink":"https://albert-5.cn/tags/查找算法/"},{"name":"数和森林","slug":"数和森林","permalink":"https://albert-5.cn/tags/数和森林/"}]},{"title":"英语学习","slug":"英语学习","date":"2019-03-01T16:20:48.000Z","updated":"2019-05-24T16:22:15.896Z","comments":true,"path":"2019/03/02/英语学习/","link":"","permalink":"https://albert-5.cn/2019/03/02/英语学习/","excerpt":"","text":"话题1 Directions: Suppose you are asked to give advice on whether to attend college at home or abroad, write an essay to state your opinion. You are required to write at least 150 words but no more than 200 words. 参考范文： Nowadays, there has been a heated discussion as to a better choice between attending college at home and abroad. Views on the topic vary greatly among people from different walks of life. Some believe that it is a better choice to study in domestic colleges, but others consider it better to study abroad. I totally agree with the latter idea for the reasons presented below. To begin with, it harms the society in that the greater the competition is, the higher the recruitment requirements willbecome. Therefore, with experiences of studying abroad, graduates will become more competitive in job hunting. Furthermore, it is beneficial to the students themselves to study abroad. Without the choice to pursue overseas study, many great scholars today would never have achieved such great success. From my perspective, it is crucial that the government should encourage people to pursue overseas study. Also it is crucial that people should understand the meaning and value of attending college abroad. Only in this way can we achieve greater success. 词汇学习： discussion[dɪˈskʌʃən]讨论，谈论 college[‘kɔlidʒ]大学;学院;学院的全体师生;社团 at home 在家;在国内 domestic[dəˈmɛstɪk]家庭的;热心家务的， 仆人，佣人 consider[kənˈsɪdə]考虑;考虑到;认为 话题2 英语六级作文话题：手机直播 Directions: For this part, you are allowed 30 minutes to write a short essay on mobile live video broadcasting. You are required to write at least 150 words but no more than 200 words. 参考范文： In recent years, mobile live video broadcasting has been very popular among young people. People can broadcast their daily life anytime at any place as they like as long as they have a smartphone. In my opinion, there are disadvantages as well as advantages of mobile live video broadcasting. On the one hand, mobile live video broadcasting enables people to show their talent online, which gives them a chance to earn money online. And it is also a good way to share their life experience with their friends and family. On the other hand, if people don’t use their time properly, they may become addicted to it. Particularly, if students spend too much time playing it, they may neglect their studies, which is not good for them. In conclusion, mobile live video broadcasting is a fashionable way to enrich people’s life. However, we should make best use of our time and keep ourselves from being addicted to it. 话题3英语六级作文话题：买房的重要性 参考范文： Importance of Buying a House There is a heated debate on the importance ofbuying a house with the soaring house prices. Those emphasizing the in^ortance of buyiog ahouse maintain that living in your bwn house makes you feel better and more comfortablecompared to that in a rented one. Besides, no investment is more rewarding than buying ahouse nowadays. Statistics from both home and abroad shows that owning a houseguarantees an increase in assets. Quite the contrary, many people say, buying a house is not that important. On one hand,a rented apartment can provide the same comfortable or even better life for people. This isespecially true when many people have no money to decorate their houses after the bigpurchase. On the other hand, peopk can spend more money on other more protitableinvestment than involving in real estate, such as buying stocks or other art poliections. Personally, I think possessing a house is extremely important. At its core, a house is ashelter After buying a house, people will becomc stable. What’s more important is that thctrchildren will also settle and can concentrate on study _ children could get affected as theyadapt themselves with the new places, teachers and creating new friends making them Lagbehind academically. 词汇学习： importance [ɪmˈpɔːtəns]重要;重要性;傲慢 comfortable[ˈkʌmftəbəl]舒适的，舒服的;自在的;安逸的;宽裕的 extremely[ɪkˈstriːmlɪ] 极端地，非常地，很 话题4英语六级作文话题：国学 参考范文： In recent years, Sinology, the study of Chinese traditional culture, literature, history, society etc, has become increasingly popular For instance, it is reported that many primary and secondary schools have set up courses of sinology, in which students are taught classical works by Chinese ancient educators and philosophers, like Confucius- Another good illustration is in the program CCTV Lecture Room famous scholars, e.g, Yu Dan, give lectures on Chinese ancient philosophies and literatures. Sinology becomes prevalent due to the fact that it is of vital significance for both the individuals and the society. For one thing, Sinology is the essence of Chinese civilization with more than 5,000 years. Thus, for individuals, they can enlarge their scope of knowledge, enrich their experience and adapt themselves to the complicated society. For another, it is acknowledged that the rehabilitation of Sinology can contribute to the establishment of a harmonious society. In my opinion, all Chinese people should inherit the merits of Sinology. To do so, we can read books by ourselves or to attend lectures on this issue. Besides, we have the gation to popularize introducing it to the world By doing so, we can not only inherit it but also make it glorious and prosperous. 词汇学习： For instance例如，比如; 拿 … 来说 it is reported据悉 真题 真题 1【题目】 Directions: Directions: For this part, you are allowed 30 minutes to write an essay commenting on the saying “Seek to understand others, and you will be understood.”You can cite examples to illustrate your views.You should write at least 150 words but no more than 200 words. 【参考范文】 There is a proverb going like this, “Seek to understand others, and you will be understood.” Simple as the saying is, its implication deserves exploring. From my perspective, the real sense of the proverb lies in mutual understanding. One of the reasons that mutual understanding is so vital is that it forms the basis of all friendships and relationships. Mutual understanding allows existing differences between two or more partied to be acknowledged, accepted and respected, so that common ground and a collective vision can be found. This is true regardless of whether the relationship is between individuals, businesses or even countries. For example, the US and British governments may not see eye to eye on every issue, but they have been able to put aside their differences and forge a friendship and alliance supported by their shared values. We may not fully agree with other people’s opinions or beliefs. However, by understanding the reasons behind their words and actions, we can learn to “disagree without being disagreeable”so that quarrels are averted. Therefore, for those who wish to build lasting relationships, prevent conflict with others, seeking and achieving mutual understanding with others is not only important, but essential. 真题2 2016年6月 【审题提纲】 这是一篇典型的议论文，主题是探讨虚拟世界与现实生活的关系。题目想告诉我们网络的虚拟人生无法取代真实的人生，甚至可能危害真实的人生。考生在行文时，可一方面强调网络所创造的虚拟世界所带来的好处，另一方面也可指出以网络为媒介的虚拟世界对真实人生的危害。 第一段：指出虚拟世界的现状，论述过程中可引用数据。 第二段：分析利弊，直陈得失，议论时可适当举例。 第三段：提出建议或措施。比如从年轻人自身或结合社会来给出建议。 【参考范文】 The Internet, as a platform of the virtual world, has aroused public attention these years. However, in a new Gallup poll, about 100 million Chinese cyber citizens are willing to chat with the other side of the net for several hours, but refuse to talk with their neighbors even for a moment. This deserves our consideration. Actually, this phenomenon is prevalent nowadays. There’s no denying that the Internet creates a cyberspace for people to evade the burden of the real world and find temporary relaxation. People can experience their own dream and enjoy heartily in the virtual world. For example, an increasing young adults could feel extremely proud of their upper ranks in online games. Nevertheless, it is clear that the more time one spends on surfing, the less time one does with his or her family and friends. If the situation continues, it will weaken one’s bonds with the real life. For instance, it would become difficult for them to fulfill necessary tasks and, more seriously, their individual development would be consequently hampered. As a result, addiction to the virtual world will render a person nothing in the real world. Obviously, appropriate measures need to be taken. For one thing, the youth should be educated to realize the importance of the real life. For another, their time on online and activities in real life should be balanced. 【写作模板】 (中心词), as（补充说明中心词）, has aroused public attention these years. However, in a new Gallup poll, a(数据说明). This deserves our consideration. Actually, this phenomenon is prevalent nowadays. There’s no denying that(毫无疑问的好处). People can (细节支持) in the virtual world. For example,(举例). Nevertheless, it is clear that(显而易见的弊端或危害). If the situation continues, it will weaken(细节支持). For instance,(举例一) and, more seriously, (举例二) .As a result, addiction to the virtual world will render(总结危害). Obviously, appropriate measures need to be taken. For one thing,(角度一). For another,(角度二). 真题3 2016年6月 【审题提纲】 这是一篇典型的议论文，主题是探讨在线学习与学校学习的关系。题目想告诉我们在线学习是无法取代学校学习的。考生行文时，一方面可强调在线学习所带来的好处，另一方面也需指出在线学习存在的弊端，同时论证学校学习是能改善这些弊端的最佳途径。 第一段：描述现状，说明自己的观点。 第二段：分析在线学习的利弊，同时指出学校学习可以弥补在线学习的不足。 第三段：指出自己的应对之策并结合学生身份，说明采取哪种学习方式不重要，最重要的是要更加有效地学习。 【参考范文】 With the growing of the world wide web, those luckily enough to learn by the net face the decision of e-learning and attending school. The choice is a difficult one as both ways of learning have advantage. Personally, I believe, although e-learning is obviously convenient, the benefits are often not significant and in many ways learning in this kind of way can limit one’s experience. Undoubtedly, the conveniences of e-learning include the fact that it easily breaks through the limitations of time and space and offers the update knowledge and lower learning cost. Additionally, it is a more advanced approach to access to essential and useful information. However, the disadvantage of e-learning is clear as well. It cannot allow the students to socialize; namely, it cannot help develop the necessary social skills needed to survive in today’s fast-pace world. Fortunately, this can be fulfilled by attending school. For example, many people meet their best friends while attending school. These friendships are deepened over spending hours and hours in the same classrooms together. Consequently, the bonds that are formed in classroom cannot be replaced by e-learning. In a word, when combined with other learning methods, such as face-to-face sessions, e-learning is most effective. That is to say, it is a good idea that we combine e-learning and attending school together. No matter what we choose, as college students, we should study more effectively. 【写作模板】 With the growing of the world wide web, those(某类和主题相关的人群) face the decision of (关键词1+关键词2). The choice is a difficult one as both ways of(关键词的类别) have advantage. Personally, I believe, although(关键词1) is obviously convenient, the benefits are often not significant and in many ways (局限性). Undoubtedly, the conveniences of(关键词1)include the fact that it(细节支持). Additionally, (细节支持). However, the disadvantage of (关键词1) is clear as well. It cannot(弊端); namely, it cannot(进一步解释弊端). Fortunately, this can be fulfilled by(关键词2). For example, (举例). Consequently, (小结). In a word, when(假设某种条件), such as(举例),(关键词1) is most effective. That is to say, it is a good idea that(进一步阐述我的观点). No matter what we choose, as college students, we should (结合自身举例，使文章立意升华). 真题4 2016年6月 【审题提纲】 本文是一篇非常典型的科技类话题作文。题目要求从机器人的使用出发，设想机器人的未来前景。考生可结合自身对机器人的认识，论述自己的观点。纵观六级考试这三套题目，考查的均是与科技相关的话题，这就说明与科技相关的话题始终是六级作文考查的重点。 第一段：引出文章话题，假设机器人对人类生活所做出的改变。 第二段：针对此现象阐述观点。 第三段：自己的看法。 【参考范文】 At the mention of the robots, many fiction films are rising before my eyes, such as AI(Artificial Intelligence). I would like to imagine what will happen when an increasing number of robots take the place of human beings in our life. How interesting the scene is—there’s a robot ready to help you, whether it is helping your mother with household chores or helping you copy the text. Clearly, the robots contribute to the progression of human beings’ society. For one thing, they liberate the labor force and promote the industrial efficiency. For another, they are engaged in some dangerous work, protecting mankind from the risks. However, sometimes the robots cause troubles. On the one hand, it will impair man’s innovation ability, if humanity completely depends on the robots for a long time. On the other hand, a single robot can wreck a lot, if robots are given awareness. Hence, if robots are to reach further, there are still much real challenge. As for me, robots will not take the place of human beings totally, although they would exceed the man in many aspects, such as power of work, operating rate and memory function. Nevertheless, because robots lack the capability of logical thinking and reasoning, it dooms that they can not solve the complicated problems as humans do. Therefore, robots cannot do better than human in many fields, let alone substituting humans. 【写作模板】 At the mention of the (关键词), (具体情况), such as(举例). I would like to imagine(题目主旨). How (与主题相关的形容词)the scene is— (细节支持). Clearly, the(关键词)contribute to the progression of human beings’ society. For one thing,(细节支持). For another,(细节支持). However, sometimes the(关键词) cause troubles. On the one hand,(细节支持). Hence, if (关键词) are to reach further, there are still much real challenge. As for me,(自己的看法), although they would(让步假设), such as(举例). Nevertheless, because(某种原因), it dooms that they can not (存在弊端). Therefore,(进一步总结). 真题5Equality of Education Opportunity 近年来出现一些教育不公平的现象 出现这些现象的原因和后果 为了改变这种状况，我认为…… 【范文】 Equality of Education Opportunity In recent years the problems which are causedby the inequality of education opportunity haveattracted the public’s attention. For instance, thebackward teaching facilities anddilapidated schoolbuildings in rural areas are in sharp contrast tothose advanced facilities and well-equippedclassrooms in urban areas, students from poor families cannot go to universities because ofthe high tuition. There are several factors which contribute to these problems. First, the distribution ofresources is unbalanced between rural and urban schools. Second, educational loans for poorstudents are far from enough. Third, the inequality in some schools’ admission policies alsoturns many students away. The education inequality can result in many bad impacts. On onehand, it can affect people’s future employment. On the other hand，it is the root of manysocial problems. To change this situation, I think, we should take the following measures. Firstly, thegovernment’s spending on education should be increased and the allocation of public resourcesgives priority to rural and weak urban schools. Secondly, the implementation of thegovernment financial aid system for students should be accelerated. Thirdly, the governmentshould speed up education reforms to ensure everyone has equal access to schools. 高分替换词32个高分替换词 1) 大多数人 most people→ the majority of the population 2) 经常 often→frequently 3) 我相信 I believe→ from my standpoint, from my perspective 4) 必须 must→ it is a must for us to… 5) 知道 know→ be aware of 6) 因为 because→in that 7) 最后 at last→eventually 8) 然而 but→however 9) 如果 if→provided that 10) 各行各业的人 all kinds of people→people from all walks of life 11) 引起，导致 lead to→contribute to 12) 人 people→individuals 13) 好的 good→desirable, beneficial 14) 坏的 bad→undesirable 15) 很多many→ numerous 16) 越来越 more and more→ a(n) increasing/mounting number of 17) 很 very→extremely 18) 方面 side→aspects 19) 表明 show→demonstrate, indicate 20) 利用 use→utilize 21) 因此/结果 so→therefore 22) 部分 part→proportion 23) 提高 improve→enhance 24) 改变 change→transform 25) 强调/重视 emphasize→ attach great importance to 26) 培养 develop→cultivate 27) 破坏 destroy→undermine 28) 解决 deal with →tackle /figure out 29) 普遍的 everywhere→universal 30) 明显的 obvious→apparent 31) 在当今社会 in the modern society→in the current society 32) 使 make→enable 词组 at the thought of 一想到… as a whole 就整体而论 （in general 就整体而论） at will 随心所欲 be abundant in 富于，富有 （be rich in 富于，富有） access to 能接近，进入，了解 without accident 安全地 of one’s own accord 自愿地 ,主动地 （ without being asked 自愿地 ,主动地） in accord with 与…一致 （ out of one’s accord with 同…不一致） with one accord 一致地 (with everybody agreeing 一致地） in accordance with 依照，根据 (in agreement with 依照，根据） on one’s own account 1) 为了某人的缘故， 为了某人自己的利益 2) (=at one’s own risk) 自行负责 3) (=by oneself)依靠自己 take…into account 把…..考虑进去 give sb. an account of 说明， 解释 (理由) account for 解释， 说明 ​ (give an explanation or reason for 解释） on account of 由于，因为 ​ (because of 由于，因为） on no account 决不 ​ (in no case, for no reason 决不） accuse…of…指控，控告 (charge…with; blame sb. for sth. ; blame sth. on sb. ; complain about 指控，控告） be accustomed to 习惯于 ​ (be used to)习惯于 be acquainted with 了解 act on 奉行，按照…行动; ​ act as 扮演 ​ act for 代理 adapt oneself to 使自己适应于 ​ (adjust oneself to 使自己适应于） adapt…for 改写以适应（新的需要） in addition 此外， 又， 加之 in addition to 除…外 ​ （as well as 除…外） adhere to 粘附; 坚持， 遵循 adjacent(=next to) 毗邻的， 临近的 adjust to (=change slightly)调节; 适应 admit of (=be capable of) …的可能，留有…的余地 in advance (before in time) 预告， 事先 to advantage 有利的，使优点更加突出地 have an advantage over 胜过 have the advantage of 由于…处于有利条件 have the advantage of sb. 知道某人所不知道的事 take advantage of 利用 agree with 赞同(某人意见) ​ agree to 同意 in agreement (with) 同意， 一致 ahead of 在…之前， 超过… ​ ahead of time 提前 in the air 1)悬而未决. 2)在谣传中 above all 尤其是， 最重要的 in all 总共， 总计 after all 毕竟，到底; 1) (not) at all 一点也不; 2) all at once(=suddenly)突然; 3) once and for all 只此一次; 4) above all 最重要的; 5) first of all 首先; 6) all in all 大体上说; 7) be all in 累极了; 8) all but 几乎 allow for (take into consideration) 考虑到， 估计到 amount to总计， 等于。 answer for 对…负责。 conform to 适合，符合。 be anxious about 为…焦急不安; ​ （anxious for） apologize to sb. for sth. 为…向…道歉 appeal to sb. for sth. 为某事向某人呼吁. ​ appeal to sb. 对某人有吸引力 apply for 申请 apply to 与…有关;适用 approve of 赞成 arise from(=be caused by) 由…引起 arrange for sb. to do sth. 安排…做… arrive on 到达; ​ arrive at 到达某地(小地方);获得; ​ arrive in 到达某地(大地方); be ashamed of 以…为羞耻 assure sb. of sth. 向…保证， 使…确信 attach to缚， 系 ,结 make an attempt at doing sth. 试图做… attend to 注意，照顾 ​ attend on 侍候，照料 attitude to/ toward …对…的态度 attribute…to… 把…归因于…，认为…是…的结果 on the average 平均 (be) aware of 意识到，知道 at the back of 在…后面 in the back of 在…后部(里面); ​ on the back of 在…后部(外面) at one’s back 支持，维护; turn one’s back on sb. 不理睬(某人),背弃，抛弃 behind one’s back 背着某人(说坏话) be based on / upon 基于 on the basis of 根据…, 在…基础上 beat…at 在…运动项目上打赢 begin with 以…开始 on behalf of 以…名义 believe in 相信，依赖，信仰。 benefit (from) 受益，得到好处。 for the benefit of 为了…的利益(好处) for the better 好转 get the better of 打败， 胜过。 by birth 在出生上，论出身，按血统 ​ at birth 在出生时 blame sb. for sth. 因…责备某人 ​ blame sth. on sb. 把…推在某人身上 in blossom开花(指树木) on board 到船上，在船上，上火车或飞机 boast of 吹嘘 out of breath 喘不过气来 in brief 简言之 in bulk 成批地，不散装的 take the floor 起立发言 on business 出差办事 be busy with sth.于某事 ​ be busy doing sth. 忙于做某事 last but one 倒数第二 but for 要不是（表示假设） buy sth. for…money 用多少钱买 be capable of 能够， 有能力 be capable of being+过去分词 是能够被…的 in any case 无论如何 in case 万一 in case of 如果发生…万一 in the case of 至于…, 就…而言 in no case 在任何情况下都不 be cautious of 谨防 center one’s attention on 把某人的注意力集中在…上 be certain of (be sure of) 有把握， 一定 for certain of (for sure )肯定地，有把握地 by chance(by accident)偶然","categories":[{"name":"English","slug":"English","permalink":"https://albert-5.cn/categories/English/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://albert-5.cn/tags/英语/"},{"name":"六级","slug":"六级","permalink":"https://albert-5.cn/tags/六级/"},{"name":"作文","slug":"作文","permalink":"https://albert-5.cn/tags/作文/"}]},{"title":"AnyConnect","slug":"AnyConnect","date":"2019-02-28T09:43:44.000Z","updated":"2019-04-29T09:45:40.881Z","comments":true,"path":"2019/02/28/AnyConnect/","link":"","permalink":"https://albert-5.cn/2019/02/28/AnyConnect/","excerpt":"","text":"最近发现使用Cisco AnyConnect在Win8.1上系统上连接VPN时，会出现anyconnect was not able to establish a connection to the specified secure gateway问题导致无法成功连接VPN，错误提示如下所示 problem: AnyConnect was not able to establish a connection to the specified secure gateway. Please try connecting again. 其实解决方法也是很简单的，只需要： 此电脑鼠标右击 -&gt;管理 -&gt;服务于应用程序 -&gt; 服务 -&gt; 禁用 Internet Connection Sharing即可","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"https://albert-5.cn/categories/疑难杂症/"}],"tags":[{"name":"Windows 10","slug":"Windows-10","permalink":"https://albert-5.cn/tags/Windows-10/"},{"name":"VPN","slug":"VPN","permalink":"https://albert-5.cn/tags/VPN/"},{"name":"anyconnect","slug":"anyconnect","permalink":"https://albert-5.cn/tags/anyconnect/"}]},{"title":"CSS","slug":"CSS","date":"2019-01-14T09:34:51.000Z","updated":"2019-04-29T09:39:54.859Z","comments":true,"path":"2019/01/14/CSS/","link":"","permalink":"https://albert-5.cn/2019/01/14/CSS/","excerpt":"","text":"一、CSS概述内容的样式 英文全称: Cascating Style Sheets^注释1 二、CSS语法基本语法格式 p{font-size:#;——&gt;字体大小color:blue; ——–&gt;字体颜色 font-weight:bold;——&gt;加粗} 注意： 1、最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。 2、为了使用样式更加容易阅读，可以将每条代码写在一个新行里。 1、css添加方法a： 行内添加 &lt;!DOCTYPE HTML&gt; 学习笔记CSS篇 &lt;/!doctype&gt; b: 内嵌样式 &lt;!DOCTYPE HTML&gt; p{ color:black;/设置字体颜色/ } 学习笔记CSS篇,内嵌样式的添加 &lt;/!doctype&gt; p{ 1color:#; } c: 单独文件外部样式表文件 style.css p{color：#;} 网页文件 12.html 使用 href 链接到 css文件 单独样式的优点 页面结构HTML代码与样式CSS代码的完全分离，便于维护 如果需要改变网站的风格，只需要修改公共CSS文件即可 可以在同一个HTML文件中引用多个外部样式表 2、 添加方式的优先级_ 多重样式可以层叠，可以覆盖 _ 样式的优先级按照“就近原则” _ 行内样式 &gt; 内嵌样式 &gt; 链接样式 &gt; 浏览器默认样式 三、CSS选择器1、标签选择器采用内嵌式时，以body、h1、p等直接作为标签名 body{background-color:##; text-align:#; font-size:#;} h1{ font:\"黑体\"；font-size:#; } p{ color:#; font-size:\"#\"; } hr{width:220px;} 标题正文的段落版权所有L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"position\":\"left\",\"width\":150,\"height\":300,\"jsonPath\":\"/live2dw/assets/assets/shizuku.model.json\"},\"mobile\":{\"show\":false}}); 2、类别选择器 printf() 1234567891011121314&gt; &lt;style type=&quot;text/css&quot;&gt;&gt; p&#123; font-size:12px;&#125;&gt; .one&#123; font-size:13px;&#125;&gt; .two&#123; font-size:14px;&#125;&gt; &lt;/style&gt;&gt; &lt;body&gt;&gt; &lt;p class=&quot;one&quot;&gt;类型1&lt;/p&gt;&gt; &lt;p class=&quot;two&quot;&gt;类型2&lt;/p&gt;&gt; &lt;p class=&quot;three&quot;&gt;类型3&lt;/p&gt;&gt; &lt;p class=&quot;four&quot;&gt;类型4&lt;/p&gt;&gt; &lt;p class=&quot;five&quot;&gt;类型5&lt;/p&gt;&gt; &lt;p&gt;普通的段落文字&lt;/p&gt;&gt; &lt;/body&gt;&gt; 3、ID选择器printf() 12345678&lt;style type=\"text/css\"&gt; #one&#123;font-size:12px;&#125; #two&#123;font-size:24px;&#125; &lt;/style&gt;&lt;body&gt; &lt;p id=\"one\"&gt;文字1&lt;/p&gt; &lt;p id=\"two\"&gt;文字2&lt;/p&gt;&lt;/body&gt; 4、嵌套声明printf() 12345678&lt;style&gt; p span&#123; color:#; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;&lt;span&gt;学习&lt;/span&gt;&lt;/p&gt;&lt;/body&gt; 5、文本样式格式 属性 描 述 取值 color 文本颜色 red #f00 letter-spacing 字符间距 2px、3px line-height 行高 14px 1.5em 120% text-align 对齐 center left right justify text-decoration 装饰线 none overline underline line-though text-indent 首行缩进 2em 6、背景设置1、背景属性空元素需要先定义元素的高度和宽度 background-color background-image–背景图片 url(“logo.jpg”) background-repecat–背景图片的填充方式 repeat repeat-x(横向填充) repeat-y(纵向填充) no-repeat(填充一次) bacground 2、CSS超链接超链接的四种状态 a:link 普通的、未被访问的链接 a:visited 用户已经访问的链接 a:hover 鼠标指针位于链接的上方悬停 a:active 链接被点击的时刻 :伪类选择器 顺序 a:hover 必须位于a:link 和a:visited之后 a:active 必须位于a:hover之后 3、列表样式 life-style 所有用于列表的属性设置于一个声明之中 list-style-image 为列表项标志设置图像 list-style-position 标志的位置 list-style-type 标志的类型 无序列表ul和有序列表ol 4、表格的样式表格大小 属性 width(宽),height(高) printf() table{ 123width:500px;height:200px; } 表格边框属性boder 123table,td,th&#123; boder:1px solidn#eee&#125; td标签—单元格的样式 th标签—表头的样式 另一个属性 boder-collapse —内外边框重叠问题 123table&#123; boder-collapse:collapse;&#125; 5、CSS表格–奇偶选择器 :nth-child(odd|even)12tr:nth-child(odd)background-color:#EAF2D3; 四、CSS布局和定位问题1、盒子模型概念 页面上的区域、图片、导航、列表、段落都可以是盒子 除了content之外其他的都是属性的名字 1234567891011121314151617181920&gt; &lt;html&gt;&gt; &lt;head&gt;&gt; &lt;style type=\"text/css\"&gt;&gt; #box&#123;&gt; width:100px;&gt; height:100px;&gt; border:1px solid;&gt; padding:20px;&gt; margin:10px;&gt; &#125;&gt; &lt;/style&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;div id=\"box\"&gt;&gt; 你猜啊&gt; &lt;/div&gt;&gt; &lt;/body&gt;&gt; &lt;/html&gt;&gt; &gt; 2、盒子属性 border-width: px thin medium thick border-style:dashaed^注释2 dotted^注释3 solid^注释4 double^注释5 border-color: 颜色 border:width style color 五、CSS定位机制概述：就是盒子的位置 三种定位机制 1、文档流 flow定位：默认的方式 2、浮动 float定位：设置float属性 3、层定位 layer：设置position属性 1、文档流定位1、元素分类 block类型：每个此类型的元素都要独占一行 常见的block元素有： ··· inline类型 : 每个元素不单独占一行，且width height不可设置 常见的inline元素有： –显示为inline元素 display:inline– inline-block类型 : 不单独占据一行，但是可以改变设置 常见的inline-block 元素有： 2、元素转换类型display类型 2、浮动定位float属性 width:200px;height:200px;boder:1px solid red;float:left; 3、层定位概述 像图象软件中的图层一样可以对每个layer进行能够精准定位操作 position 属性：（相对于谁定位） fixed 固定定位 ：相对于浏览器窗口进行定位 relative 相对定位 ：相对于直接父元素进行定位 absotive 绝对定位 ：相对于static定位意外的第一个父元素 六、CSS3续篇1、圆角边框和阴影2、文字与文本 text-shadow属性 ：文本阴影 –水平偏移 垂直偏移 阴影大小 颜色– text-wrap属性 ：允许单词、url强制进行换行 –normal 属性– –break-word 属性– @font-face属性","categories":[{"name":"前端","slug":"前端","permalink":"https://albert-5.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://albert-5.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://albert-5.cn/tags/前端/"}]}]}