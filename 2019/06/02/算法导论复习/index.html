<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', '[object Object]', 'auto');
ga('send', 'pageview');
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="sHO_73a3zHA-ndhyNC1D2d7DNrGbbCjApnFHsV56H8o">
    
    
    
    
    <title>算法导论复习 | Albert</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#C20f0b">
    
    
    <meta name="keywords" content="插入排序,算法导论,最大流问题,KMP算法">
    <meta name="description" content="算法复习  1 插入排序思想： 通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 •Sorting problem:    –Input: A sequence of n numbers a~1~, a~2~, …, a~n~ –Output: A permutation">
<meta name="keywords" content="插入排序,算法导论,最大流问题,KMP算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法导论复习">
<meta property="og:url" content="https://albert-5.cn/2019/06/02/算法导论复习/index.html">
<meta property="og:site_name" content="Albert">
<meta property="og:description" content="算法复习  1 插入排序思想： 通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 •Sorting problem:    –Input: A sequence of n numbers a~1~, a~2~, …, a~n~ –Output: A permutation">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5ceba10f651f696716.png">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5ceba1dd9a94a76116.png">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5ceba889be77034819.png">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5ceba94921f3323702.jpg">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5cebaa7f899e747908.png">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5cebae4968c7253022.png">
<meta property="og:image" content="https://i.loli.net/2019/05/27/5cebb0702d86d20471.png">
<meta property="og:image" content="https://i.loli.net/2019/05/31/5cf11c9d992b622317.png">
<meta property="og:image" content="https://i.loli.net/2019/05/31/5cf11cd82ac6564716.png">
<meta property="og:image" content="https://i.loli.net/2019/05/31/5cf11d99c7bdb91542.png">
<meta property="og:image" content="https://i.loli.net/2019/06/01/5cf1d0afbb57471277.png">
<meta property="og:image" content="https://img-blog.csdn.net/20161210100959132?waterark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20161210103651379?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20161210103733670?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20161210103803780?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20161210103828030?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20161210103845536?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20161210104103615?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://i.loli.net/2019/06/01/5cf1ea551012294327.png">
<meta property="og:image" content="https://i.loli.net/2019/06/01/5cf1ebf9b341b34472.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180612112701509">
<meta property="og:image" content="https://img-blog.csdn.net/20180612112750298">
<meta property="og:image" content="https://img-blog.csdn.net/20180612113041548">
<meta property="og:image" content="https://img-blog.csdn.net/20170212231637204?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ2NzA0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20160915154406936">
<meta property="og:image" content="https://img-blog.csdn.net/20140819173639786">
<meta property="og:image" content="https://img-blog.csdn.net/20140819173649739">
<meta property="og:image" content="https://img-blog.csdn.net/20140725231726921">
<meta property="og:image" content="https://img-blog.csdn.net/20140721222801918">
<meta property="og:image" content="https://img-blog.csdn.net/20140721230250468">
<meta property="og:updated_time" content="2019-06-23T15:28:06.707Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法导论复习">
<meta name="twitter:description" content="算法复习  1 插入排序思想： 通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动 •Sorting problem:    –Input: A sequence of n numbers a~1~, a~2~, …, a~n~ –Output: A permutation">
<meta name="twitter:image" content="https://i.loli.net/2019/05/27/5ceba10f651f696716.png">
    
        <link rel="alternate" type="application/atom+xml" title="Albert" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<!-- 导入音乐插件js -->
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">albert</h5>
          <a href="mailto:981287080@qq.com" title="981287080@qq.com" class="mail">981287080@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Albert-5" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.weibo.com/5973922558/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/Music" target="_blank">
                <i class="icon icon-lg icon-music"></i>
                Music
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/desktop">
                <i class="icon icon-lg icon-desktop"></i>
                Desktop
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/picture">
                <i class="icon icon-lg icon-camera"></i>
                Camera
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Starky35793281" target="_blank">
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about">
                <i class="icon icon-lg icon-link"></i>
                About me
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">算法导论复习</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">算法导论复习</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-06-02T06:22:04.000Z" itemprop="datePublished" class="page-time">
  2019-06-02
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>

            
        </h5>
    </div>

    

    
</header>

<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-插入排序"><span class="post-toc-number">1.</span> <span class="post-toc-text">1 插入排序</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-时间复杂度描述"><span class="post-toc-number">2.</span> <span class="post-toc-text">2 时间复杂度描述</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-分治思想"><span class="post-toc-number">3.</span> <span class="post-toc-text">3 分治思想</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-快速排序"><span class="post-toc-number">4.</span> <span class="post-toc-text">4 快速排序</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#5-Dynamic-programming-动态规划"><span class="post-toc-number">5.</span> <span class="post-toc-text">5 Dynamic programming 动态规划</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#6-贪心算法"><span class="post-toc-number">6.</span> <span class="post-toc-text">6 贪心算法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#7-最大流问题"><span class="post-toc-number">7.</span> <span class="post-toc-text">7 最大流问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#8-字符串匹配"><span class="post-toc-number">8.</span> <span class="post-toc-text">8 字符串匹配</span></a></li></ol>
        </nav>
    </aside>


<article id="post-算法导论复习" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">算法导论复习</h1>
        <div class="post-meta">
			

          

            <time class="post-time" title="2019-06-02 14:22:04" datetime="2019-06-02T06:22:04.000Z" itemprop="datePublished">2019-06-02</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法/">算法</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>



        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <center>算法复习</center>

<h5 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1 插入排序"></a>1 插入排序</h5><p><strong>思想：</strong></p>
<p><strong>通过构建有序序列，对于未排列的数据，在已经排好序的数列中从后向前进行扫描，找到相应的位置并插入，插入排序在实现上，在从后向前扫描的过程中，需要反复把已经排序元素逐步向后移动</strong></p>
<p>•Sorting problem: </p>
<blockquote>
<ul>
<li>–<strong>Input:</strong> A sequence of <em>n</em> numbers <em>a</em>~1~, <em>a</em>~2~, …, a~n~</li>
<li>–<strong>Output:</strong> A permutation   (reordering) <em>a’</em>~1~, <em>a’</em>~2~, …, <em>a’</em>~n~ of the input sequence such that</li>
</ul>
<p>a’~1~&lt;=a’~2~ &lt;= … &lt;=a’~n~</p>
</blockquote>
<p>•An instance of the sorting problem</p>
<blockquote>
<p>–Input: 8 2 4 9 3 6</p>
<p>–Output: 2 3 4 6 8 9</p>
</blockquote>
<p>•Notation:</p>
<blockquote>
<p>–Sorting is a fundamental operation in CS</p>
<p>–A large number of good sorting algorithms have been D&amp;R</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/05/27/5ceba10f651f696716.png" alt="算法描述" title>
                </div>
                <div class="image-caption">算法描述</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/05/27/5ceba1dd9a94a76116.png" alt="伪代码" title>
                </div>
                <div class="image-caption">伪代码</div>
            </figure>
<p>具体python代码实现参考<a href="https://albert-5.cn/2019/03/28/sort-algorithm/">博客文章</a></p>
<p>时间复杂度的问题：</p>
<p>•<strong>Worst-case:</strong> (usually) </p>
<blockquote>
<p>–T(n) = maximum time of algorithm on any input of size n. </p>
<center>T(n)=maxI {T(n,I)}</center>

<p>–Time Complexity (Default )</p>
</blockquote>
<p>•<strong>Average-case:</strong> (sometimes) </p>
<blockquote>
<p>–T(n) = expected time of algorithm over all inputs of size n. </p>
<p>–Need assumption of statistical distribution of inputs. </p>
<center>?</center> 
</blockquote>
<p>•<strong>Best-case:</strong> (bogus虚假) </p>
<blockquote>
<p>–Cheat with a slow algorithm that works fast on <em>some</em> input.</p>
<center>?</center>
</blockquote>
<h5 id="2-时间复杂度描述"><a href="#2-时间复杂度描述" class="headerlink" title="2 时间复杂度描述"></a>2 时间复杂度描述</h5><p>$$<br>\Theta(n) \quad既有上界又有下界<br>$$</p>
<p>•<strong>Engineering:</strong> </p>
<blockquote>
<p>–Drop low-order terms; ignore leading constants.  </p>
</blockquote>
<p>example:<br>$$<br>3n^3 + 90n^2 –5n + 6046 = Θ(n3)<br>$$</p>
<p>$$<br>O(n)\quad 只有上界<br>$$</p>
<p>$$<br>Ω(n)\quad 只有下界<br>$$</p>
<hr>
<h5 id="3-分治思想"><a href="#3-分治思想" class="headerlink" title="3 分治思想"></a>3 分治思想</h5><p>recursively  递归</p>
<p>subproblems  子问题</p>
<p><strong>median</strong>  中位数</p>
<ul>
<li><p>Merge sort</p>
<blockquote>
<p>•Problem:</p>
<blockquote>
<p>–Input: A[1,n]</p>
<p>–Output: A[1,n] in sorted order</p>
</blockquote>
<p>•Divide-and-conquer paradigm</p>
<blockquote>
<p>–<strong>Divide:</strong> Divide the <em>n</em>-element sequence to be sorted into two subsequences of <em>n</em>/2 elements each.</p>
<p>–<strong>Conquer:</strong> Sort the two subsequences recursively using merge sort.</p>
<p>–<strong>Combine:</strong> Merge the two sorted subsequences to produce the sorted answer.</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5ceba889be77034819.png" alt="1558947965911"></p>
<p><img src="https://i.loli.net/2019/05/27/5ceba94921f3323702.jpg" alt="1558947965911"></p>
<ul>
<li><p>Recursion tree递归树解决递归式问题</p>
<p><strong>例子</strong>：<br>$$<br>Solve \quad T(n)=2T(n)+cn,\quad where c&gt;0\quad is \quad constant<br>$$</p>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/05/27/5cebaa7f899e747908.png" alt="1558947965911" title>
                </div>
                <div class="image-caption">1558947965911</div>
            </figure>
<h5 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4 快速排序"></a>4 快速排序</h5><p>思想:</p>
<p>​    通过一趟排序将要排序的数据分割成<strong>独立的两部分</strong>，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>前言介绍</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/05/27/5cebae4968c7253022.png" alt="1558947965911" title>
                </div>
                <div class="image-caption">1558947965911</div>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PARTITION (A,  p,  r)  # A是待排序数组</span><br><span class="line">	x ← A[r]</span><br><span class="line">	i  ← p-1</span><br><span class="line">	FOR j ← p TO r-1</span><br><span class="line">		IF A[ j] ≤ x</span><br><span class="line">			THEN i ← i + 1</span><br><span class="line">				  exchange A[i] ↔ A[ j]</span><br><span class="line">	exchange A[i+1] ↔ A[r]</span><br><span class="line">	RETURN i+1</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/05/27/5cebb0702d86d20471.png" alt="1558947965911" title>
                </div>
                <div class="image-caption">1558947965911</div>
            </figure>
<p>​        <strong>the run time drops from Ω(n log <em>n</em>) to Ω(n^2^)</strong></p>
<p><strong>提高快速排序的方法</strong></p>
<p>Median-of-three(三平均分区法)</p>
<blockquote>
<p>关于这一改进的最简单的描述大概是这样的：与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：<br>　　（1） 首先，它使得最坏情况发生的几率减小了。<br>　　（2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。</p>
</blockquote>
<p>提高的方法可以说是这样的：</p>
<blockquote>
<p>首先对整个列表的元素进行选取，第一个位置first，中间位置middle，最后一个位置的元素last，然后以这三个数的中位数（以middle）为基准，对列表剩余的元素进行比较采用插入排序进行sort，这样一来，左边的元素都是小于middle的元素，右边的元素都是大于middle的元素；</p>
<p>然后在对middle左边的元素进行上述操作，对右边进行上述操作，直至待排的元素个数为1。</p>
<p>至此，整个排序也就完成了；</p>
</blockquote>
<h5 id="5-Dynamic-programming-动态规划"><a href="#5-Dynamic-programming-动态规划" class="headerlink" title="5 Dynamic programming 动态规划"></a>5 Dynamic programming 动态规划</h5><p><strong>Rod cutting</strong></p>
<p>Given a rod of length n inches and a table of prices pi for i = 1,2,3,…,n, determine the maximum revenue(收入) r(n) obtainable by cutting up the rod and<br>selling the pieces.</p>
<blockquote>
<p>给定长度为n英寸的杆和i = 1,2,3，…，n的价格表p~i~，确定通过切割杆和杆可获得的最大收入r(n)来销售。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/31/5cf11c9d992b622317.png" alt="问题描述"></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/05/31/5cf11cd82ac6564716.png" alt="问题描述" title>
                </div>
                <div class="image-caption">问题描述</div>
            </figure>
<p><img src="https://i.loli.net/2019/05/31/5cf11d99c7bdb91542.png" alt="Nothing" title="哈哈"></p>
<p><a href="https://blog.csdn.net/qq_27139155/article/details/79725084" target="_blank" rel="noopener">拓展阅读</a></p>
<h5 id="6-贪心算法"><a href="#6-贪心算法" class="headerlink" title="6 贪心算法"></a>6 贪心算法</h5><p>是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的<strong>算法</strong>；比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种<strong>贪心算法</strong>。 <strong>贪心算法</strong>在有最优子结构的问题中尤为有效；</p>
<p>通常情况下，贪心算法采用自顶向下的设计，因为不需要作出过多的选择求解所有子问题；</p>
<p><strong>找零钱问题</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Change</span>-Making Problem</span><br><span class="line"></span><br><span class="line">Finding the <span class="built_in">number</span> <span class="keyword">of</span> ways <span class="keyword">of</span> making changes</span><br><span class="line"><span class="keyword">for</span> a particular amount <span class="keyword">of</span> cents, n, <span class="keyword">using</span> a given</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">of</span> denominations C=&#123;c1…cd&#125; (e.g, the US</span><br><span class="line">coin <span class="keyword">system</span>: &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line">– An example: n = <span class="number">4</span>,C = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, solutions: &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;.</span><br><span class="line"> Minimizing the <span class="built_in">number</span> <span class="keyword">of</span> coins returned <span class="keyword">for</span> a</span><br><span class="line">particular quantity <span class="keyword">of</span> <span class="keyword">change</span> (available coins</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;)</span><br><span class="line">– <span class="number">30</span> Cents (solution: <span class="number">25</span> + <span class="number">5</span>, two coins)</span><br><span class="line">– <span class="number">67</span> Cents ?</span><br><span class="line"> <span class="number">17</span> cents given denominations = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;?</span><br></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/06/01/5cf1d0afbb57471277.png" alt="算法" title>
                </div>
                <div class="image-caption">算法</div>
            </figure>
<p><strong>活动选择</strong></p>
<p>有一个需要使用每个资源的N个活动组成的集合S ={a1, a2, ···, an},资源每次只能由一个活动使用。每个活动都有一个开始时间和si和结束时间fi，且0=&lt;si&lt;=fi&lt;∞，一旦被选择后，活动ai就只占据时间[si, fi]，如果[si,fi]和[sj,fi]不重叠，则称ai、aj兼容。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 活动选取的贪心算法</span></span><br><span class="line">Greedy-Activity-Selector(s, f)</span><br><span class="line">    <span class="attr">n</span> = s.length</span><br><span class="line">    <span class="attr">A</span> = &#123;a1&#125;</span><br><span class="line">    <span class="attr">k</span> = <span class="number">1</span></span><br><span class="line">    for <span class="attr">m</span> = <span class="number">2</span> to n</span><br><span class="line">        <span class="keyword">if</span> s[m] &gt;= f[k] <span class="comment"># 时间的比较</span></span><br><span class="line">            <span class="attr">A</span> = A U &#123;am&#125;</span><br><span class="line">            <span class="attr">k</span> = m</span><br><span class="line">    return A</span><br></pre></td></tr></table></figure>
<p><strong>最优子结构</strong></p>
<p><strong>如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。</strong>贪心算法要做的就是逐步求取局部最优解，以致达到全局整体最优。</p>
<p><strong>赫夫曼编码</strong></p>
<p>讨论赫夫曼编码问题，<strong>赫夫曼编码的思想就是变长编码；也就是说让字符表中出现概率高的字符的编码长度尽可能的小，而出现概率高的字符的编码相对较长；</strong>然后遵循前缀码的要求，<strong>即是任意一个编码都不是其他编码的前缀</strong>，便于解码。</p>
<blockquote>
<p>作者：JeffCoding<br>原文：<a href="https://blog.csdn.net/jeffleo/article/details/53557143" target="_blank" rel="noopener">https://blog.csdn.net/jeffleo/article/details/53557143</a> </p>
</blockquote>
<p>赫夫曼编码是一种广泛用于数据压缩的问题，该算法的主要优势在于节约了存储和传输成本。<br>举一个例子：<br>假设要传输的数据为</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210100959132?waterark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 0" title>
                </div>
                <div class="image-caption">Figure 0</div>
            </figure>
<p>那么传输成本就是：<br>45<em>3 + 30 </em> 3 + 29 <em> 3 + 10 </em> 3 + 8 <em> 3 + 5 </em> 3 = 381个字符</p>
<p>我们可以使用赫夫曼编码思想来解决<br>先合并最小频率的2个字符对应的子树，计算合并后的子树的频率；<br>重新排序各个子树；<br>重复步骤1<br>重复步骤2<br>对二叉树中的边赋予0、1，得到各字符的变长编码。<br>对于上举的例子而言就是：<br>EF最小，首先构造EF的生成树，重新排序</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210103651379?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 1" title>
                </div>
                <div class="image-caption">Figure 1</div>
            </figure>
<p>构造EF 和 D的生成树，重新排序</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210103733670?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 2" title>
                </div>
                <div class="image-caption">Figure 2</div>
            </figure>
<p>构造EFD 和 C 的生成树, 重新排序</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210103803780?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 3" title>
                </div>
                <div class="image-caption">Figure 3</div>
            </figure>
<p>构造EFDC 和 B 的生成树，重新排序</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210103828030?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 4" title>
                </div>
                <div class="image-caption">Figure 4</div>
            </figure>
<p>构造EFDCB 和 A 的生成树，重新排序</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210103845536?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 5" title>
                </div>
                <div class="image-caption">Figure 5</div>
            </figure>
<p>赫夫曼编码后的二进制数据为：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20161210104103615?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Figure 6" title>
                </div>
                <div class="image-caption">Figure 6</div>
            </figure>
<p>可以看见，利用赫夫曼思想设计之后，频率高的字符，二进制码短了，频率低的字符，二进制码长了，这样就有效得减少了总得二进制码数。</p>
<p>那么传输成本就是：<br>45<em>1 + 30 </em> 2 + 29 <em> 3 + 10 </em> 4 + 8 <em> 5 + 5 </em> 5 = 292个字符，节约了23%的成本！</p>
<center>End</center>

<hr>
<h5 id="7-最大流问题"><a href="#7-最大流问题" class="headerlink" title="7 最大流问题"></a>7 最大流问题</h5><p><strong>流网络</strong></p>
<p>digraph G=(V,E)</p>
<p>weights, called capacities on edge c(u,v)边缘容量</p>
<p>two distinct vertices (不同的顶点)</p>
<p>source, ‘s’; sink ‘t’</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/06/01/5cf1ea551012294327.png" alt="流网络" title>
                </div>
                <div class="image-caption">流网络</div>
            </figure>
<p>The value of a flow is the net flow out of the source:<br>$$<br>\sum p(s,v)-\sum p(v,s)<br>$$<br><strong>流网络流出的值是净网络</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/06/01/5cf1ebf9b341b34472.png" alt="网络的值" title>
                </div>
                <div class="image-caption">网络的值</div>
            </figure>
<center>The value of this flow is 1-0+2=3</center>

<p><strong>残存网络</strong></p>
<p>假定有一个流网络G=（V，E），其源点为s，汇点为t，f为G中的一个流。对即诶点对u，v，定义<strong>残存容量（residual capacity）<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20180612112701509" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure></strong>，有：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20180612112750298" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>残存网络可能包含图G中不存在的边，残存网络中的反向边允许算法将已经发送出来的流量发送回去。一个残存网络示例图如下：</p>
<p>Rabin-KarpRabin-Karp<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20180612113041548" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure></p>
<blockquote>
<p>图a是一个流网络，b是a对应的残存网络，注意每条边上的值，残存网络中针对<strong>每条正向边计算出该条边在存在流的情况下的剩余容量，并画出一条反向边，反向边的容量即是发出流的大小</strong>，方便将发出的流运输回发送地，并将权重为0的边省略。</p>
</blockquote>
<h5 id="8-字符串匹配"><a href="#8-字符串匹配" class="headerlink" title="8 字符串匹配"></a>8 字符串匹配</h5><p><strong>Rabin-Karp算法</strong></p>
<p>在实际应用中，Rabin-Karp算法的预处理时间为O（m）,并且在最坏的情况下的时间复杂度为O((n-m+1)m),相对于朴素字符串，它的运行时是比较好的。</p>
<p>整个<strong>算法思想</strong>介绍如下：</p>
<p>数学中有霍纳法则,我们运用霍纳法则在O(m)内计算p： </p>
<p>p=P[m]+10(P[m-1]+10(P[m-2]+…+10(P[2]+10P1)…))) </p>
<p>霍纳法则的解释如下：</p>
<p> <img src="https://img-blog.csdn.net/20170212231637204?watermar/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ2NzA0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>运用霍纳法则，类似的我们也可以根据T[s+1…s+m]计算出t. </p>
<p>但为了节约时间，我们可以利用一下方法在常数时间内根据ts,计算出ts+1.具体过程如下图解: </p>
<p> 如图所示，ts=31415,ts+1=14152,则 </p>
<p>ts+1=(ts-(T[s+1]=3)<em>10^(m=4))</em>10+(T[s+m+1]=2) </p>
<p>注：(ts-(T[s+1]=3)*10^(m=4))=31415-30000=1415 </p>
<p>即 ts+1=10(ts-10^(m-1)T[s+1])+T[s+m+1] </p>
<p>在计算过程中，可能会出现p与t的值过大，可以取模运算</p>
<p><strong>确定优先状态自动机</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20160915154406936" alt="有限自动状态机" title>
                </div>
                <div class="image-caption">有限自动状态机</div>
            </figure>
<p>上面这个图描述的就叫一个有限状态自动机，图中两个圆圈，也叫节点，用于表示状态，从图中可以看成，它有两个状态，分别叫0和1. 从每个节点出发，都会有若干条边，当处于某个状态时，如果输入的字符跟该节点出发的某条边的内容一样，那么就会引起状态的转换。例如，如果当前状态处于0，输入是字符a,那么状态机就会从状态0进入状态1.如果当前状态是1，输入字符是b或a,那么，状态机就会从状态1进入状态0.如果当前所处的状态，没有出去的边可以应对输入的字符，那么状态机便会进入到错误状态。例如，如果当前处于状态0，输入字符是c,那么状态机就会出错，因为从状态0开始，没有哪条边对应的字符是c。</p>
<p>状态机会有一个初始节点，和一个接收节点，以上图为例，我们可以设置初始节点为0，接收节点为1，当进行一系列的输入，使得状态机的状态不断变化，只要最后一个输入使得状态机处于接收节点，那么就表明当前输入可以被状态机接收。例如对应字符串”abaaa”, 从初始节点0开始，状态机根据该字符串的输入所形成的状态变化序列为：{0，1，0，1，0，1}。由于最后状态机处于状态1，所以该字符串可以被状态机接收。如果输入的字符串是:abbaa, 那么状态机的变化序列为：{0，1，0，0，1，0}， 由于最后状态机处于非接收状态，因此这个字符串被状态机拒绝。</p>
<p> 在程序中，使用<strong>二维表</strong>表示一个状态机：</p>
<table>
<thead>
<tr>
<th><strong>输入</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>状态0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>状态1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>接下来我们看看一个文本的匹配流程，假定要查找的字符串为P=”ababaca”, 被查找的文本为T=”abababacaba”. 一次读入T的一个字符，用S表示当前读入的T的字符，一开始读入一个字符，于是S=a.然后看看，从P开始，连续几个字符所构成的字符串可以成为S的后缀，由于当前S只有一个字符a,于是从P开始，连续1个字符所形成的字符串”a”,可以作为S的后缀。把这个字符串的长度记为k,于是此时k 等于1. 继续从T中读入字符，于是S=”ab”, 此时，从P开始，连续两个字符所构成的字符串”ab”可以作为S的后缀，于是k = 2.反复这么操作，于是便有以下序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S=a, k = <span class="number">1</span>, P[<span class="number">1</span>] 是S的后缀</span><br><span class="line">S=ab, k = <span class="number">2</span>, P[<span class="number">1</span>,<span class="number">2</span>] 是S的后缀</span><br><span class="line">S=aba, k = <span class="number">3</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]是S的后缀</span><br><span class="line">S=abab, k= <span class="number">4</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]是S的后缀</span><br><span class="line">S=ababa, k = <span class="number">5</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]是S的后缀</span><br><span class="line">S=ababab, k = <span class="number">4</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]是S的后缀</span><br><span class="line">S=abababa, k = <span class="number">5</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]是S的后缀</span><br><span class="line">S=abababac, k = <span class="number">6</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]是S的后缀</span><br><span class="line">S=abababaca, k = <span class="number">7</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]是S的后缀</span><br><span class="line">S=abababacab, k =<span class="number">2</span>, P[<span class="number">1</span>,<span class="number">2</span>] 是S的后缀</span><br><span class="line">S=abababacaba, k = <span class="number">3</span>, P[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 是S的后缀。</span><br></pre></td></tr></table></figure>
<p>从上述过程中，我们可以看到第九步的时候字符串P已经成为了S的后缀，此时的S是文本T的前缀，因此可以说明在字符串T中找到了模式串P。</p>
<p>如果问题变化，构造一个方法，使得一次运行便能知道从P开始，连续读取几个字符能使得这几个字符构成的字符串是S的后缀。这个方法，就需要上面我们提到的有限状态自动机了</p>
<p><strong>用于字符串匹配的自动机</strong></p>
<p>假定字符串P和文本T只由a,b两个字符组成，也就是字符集为∑={a,b,c}, P含有m个字母，于是，我们要构造的自动机就含有m个状态节点。假设我们当前处于状态节点q, 那么当下一个输入字符是a和b时，从当前节点q该跳转到哪一个节点呢？ 如果用$P_q$来表示长度为q的P的前缀，以q=4, p=”ababaca”, $P_q$ =”abab”, 那么当处于状态4, 当输入为a时，我们构造字符串 S = $P_q$ + ‘a’ = “ababa”, 然后看看字符串P从第一个字符开始，连续几个字符所构成的字符串可以成为S的后缀，就当前S为例，从第一个字符开始，连续5个字符，也就是P[1,2,3,4,5]可以作为S的后缀，于是，我们就有，当状态机处于节点4，输入为a时，跳转的下个状态就是5. 同理，当处于状态q=4,输入为字符b时，S = $P_q$ + ‘b’ = “ababb”,此时从P开始，连续读取0个字符才能形成S的后缀，于是当状态机处于状态4，如果读入字符是b, 那么跳转的下一个状态是0，同理，如果输入字符是c, 那么S = $P_q$ + ‘c’ = “ababc”, 此时从P开始，连续读取0个字符所形成的空字符串才能作为S的后缀，于是当状态机处于状态节点4，输入字符为c时，跳转到节点0. 如果q从0开始，一直到m,反复运用刚才提到的步骤，便会产生下面这个跳转表：</p>
<table>
<thead>
<tr>
<th><strong>输入</strong></th>
<th><strong>a</strong></th>
<th><strong>b</strong></th>
<th><strong>c</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>状态0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>状态1</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>状态2</td>
<td>3</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>状态3</td>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>状态4</td>
<td>5</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>状态5</td>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>状态6</td>
<td>7</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>状态7</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>状态I就是上面介绍的K的值，也就是P中形成的字符串可以构成S的后缀的长度；</p>
<p><strong>KMP算法</strong></p>
<p>算法流程</p>
<ul>
<li><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p>
<ul>
<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。<ul>
<li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。</li>
</ul>
</li>
</ul>
<p>next数组的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀，例如如果next[j]=k,代表j之前的字符串中有最大长度为k的相同前缀后缀。</p>
</li>
</ul>
<p>此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符；</p>
<p><strong>步骤</strong></p>
<p><strong>①</strong> 寻找前缀后缀的最大公共元素长度</p>
<ul>
<li>对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：</li>
</ul>
<p>  <img src="https://img-blog.csdn.net/20140819173639786" alt="img"></p>
<p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k+1 = 2）。</p>
<p><strong>②</strong> 求next数组</p>
<ul>
<li><p>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示</p>
<p><img src="https://img-blog.csdn.net/20140819173649739" alt="img"></p>
</li>
</ul>
<p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）</p>
<p><strong>补充</strong></p>
<p>寻找最长前缀后缀</p>
<p>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20140725231726921" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（<strong>下简称《最大长度表》</strong>）：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20140721222801918" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>而且，根据这个表可以得出下述结论</p>
<p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值<br>    上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p>
<p>给定字符串“ABCDABD”，可求得它的next 数组如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdn.net/20140721230250468" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>把next 数组跟之前求得的最大长度表对比后，不难发现，<strong>next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1</strong>。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p>
  <center>kmp算法的复杂度是O(n+m)</center>











<p><strong>参考文章</strong></p>
<p><a href="https://blog.csdn.net/tyler_download/article/details/52549315" target="_blank" rel="noopener">https://blog.csdn.net/tyler_download/article/details/52549315</a> </p>
<p><a href="https://blog.csdn.net/v_july_v/article/details/7041827#t5" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827#t5</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-06-23T15:28:06.707Z" itemprop="dateUpdated">2019-06-23 23:28:06</time>
</span><br>


        
        <br><br><b><center>版权声明</center></b><br><strong>作者：</strong> Albert <br> <strong>来源：</strong> <a href="https://albert-5.cn">Albert小破站</a> <br><strong>本文地址</strong>：<a href="/2019/06/02/算法导论复习/" target="_blank" rel="external">https://albert-5.cn/2019/06/02/算法导论复习/</a>，转载请务必注明<font color="indigo"><strong>作者</strong>和<strong>来源</strong></font>
        
    </div>
    
    <footer>
        <a href="https://albert-5.cn">
            <img src="/img/avatar.jpg" alt="albert">
            albert
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KMP算法/">KMP算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/插入排序/">插入排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/最大流问题/">最大流问题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法导论/">算法导论</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://albert-5.cn/2019/06/02/算法导论复习/&title=《算法导论复习》 — Albert&pic=https://albert-5.cn/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://albert-5.cn/2019/06/02/算法导论复习/&title=《算法导论复习》 — Albert&source=欢迎光顾本站~" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://albert-5.cn/2019/06/02/算法导论复习/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《算法导论复习》 — Albert&url=https://albert-5.cn/2019/06/02/算法导论复习/&via=https://albert-5.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://albert-5.cn/2019/06/02/算法导论复习/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/06/12/Wechat爬取好友信息/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Wechat爬取好友信息</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/06/01/网络流Network-Flow/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">网络流Network_Flow</h4>
      </a>
    </div>
  
</nav>



    

	


	


	


	
    <!-- Valine Comments -->
    <section class="comments" id="comments" style="margin-top:40px;padding:1px 15px 1px 10px;background-color:rgba(255,255,255,0.7);box-shadow: 0px 0px 20px #bbbbbb;border-radius: 5px;">
    </section>
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'false',
            verify: 'false' == 'false',
            appId: "INtYRvGKRn1Ey9323UGJz7gk-gzGzoHsz",
            appKey: "sruYEhxHh1hJxo04K2Gd8heb",
            avatar: "monsterid",
            placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
		console.log("Valine done!")
		 
    </script>
    <!-- Valine Comments end -->


	


	



</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢老板~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>albert &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
    
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://albert-5.cn/2019/06/02/算法导论复习/&title=《算法导论复习》 — Albert&pic=https://albert-5.cn/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://albert-5.cn/2019/06/02/算法导论复习/&title=《算法导论复习》 — Albert&source=欢迎光顾本站~" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://albert-5.cn/2019/06/02/算法导论复习/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《算法导论复习》 — Albert&url=https://albert-5.cn/2019/06/02/算法导论复习/&via=https://albert-5.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://albert-5.cn/2019/06/02/算法导论复习/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aSW4jMRAEQP3/0xpgTgaM7sksto0RGTwJbS0MHsqs5fWK1/vv+vr66/r+/P5T3/969Z6HFwYGxscy3rcr/4HkG+6PJjmyy51gYGAcwMiDbPLO+zB6/+T+2y6fY2BgYCwAkt/Kr48YGBgYK2H0/pqYbHp2fBgYGOcw8hS0vdLlR5BcGR/IxTEwMD6QMWsM/M7rH+9vYGBg/PeMd7naYll7WRzuCgMDY2vGrCg/a1i2oxt5SQ4DA2NvRjvatVJQa4tr+acwMDBOYLRJbD6QkYxrzJqaGBgY5zDyjc5KZu0W24QWAwPjHEbbklwZp8iHJ5I25+V/DwwMjI0YsxS0PaeV0Y3ogDAwMLZmzC5q7aafKqtFCTAGBsZhjCTktRe7tsFQJ8kYGBibMpJNrDxJktXZ1jEwME5gzIYhngqR7W9dBn0MDIytGe0gRdvsnA1ktCMdGBgYezPyQn8+yLUSmpMS3j/ybwwMjCMZr9FqS/+zRikGBsYJjJXwN2tk5seUh3UMDIy9Gfl2k03Pcug24GJgYJzMSL50Vu7P0938Cnh5w8XAwNiO0ZbvZ6G2Hbaob7UYGBhbM97lmiWiK+Nl0XAGBgbG1oyfKPS3V8B2sGOlXYGBgfG5jDxxXS/3r4xWRM1LDAyMrRmzINiW6tpAnBwBBgYGxqxMnxf6H2uIYmBgYNxu4tmgjIGBgXHFyBPLvCjWjlC0x4eBgXEO43caA7O2QRLoMTAwtmb8ASuz/vX63ZrIAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>



 <!-- 添加百度统计js -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4099fc41b7fab35703d6ee8152506fa9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>


<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)哦吼!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



<!-- 插入音乐插件js文件 -->
<script src="//cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    <!-- 爱心点击特效 -->
    <script type="text/javascript" src="/js/click.js"></script>
    
    <!-- 社会主义核心价值观点击特效 -->
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <script type="text/javascript">
        /* 鼠标点击特效 - 7Core.CN */
        var a_idx = 0;jQuery(document).ready(function($) {$("body").click(function(e) {var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正" ,"法治", "爱国", "敬业", "诚信", "友善");var $i = $("<span/>").text(a[a_idx]);
        a_idx = (a_idx + 1) % a.length;var x = e.pageX,y = e.pageY;$i.css({"z-index": 100000000,"top": y - 20,"left": x,"position": "absolute","font-weight": "bold","color": "#C20f0b"});$("body").append($i);$i.animate({"top": y - 180,"opacity": 0},1500,function() {$i.remove();});});});
    </script>
    

    <script src="//code.tidio.co/dhfi5clsw9dl27z5yr9nyrnwtuqc4zhv.js"></script>
    
    <!-- weather -->
 <!--    <script type="text/javascript">WIDGET = {FID: 'rNrYhPQIei'}</script>
    <script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>
 -->


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"position":"left","width":150,"height":300,"jsonPath":"/live2dw/assets/assets/shizuku.model.json"},"mobile":{"show":false}});</script></body>
</html>
